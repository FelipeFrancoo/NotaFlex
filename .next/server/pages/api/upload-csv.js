"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/upload-csv";
exports.ids = ["pages/api/upload-csv"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "papaparse":
/*!****************************!*\
  !*** external "papaparse" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("papaparse");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "formidable":
/*!*****************************!*\
  !*** external "formidable" ***!
  \*****************************/
/***/ ((module) => {

module.exports = import("formidable");;

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fupload-csv&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cupload-csv.ts&middlewareConfigBase64=e30%3D!":
/*!**************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fupload-csv&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cupload-csv.ts&middlewareConfigBase64=e30%3D! ***!
  \**************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\upload-csv.ts */ \"(api)/./pages/api/upload-csv.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/upload-csv\",\n        pathname: \"/api/upload-csv\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRnVwbG9hZC1jc3YmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZwYWdlcyU1Q2FwaSU1Q3VwbG9hZC1jc3YudHMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ0w7QUFDMUQ7QUFDd0Q7QUFDeEQ7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLHFEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxxREFBUTtBQUNwQztBQUNPLHdCQUF3QixnSEFBbUI7QUFDbEQ7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQscUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3RhZmxleC1uZXh0anMvPzk2YmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzXFxcXGFwaVxcXFx1cGxvYWQtY3N2LnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvdXBsb2FkLWNzdlwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3VwbG9hZC1jc3ZcIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiBcIlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fupload-csv&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cupload-csv.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./lib/storage.ts":
/*!************************!*\
  !*** ./lib/storage.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   storage: () => (/* binding */ storage)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n// lib/storage.ts\n\n\nclass PersistentStorage {\n    constructor(){\n        this.data = {};\n        this.filePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"temp\", \"storage_cache.json\");\n        this.ensureDirectoryExists();\n        this.loadFromFile();\n    }\n    ensureDirectoryExists() {\n        const dir = path__WEBPACK_IMPORTED_MODULE_1___default().dirname(this.filePath);\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(dir)) {\n            fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(dir, {\n                recursive: true\n            });\n        }\n    }\n    loadFromFile() {\n        try {\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(this.filePath)) {\n                const content = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(this.filePath, \"utf-8\");\n                this.data = JSON.parse(content);\n                console.log(\"[STORAGE] Dados carregados do cache:\", Object.keys(this.data));\n            }\n        } catch (error) {\n            console.warn(\"[STORAGE] Erro ao carregar cache:\", error);\n            this.data = {};\n        }\n    }\n    saveToFile() {\n        try {\n            fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(this.filePath, JSON.stringify(this.data, null, 2));\n            console.log(\"[STORAGE] Dados salvos no cache:\", Object.keys(this.data));\n        } catch (error) {\n            console.warn(\"[STORAGE] Erro ao salvar cache:\", error);\n        }\n    }\n    get(key) {\n        return this.data[key];\n    }\n    set(key, value) {\n        this.data[key] = value;\n        this.saveToFile();\n        console.log(`[STORAGE] Definido ${key}:`, typeof value === \"object\" ? JSON.stringify(value).substring(0, 100) + \"...\" : value);\n    }\n    delete(key) {\n        delete this.data[key];\n        this.saveToFile();\n    }\n    keys() {\n        return Object.keys(this.data);\n    }\n    clear() {\n        this.data = {};\n        this.saveToFile();\n    }\n}\n// Criar instância singleton\nconst persistentStorage = new PersistentStorage();\n// Proxy para manter compatibilidade com sintaxe de array\nconst storage = new Proxy(persistentStorage, {\n    get (target, prop) {\n        if (typeof prop === \"string\") {\n            // Se for um método da classe, retornar o método\n            if (typeof target[prop] === \"function\") {\n                return target[prop].bind(target);\n            }\n            // Caso contrário, tratar como chave de dados\n            return target.get(prop);\n        }\n        return target[prop];\n    },\n    set (target, prop, value) {\n        if (typeof prop === \"string\") {\n            target.set(prop, value);\n            return true;\n        }\n        return false;\n    },\n    deleteProperty (target, prop) {\n        if (typeof prop === \"string\") {\n            target.delete(prop);\n            return true;\n        }\n        return false;\n    },\n    ownKeys (target) {\n        return target.keys();\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtJQUNBVCxLQUFJUSxNQUFNLEVBQUVDLElBQXFCLEVBQUVSLEtBQUs7UUFDdEMsSUFBSSxPQUFPUSxTQUFTLFVBQVU7WUFDNUJELE9BQU9SLEdBQUcsQ0FBQ1MsTUFBTVI7WUFDakIsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBQ0FVLGdCQUFlSCxNQUFNLEVBQUVDLElBQXFCO1FBQzFDLElBQUksT0FBT0EsU0FBUyxVQUFVO1lBQzVCRCxPQUFPTCxNQUFNLENBQUNNO1lBQ2QsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBQ0FHLFNBQVFKLE1BQU07UUFDWixPQUFPQSxPQUFPaEIsSUFBSTtJQUNwQjtBQUNGLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3RhZmxleC1uZXh0anMvLi9saWIvc3RvcmFnZS50cz81ZGM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9zdG9yYWdlLnRzXHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuaW50ZXJmYWNlIFN0b3JhZ2VEYXRhIHtcclxuICBba2V5OiBzdHJpbmddOiBhbnk7XHJcbn1cclxuXHJcbmNsYXNzIFBlcnNpc3RlbnRTdG9yYWdlIHtcclxuICBwcml2YXRlIGRhdGE6IFN0b3JhZ2VEYXRhID0ge307XHJcbiAgcHJpdmF0ZSBmaWxlUGF0aDogc3RyaW5nO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuZmlsZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RlbXAnLCAnc3RvcmFnZV9jYWNoZS5qc29uJyk7XHJcbiAgICB0aGlzLmVuc3VyZURpcmVjdG9yeUV4aXN0cygpO1xyXG4gICAgdGhpcy5sb2FkRnJvbUZpbGUoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZW5zdXJlRGlyZWN0b3J5RXhpc3RzKCkge1xyXG4gICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKHRoaXMuZmlsZVBhdGgpO1xyXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcclxuICAgICAgZnMubWtkaXJTeW5jKGRpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGxvYWRGcm9tRmlsZSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKHRoaXMuZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLmZpbGVQYXRoLCAndXRmLTgnKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbU1RPUkFHRV0gRGFkb3MgY2FycmVnYWRvcyBkbyBjYWNoZTonLCBPYmplY3Qua2V5cyh0aGlzLmRhdGEpKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdbU1RPUkFHRV0gRXJybyBhbyBjYXJyZWdhciBjYWNoZTonLCBlcnJvcik7XHJcbiAgICAgIHRoaXMuZGF0YSA9IHt9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzYXZlVG9GaWxlKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLmZpbGVQYXRoLCBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEsIG51bGwsIDIpKTtcclxuICAgICAgY29uc29sZS5sb2coJ1tTVE9SQUdFXSBEYWRvcyBzYWx2b3Mgbm8gY2FjaGU6JywgT2JqZWN0LmtleXModGhpcy5kYXRhKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1tTVE9SQUdFXSBFcnJvIGFvIHNhbHZhciBjYWNoZTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQoa2V5OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcclxuICB9XHJcblxyXG4gIHNldChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkge1xyXG4gICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgIHRoaXMuc2F2ZVRvRmlsZSgpO1xyXG4gICAgY29uc29sZS5sb2coYFtTVE9SQUdFXSBEZWZpbmlkbyAke2tleX06YCwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKS5zdWJzdHJpbmcoMCwgMTAwKSArICcuLi4nIDogdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZGVsZXRlKGtleTogc3RyaW5nKSB7XHJcbiAgICBkZWxldGUgdGhpcy5kYXRhW2tleV07XHJcbiAgICB0aGlzLnNhdmVUb0ZpbGUoKTtcclxuICB9XHJcblxyXG4gIGtleXMoKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhKTtcclxuICB9XHJcblxyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5kYXRhID0ge307XHJcbiAgICB0aGlzLnNhdmVUb0ZpbGUoKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIENyaWFyIGluc3TDom5jaWEgc2luZ2xldG9uXHJcbmNvbnN0IHBlcnNpc3RlbnRTdG9yYWdlID0gbmV3IFBlcnNpc3RlbnRTdG9yYWdlKCk7XHJcblxyXG4vLyBQcm94eSBwYXJhIG1hbnRlciBjb21wYXRpYmlsaWRhZGUgY29tIHNpbnRheGUgZGUgYXJyYXlcclxuZXhwb3J0IGNvbnN0IHN0b3JhZ2UgPSBuZXcgUHJveHkocGVyc2lzdGVudFN0b3JhZ2UsIHtcclxuICBnZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcgfCBzeW1ib2wpIHtcclxuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgLy8gU2UgZm9yIHVtIG3DqXRvZG8gZGEgY2xhc3NlLCByZXRvcm5hciBvIG3DqXRvZG9cclxuICAgICAgaWYgKHR5cGVvZiAodGFyZ2V0IGFzIGFueSlbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gKHRhcmdldCBhcyBhbnkpW3Byb3BdLmJpbmQodGFyZ2V0KTtcclxuICAgICAgfVxyXG4gICAgICAvLyBDYXNvIGNvbnRyw6FyaW8sIHRyYXRhciBjb21vIGNoYXZlIGRlIGRhZG9zXHJcbiAgICAgIHJldHVybiB0YXJnZXQuZ2V0KHByb3ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICh0YXJnZXQgYXMgYW55KVtwcm9wXTtcclxuICB9LFxyXG4gIHNldCh0YXJnZXQsIHByb3A6IHN0cmluZyB8IHN5bWJvbCwgdmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdGFyZ2V0LnNldChwcm9wLCB2YWx1ZSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wOiBzdHJpbmcgfCBzeW1ib2wpIHtcclxuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdGFyZ2V0LmRlbGV0ZShwcm9wKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuICBvd25LZXlzKHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHRhcmdldC5rZXlzKCk7XHJcbiAgfVxyXG59KTtcclxuIl0sIm5hbWVzIjpbImZzIiwicGF0aCIsIlBlcnNpc3RlbnRTdG9yYWdlIiwiY29uc3RydWN0b3IiLCJkYXRhIiwiZmlsZVBhdGgiLCJqb2luIiwicHJvY2VzcyIsImN3ZCIsImVuc3VyZURpcmVjdG9yeUV4aXN0cyIsImxvYWRGcm9tRmlsZSIsImRpciIsImRpcm5hbWUiLCJleGlzdHNTeW5jIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwiY29udGVudCIsInJlYWRGaWxlU3luYyIsIkpTT04iLCJwYXJzZSIsImNvbnNvbGUiLCJsb2ciLCJPYmplY3QiLCJrZXlzIiwiZXJyb3IiLCJ3YXJuIiwic2F2ZVRvRmlsZSIsIndyaXRlRmlsZVN5bmMiLCJzdHJpbmdpZnkiLCJnZXQiLCJrZXkiLCJzZXQiLCJ2YWx1ZSIsInN1YnN0cmluZyIsImRlbGV0ZSIsImNsZWFyIiwicGVyc2lzdGVudFN0b3JhZ2UiLCJzdG9yYWdlIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwiYmluZCIsImRlbGV0ZVByb3BlcnR5Iiwib3duS2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./lib/storage.ts\n");

/***/ }),

/***/ "(api)/./pages/api/upload-csv.ts":
/*!*********************************!*\
  !*** ./pages/api/upload-csv.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var formidable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! formidable */ \"formidable\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! papaparse */ \"papaparse\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lib_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/storage */ \"(api)/./lib/storage.ts\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_5__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([formidable__WEBPACK_IMPORTED_MODULE_0__]);\nformidable__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n// Função para parsing de datas CSV (EXATA)\nfunction parseCSVDate(dateStr) {\n    const formats = [\n        /(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/,\n        /(\\d{4})-(\\d{1,2})-(\\d{1,2})/\n    ];\n    for (const format of formats){\n        const match = dateStr.match(format);\n        if (match) {\n            if (format === formats[0]) {\n                // DD/MM/YYYY - formato brasileiro\n                return new Date(parseInt(match[3]), parseInt(match[2]) - 1, parseInt(match[1]));\n            } else {\n                // YYYY-MM-DD - formato ISO\n                return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));\n            }\n        }\n    }\n    return new Date(dateStr); // Fallback\n}\n// Função auxiliar para semana (EXATA)\nfunction getWeekBoundaries(date) {\n    const dayOfWeek = date.getDay();\n    const weekStart = new Date(date);\n    weekStart.setDate(date.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1)); // Monday\n    weekStart.setHours(0, 0, 0, 0);\n    const weekEnd = new Date(weekStart);\n    weekEnd.setDate(weekStart.getDate() + 6); // Sunday\n    weekEnd.setHours(23, 59, 59, 999);\n    return {\n        weekStart,\n        weekEnd\n    };\n}\n// Função para parsing de valores monetários\nfunction parseMonetaryValue(str) {\n    let cleanValue = str.replace(/[R$\\s]/g, \"\").replace(/\\./g, \"\").replace(\",\", \".\");\n    const isNegative = cleanValue.startsWith(\"-\");\n    if (isNegative) {\n        cleanValue = cleanValue.substring(1);\n    }\n    const value = parseFloat(cleanValue);\n    return isNegative ? -value : value;\n}\n// Função para detectar encoding\nfunction detectEncoding(buffer) {\n    const encodings = [\n        \"utf-8\",\n        \"latin1\",\n        \"ascii\",\n        \"utf16le\"\n    ];\n    for (const encoding of encodings){\n        try {\n            const decoded = buffer.toString(encoding);\n            // Verificar se contém caracteres especiais brasileiros\n            if (decoded.includes(\"\\xe7\") || decoded.includes(\"\\xe3\") || decoded.includes(\"\\xe9\")) {\n                return encoding;\n            }\n        } catch (error) {\n            continue;\n        }\n    }\n    return \"utf-8\"; // fallback\n}\n// Função para extrair transacionador e documento seguindo especificação EXATA\nfunction extrairTransacionadorEDocumento(csvContent, documentType, nomeFilial) {\n    // Parse CSV sem headers\n    const parseResult = papaparse__WEBPACK_IMPORTED_MODULE_2___default().parse(csvContent, {\n        header: false,\n        skipEmptyLines: true\n    });\n    const rows = parseResult.data;\n    const documentosExtraidos = [];\n    // Processar cada linha do CSV\n    for (const row of rows){\n        // VALIDAÇÃO ESTRUTURAL OBRIGATÓRIA\n        if (!Array.isArray(row) || row.length < 5) continue;\n        const category = row[0]?.toString().trim() || \"\";\n        let dateStr = \"\";\n        let transacionador = \"\";\n        let numeroDocumento = \"\";\n        let valueStr = \"\";\n        // LÓGICA DE IDENTIFICAÇÃO POR TIPO DE DOCUMENTO\n        if (documentType === \"A_PAGAR\") {\n            // Match EXATO - não usar includes()\n            if (category !== \"Contas a pagar- \\xc0 vencer\") continue;\n            // MAPEAMENTO FIXO DAS COLUNAS:\n            dateStr = row[1]?.toString().trim() || \"\"; // COLUNA 1: Data Vencimento\n            transacionador = row[2]?.toString().trim() || \"\"; // COLUNA 2: TRANSACIONADOR\n            numeroDocumento = row[3]?.toString().trim() || \"\"; // COLUNA 3: NÚMERO DO DOCUMENTO\n            valueStr = row[5]?.toString().trim() || \"0\"; // COLUNA 5: Valor (SEMPRE coluna 5)\n        } else if (documentType === \"A_RECEBER\") {\n            // Match EXATO - não usar includes()\n            if (category !== \"Contas a receber - A vencer\") continue;\n            // MAPEAMENTO FIXO DAS COLUNAS:\n            dateStr = row[1]?.toString().trim() || \"\"; // COLUNA 1: Data Vencimento\n            transacionador = row[2]?.toString().trim() || \"\"; // COLUNA 2: TRANSACIONADOR\n            numeroDocumento = row[3]?.toString().trim() || \"\"; // COLUNA 3: NÚMERO DO DOCUMENTO\n            valueStr = row[5]?.toString().trim() || \"0\"; // COLUNA 5: Valor (SEMPRE coluna 5)\n        }\n        // VALIDAÇÕES OBRIGATÓRIAS DOS DADOS EXTRAÍDOS\n        if (!dateStr || !transacionador || !valueStr) continue;\n        // PARSING DA DATA DE VENCIMENTO\n        const date = parseCSVDate(dateStr);\n        if (!date || isNaN(date.getTime())) continue;\n        // PARSING DO VALOR MONETÁRIO (formato brasileiro)\n        let cleanValue = valueStr.replace(/[R$\\s]/g, \"\").replace(/\\./g, \"\").replace(\",\", \".\");\n        const isNegative = cleanValue.startsWith(\"-\");\n        if (isNegative) {\n            cleanValue = cleanValue.substring(1);\n        }\n        const value = parseFloat(cleanValue);\n        if (isNaN(value) || value <= 0) continue;\n        // APLICAÇÃO DE FALLBACKS PARA CAMPOS OBRIGATÓRIOS\n        const transacionadorFinal = transacionador || \"FORNECEDOR N\\xc3O IDENTIFICADO\";\n        const numeroDocumentoFinal = numeroDocumento || \"\"; // Removido fallback 'PENDENTE'\n        // ESTRUTURA FINAL DOS DADOS EXTRAÍDOS\n        const { weekStart, weekEnd } = getWeekBoundaries(date);\n        documentosExtraidos.push({\n            dataVencimento: date,\n            transacionador: transacionadorFinal,\n            numeroDocumento: numeroDocumentoFinal,\n            valor: value,\n            valorOriginal: valueStr,\n            categoria: documentType,\n            filial: nomeFilial,\n            // Dados de compatibilidade\n            weekStart: weekStart,\n            weekEnd: weekEnd,\n            sourceFile: `${nomeFilial}.csv`\n        });\n    }\n    return documentosExtraidos;\n}\n// Configuração para desabilitar o parser padrão do Next.js\nconst config = {\n    api: {\n        bodyParser: false\n    }\n};\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            message: \"Method not allowed\"\n        });\n    }\n    try {\n        // Opcional: limpar dados anteriores se solicitado\n        if (req.query.clearData === \"true\") {\n            _lib_storage__WEBPACK_IMPORTED_MODULE_4__.storage.delete(\"summaryData\");\n            _lib_storage__WEBPACK_IMPORTED_MODULE_4__.storage.delete(\"processedData\");\n        }\n        console.log(\"=== DEBUG UPLOAD CSV ===\");\n        console.log(\"Method:\", req.method);\n        console.log(\"Content-Type:\", req.headers[\"content-type\"]);\n        console.log(\"Headers:\", JSON.stringify(req.headers, null, 2));\n        // Garantir que a pasta temp existe\n        const tempDir = \"./temp\";\n        if (!fs__WEBPACK_IMPORTED_MODULE_1___default().existsSync(tempDir)) {\n            fs__WEBPACK_IMPORTED_MODULE_1___default().mkdirSync(tempDir, {\n                recursive: true\n            });\n        }\n        // Configurar formidable para upload de múltiplos arquivos\n        const form = (0,formidable__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            uploadDir: tempDir,\n            keepExtensions: true,\n            maxFiles: 10,\n            maxFileSize: 10 * 1024 * 1024\n        });\n        const [fields, files] = await form.parse(req);\n        console.log(\"=== PARSED DATA ===\");\n        console.log(\"Fields:\", JSON.stringify(fields, null, 2));\n        console.log(\"Files keys:\", Object.keys(files));\n        console.log(\"Files structure:\", JSON.stringify(files, null, 2));\n        // Obter tipos de documento selecionados\n        let selectedTypes = [\n            \"A_PAGAR\",\n            \"A_RECEBER\"\n        ]; // Default\n        if (fields.documentTypes && fields.documentTypes.length > 0) {\n            const documentTypesString = fields.documentTypes[0];\n            console.log(\"documentTypesString recebido:\", documentTypesString);\n            try {\n                // Tentar fazer parse se for JSON\n                const parsed = JSON.parse(documentTypesString);\n                console.log(\"JSON parsed:\", parsed);\n                if (Array.isArray(parsed)) {\n                    selectedTypes = parsed;\n                } else if (typeof parsed === \"object\") {\n                    // Se for um objeto com indices, extrair os valores e flatten\n                    const allTypes = [];\n                    Object.values(parsed).forEach((typeArray)=>{\n                        if (Array.isArray(typeArray)) {\n                            allTypes.push(...typeArray);\n                        }\n                    });\n                    // Remover duplicatas\n                    const uniqueTypes = Array.from(new Set(allTypes));\n                    selectedTypes = uniqueTypes;\n                }\n            } catch (e) {\n                console.log(\"Erro no parse JSON:\", e);\n                // Se não for JSON, usar como array direto\n                selectedTypes = Array.isArray(fields.documentTypes) ? fields.documentTypes : [\n                    documentTypesString\n                ];\n            }\n        }\n        console.log(\"Selected types processados:\", selectedTypes);\n        // NORMALIZAÇÃO ROBUSTA DE ARQUIVOS (multi-field, multi-file)\n        const allFiles = Object.values(files).flat().filter(Boolean);\n        console.log(\"=== FILE PROCESSING ===\");\n        console.log(\"allFiles (normalizado):\", allFiles.map((f)=>({\n                originalFilename: f.originalFilename,\n                path: f.filepath\n            })));\n        console.log(\"allFiles length:\", allFiles.length);\n        // Filtrar apenas arquivos CSV - sendo mais permissivo para debug\n        const csvFiles = allFiles.filter((file)=>{\n            console.log(\"Checking file:\", file ? {\n                originalFilename: file.originalFilename,\n                mimetype: file.mimetype,\n                size: file.size,\n                filepath: file.filepath\n            } : \"null file\");\n            if (!file || !file.originalFilename) return false;\n            // Aceitar .csv ou .txt (alguns sistemas exportam assim), case insensitive\n            return /\\.(csv|txt)$/i.test(file.originalFilename);\n        });\n        console.log(\"=== FILTERING RESULTS ===\");\n        console.log(\"CSV Files found:\", csvFiles.length);\n        console.log(\"Selected types:\", selectedTypes);\n        console.log(\"CSV Files details:\", csvFiles.map((f)=>f ? {\n                name: f.originalFilename,\n                type: f.mimetype,\n                size: f.size\n            } : null));\n        if (csvFiles.length === 0) {\n            console.log(\"=== ERROR: NO FILES ===\");\n            console.log(\"No CSV files found after filtering\");\n            return res.status(400).json({\n                success: false,\n                message: `Nenhum arquivo foi encontrado. Arquivos recebidos: ${allFiles.length}. Verifique se o arquivo é um CSV válido.`\n            });\n        }\n        const allTransactions = [];\n        const allFilesData = [];\n        const allFilesResults = [];\n        // Processar cada arquivo CSV\n        for (const file of csvFiles){\n            console.log(`=== PROCESSING FILE: ${file?.originalFilename} ===`);\n            if (!file || !file.filepath) {\n                console.log(\"Skipping invalid file:\", file);\n                continue;\n            }\n            try {\n                console.log(\"File path:\", file.filepath);\n                console.log(\"File exists:\", fs__WEBPACK_IMPORTED_MODULE_1___default().existsSync(file.filepath));\n                const buffer = fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(file.filepath);\n                const encoding = detectEncoding(buffer);\n                const csvContent = buffer.toString(encoding);\n                // Extrair nome da filial\n                const branchName = (file.originalFilename || \"FILIAL_DESCONHECIDA\").replace(/\\.(csv|txt)$/i, \"\").toUpperCase();\n                const fileTransactions = [];\n                // Processar cada tipo de documento selecionado usando a nova lógica\n                for (const documentType of selectedTypes){\n                    console.log(`Processando tipo de documento: ${documentType} para arquivo: ${file.originalFilename}`);\n                    // Usar a função de extração específica com a lógica correta\n                    const documentosExtraidos = extrairTransacionadorEDocumento(csvContent, documentType, branchName);\n                    console.log(`Documentos extraídos para ${documentType}:`, documentosExtraidos.length);\n                    // Log dos primeiros documentos para debug\n                    if (documentosExtraidos.length > 0) {\n                        console.log(\"Primeiros documentos extra\\xeddos:\", documentosExtraidos.slice(0, 3).map((doc)=>({\n                                transacionador: doc.transacionador,\n                                numeroDocumento: doc.numeroDocumento,\n                                valor: doc.valor,\n                                dataVencimento: doc.dataVencimento.toLocaleDateString(\"pt-BR\")\n                            })));\n                    }\n                    // Converter para o formato TransactionData (manter compatibilidade)\n                    for (const doc of documentosExtraidos){\n                        const transaction = {\n                            date: doc.dataVencimento,\n                            supplier: doc.transacionador,\n                            docNumber: doc.numeroDocumento,\n                            value: doc.valor,\n                            category: documentType === \"A_PAGAR\" ? \"Contas a pagar- \\xc0 vencer\" : \"Contas a receber - A vencer\",\n                            branch: doc.filial,\n                            documentType: doc.categoria,\n                            sourceFile: file.originalFilename || `${branchName}.csv`\n                        };\n                        fileTransactions.push(transaction);\n                        allTransactions.push(transaction);\n                    }\n                }\n                allFilesData.push({\n                    filename: file.originalFilename,\n                    branch: branchName,\n                    transactions: fileTransactions,\n                    totalTransactions: fileTransactions.length\n                });\n                // Agregação individual por arquivo\n                const branchTotalsMap = new Map();\n                const dailyTotalsMap = new Map();\n                let totalPayable = 0;\n                let totalReceivable = 0;\n                let grandTotalValue = 0;\n                fileTransactions.forEach((transaction)=>{\n                    const { branch, date, value, documentType } = transaction;\n                    const { weekStart, weekEnd } = getWeekBoundaries(date);\n                    const branchKey = branch;\n                    if (!branchTotalsMap.has(branchKey)) {\n                        branchTotalsMap.set(branchKey, {\n                            invoiceCount: 0,\n                            totalValue: 0,\n                            weekStart,\n                            weekEnd\n                        });\n                    }\n                    const branchTotal = branchTotalsMap.get(branchKey);\n                    branchTotal.invoiceCount++;\n                    branchTotal.totalValue += value;\n                    const dateKey = `${branch}-${date.toISOString().split(\"T\")[0]}`;\n                    const dayOfWeek = [\n                        \"Domingo\",\n                        \"Segunda\",\n                        \"Ter\\xe7a\",\n                        \"Quarta\",\n                        \"Quinta\",\n                        \"Sexta\",\n                        \"S\\xe1bado\"\n                    ][date.getDay()];\n                    if (!dailyTotalsMap.has(dateKey)) {\n                        dailyTotalsMap.set(dateKey, {\n                            date,\n                            dayOfWeek,\n                            totalValue: 0,\n                            invoiceCount: 0,\n                            branch\n                        });\n                    }\n                    const dailyTotal = dailyTotalsMap.get(dateKey);\n                    dailyTotal.totalValue += value;\n                    dailyTotal.invoiceCount++;\n                    if (documentType === \"A_PAGAR\") {\n                        totalPayable += value;\n                    } else if (documentType === \"A_RECEBER\") {\n                        totalReceivable += value;\n                    }\n                    grandTotalValue += value;\n                });\n                const branchTotals = Array.from(branchTotalsMap.entries()).map(([branch, data])=>({\n                        id: (0,crypto__WEBPACK_IMPORTED_MODULE_5__.randomUUID)(),\n                        branch,\n                        invoiceCount: data.invoiceCount,\n                        totalValue: `R$ ${data.totalValue.toLocaleString(\"pt-BR\", {\n                            minimumFractionDigits: 2\n                        })}`,\n                        weekStart: data.weekStart,\n                        weekEnd: data.weekEnd\n                    }));\n                const dailyTotals = Array.from(dailyTotalsMap.values()).map((data)=>({\n                        id: (0,crypto__WEBPACK_IMPORTED_MODULE_5__.randomUUID)(),\n                        ...data,\n                        totalValue: `R$ ${data.totalValue.toLocaleString(\"pt-BR\", {\n                            minimumFractionDigits: 2\n                        })}`\n                    }));\n                const workingDaysTotal = dailyTotals.filter((d)=>![\n                        0,\n                        6\n                    ].includes(d.date.getDay())).reduce((sum, d)=>sum + parseMonetaryValue(d.totalValue), 0);\n                const weekendTotal = dailyTotals.filter((d)=>[\n                        0,\n                        6\n                    ].includes(d.date.getDay())).reduce((sum, d)=>sum + parseMonetaryValue(d.totalValue), 0);\n                const workingDays = dailyTotals.filter((d)=>![\n                        0,\n                        6\n                    ].includes(d.date.getDay())).length;\n                const weekendDays = dailyTotals.filter((d)=>[\n                        0,\n                        6\n                    ].includes(d.date.getDay())).length;\n                const minDate = fileTransactions.length > 0 ? new Date(Math.min(...fileTransactions.map((t)=>t.date.getTime()))) : new Date();\n                const maxDate = fileTransactions.length > 0 ? new Date(Math.max(...fileTransactions.map((t)=>t.date.getTime()))) : new Date();\n                allFilesResults.push({\n                    filename: file.originalFilename,\n                    branch: branchName,\n                    processedData: {\n                        branchTotals,\n                        dailyTotals,\n                        weeklyTotals: {\n                            workingDaysTotal: `R$ ${workingDaysTotal.toLocaleString(\"pt-BR\", {\n                                minimumFractionDigits: 2\n                            })}`,\n                            weekendTotal: `R$ ${weekendTotal.toLocaleString(\"pt-BR\", {\n                                minimumFractionDigits: 2\n                            })}`,\n                            weekTotal: `R$ ${grandTotalValue.toLocaleString(\"pt-BR\", {\n                                minimumFractionDigits: 2\n                            })}`,\n                            workingDays,\n                            weekendDays,\n                            weekPeriod: `${minDate.toLocaleDateString(\"pt-BR\")} - ${maxDate.toLocaleDateString(\"pt-BR\")}`,\n                            totalPayable,\n                            totalReceivable\n                        },\n                        grandTotal: `R$ ${grandTotalValue.toLocaleString(\"pt-BR\", {\n                            minimumFractionDigits: 2\n                        })}`,\n                        totalInvoices: fileTransactions.length\n                    }\n                });\n                // Limpar arquivo temporário\n                if (file.filepath && fs__WEBPACK_IMPORTED_MODULE_1___default().existsSync(file.filepath)) {\n                    fs__WEBPACK_IMPORTED_MODULE_1___default().unlinkSync(file.filepath);\n                }\n            } catch (processFileErr) {\n                console.error(\"Erro ao processar arquivo individual, continuando com os demais:\", file?.originalFilename, processFileErr);\n                continue;\n            }\n        }\n        // Agregação de dados\n        const branchTotalsMap = new Map();\n        const dailyTotalsMap = new Map();\n        let totalPayable = 0;\n        let totalReceivable = 0;\n        let grandTotalValue = 0;\n        // Processar transações para agregação\n        allTransactions.forEach((transaction)=>{\n            const { branch, date, value, documentType } = transaction;\n            // Atualizar totais por filial\n            const { weekStart, weekEnd } = getWeekBoundaries(date);\n            const branchKey = branch;\n            if (!branchTotalsMap.has(branchKey)) {\n                branchTotalsMap.set(branchKey, {\n                    invoiceCount: 0,\n                    totalValue: 0,\n                    weekStart,\n                    weekEnd\n                });\n            }\n            const branchTotal = branchTotalsMap.get(branchKey);\n            branchTotal.invoiceCount++;\n            branchTotal.totalValue += value;\n            // Atualizar totais diários\n            const dateKey = `${branch}-${date.toISOString().split(\"T\")[0]}`;\n            const dayOfWeek = [\n                \"Domingo\",\n                \"Segunda\",\n                \"Ter\\xe7a\",\n                \"Quarta\",\n                \"Quinta\",\n                \"Sexta\",\n                \"S\\xe1bado\"\n            ][date.getDay()];\n            if (!dailyTotalsMap.has(dateKey)) {\n                dailyTotalsMap.set(dateKey, {\n                    date,\n                    dayOfWeek,\n                    totalValue: 0,\n                    invoiceCount: 0,\n                    branch\n                });\n            }\n            const dailyTotal = dailyTotalsMap.get(dateKey);\n            dailyTotal.totalValue += value;\n            dailyTotal.invoiceCount++;\n            // Atualizar totais por tipo\n            if (documentType === \"A_PAGAR\") {\n                totalPayable += value;\n            } else if (documentType === \"A_RECEBER\") {\n                totalReceivable += value;\n            }\n            grandTotalValue += value;\n        });\n        // Converter Maps para arrays\n        const branchTotals = Array.from(branchTotalsMap.entries()).map(([branch, data])=>({\n                id: (0,crypto__WEBPACK_IMPORTED_MODULE_5__.randomUUID)(),\n                branch,\n                invoiceCount: data.invoiceCount,\n                totalValue: `R$ ${data.totalValue.toLocaleString(\"pt-BR\", {\n                    minimumFractionDigits: 2\n                })}`,\n                weekStart: data.weekStart,\n                weekEnd: data.weekEnd\n            }));\n        const dailyTotals = Array.from(dailyTotalsMap.values()).map((data)=>({\n                id: (0,crypto__WEBPACK_IMPORTED_MODULE_5__.randomUUID)(),\n                ...data,\n                totalValue: `R$ ${data.totalValue.toLocaleString(\"pt-BR\", {\n                    minimumFractionDigits: 2\n                })}`\n            }));\n        // Calcular totais semanais\n        const workingDaysTotal = dailyTotals.filter((d)=>![\n                0,\n                6\n            ].includes(d.date.getDay())) // Não domingo/sábado\n        .reduce((sum, d)=>sum + parseMonetaryValue(d.totalValue), 0);\n        const weekendTotal = dailyTotals.filter((d)=>[\n                0,\n                6\n            ].includes(d.date.getDay())) // Domingo/sábado\n        .reduce((sum, d)=>sum + parseMonetaryValue(d.totalValue), 0);\n        const workingDays = dailyTotals.filter((d)=>![\n                0,\n                6\n            ].includes(d.date.getDay())).length;\n        const weekendDays = dailyTotals.filter((d)=>[\n                0,\n                6\n            ].includes(d.date.getDay())).length;\n        const minDate = allTransactions.length > 0 ? new Date(Math.min(...allTransactions.map((t)=>t.date.getTime()))) : new Date();\n        const maxDate = allTransactions.length > 0 ? new Date(Math.max(...allTransactions.map((t)=>t.date.getTime()))) : new Date();\n        const processedData = {\n            branchTotals,\n            dailyTotals,\n            weeklyTotals: {\n                workingDaysTotal: `R$ ${workingDaysTotal.toLocaleString(\"pt-BR\", {\n                    minimumFractionDigits: 2\n                })}`,\n                weekendTotal: `R$ ${weekendTotal.toLocaleString(\"pt-BR\", {\n                    minimumFractionDigits: 2\n                })}`,\n                weekTotal: `R$ ${grandTotalValue.toLocaleString(\"pt-BR\", {\n                    minimumFractionDigits: 2\n                })}`,\n                workingDays,\n                weekendDays,\n                weekPeriod: `${minDate.toLocaleDateString(\"pt-BR\")} - ${maxDate.toLocaleDateString(\"pt-BR\")}`,\n                totalPayable,\n                totalReceivable\n            },\n            grandTotal: `R$ ${grandTotalValue.toLocaleString(\"pt-BR\", {\n                minimumFractionDigits: 2\n            })}`,\n            totalInvoices: allTransactions.length,\n            transactions: allTransactions.map((transaction)=>({\n                    vencimento: transaction.date.toLocaleDateString(\"pt-BR\"),\n                    transacionador: transaction.supplier,\n                    documento: transaction.docNumber,\n                    valor: `R$ ${transaction.value.toLocaleString(\"pt-BR\", {\n                        minimumFractionDigits: 2\n                    })}`,\n                    valorNumerico: transaction.value,\n                    documentType: transaction.documentType,\n                    filial: transaction.branch,\n                    sourceFile: transaction.sourceFile // nome original do arquivo\n                }))\n        };\n        // Cache dos dados processados para exportação posterior sem precisar reenviar pelo frontend\n        try {\n            const cachePath = path__WEBPACK_IMPORTED_MODULE_3___default().join(tempDir, \"last_processed.json\");\n            fs__WEBPACK_IMPORTED_MODULE_1___default().writeFileSync(cachePath, JSON.stringify(processedData, null, 2), \"utf8\");\n        } catch (cacheErr) {\n            console.warn(\"N\\xe3o foi poss\\xedvel salvar cache de processedData:\", cacheErr);\n        }\n        // ===== INÍCIO: GERAÇÃO DE summaryData PARA /api/export-summary-excel =====\n        try {\n            // Guardar processedData em memória também\n            _lib_storage__WEBPACK_IMPORTED_MODULE_4__.storage.set(\"processedData\", processedData);\n            const branchMap = {};\n            const dateTotalsMap = {};\n            processedData.transactions.forEach((tr)=>{\n                const branch = tr.filial || tr.sourceFile?.replace(/\\.csv$/i, \"\") || \"DESCONHECIDA\";\n                if (!branchMap[branch]) branchMap[branch] = {\n                    pagar: 0,\n                    receber: 0\n                };\n                if (tr.documentType === \"A_PAGAR\") branchMap[branch].pagar += tr.valorNumerico;\n                else if (tr.documentType === \"A_RECEBER\") branchMap[branch].receber += tr.valorNumerico;\n                // Totais por data (usando apenas A_PAGAR para manter consistência com resumo anterior)\n                if (tr.documentType === \"A_PAGAR\") {\n                    const dateStr = tr.vencimento; // já em DD/MM/YYYY\n                    if (!dateTotalsMap[dateStr]) dateTotalsMap[dateStr] = 0;\n                    dateTotalsMap[dateStr] += tr.valorNumerico;\n                }\n            });\n            const branchesSummary = Object.entries(branchMap).map(([name, v])=>({\n                    name,\n                    totalAPagar: v.pagar,\n                    totalAReceber: v.receber,\n                    total: v.pagar + v.receber\n                }));\n            // Construir dateSpecificTotals ordenado\n            const dateSpecificTotals = Object.entries(dateTotalsMap).map(([day, total])=>({\n                    day,\n                    total\n                })).filter((d)=>/\\d{1,2}\\/\\d{1,2}\\/\\d{4}/.test(d.day)).sort((a, b)=>{\n                const [da, ma, ya] = a.day.split(\"/\").map(Number);\n                const [db, mb, yb] = b.day.split(\"/\").map(Number);\n                return new Date(ya, ma - 1, da).getTime() - new Date(yb, mb - 1, db).getTime();\n            });\n            // DocumentDates com dia da semana (apenas dias úteis)\n            const documentDates = dateSpecificTotals.map((d)=>{\n                const [day, month, year] = d.day.split(\"/\").map(Number);\n                const date = new Date(year, month - 1, day);\n                const dayNames = [\n                    \"Domingo\",\n                    \"Segunda\",\n                    \"Ter\\xe7a\",\n                    \"Quarta\",\n                    \"Quinta\",\n                    \"Sexta\",\n                    \"S\\xe1bado\"\n                ];\n                return {\n                    day: d.day,\n                    dayOfWeek: dayNames[date.getDay()],\n                    total: d.total,\n                    date\n                };\n            }).filter((item)=>{\n                const dow = item.date.getDay();\n                return dow >= 1 && dow <= 5; // dias úteis\n            }).sort((a, b)=>a.date.getTime() - b.date.getTime()).map(({ day, dayOfWeek, total })=>({\n                    day,\n                    dayOfWeek,\n                    total\n                }));\n            const grandTotalAPagar = branchesSummary.reduce((s, b)=>s + b.totalAPagar, 0);\n            const grandTotalAReceber = branchesSummary.reduce((s, b)=>s + b.totalAReceber, 0);\n            const grandTotal = dateSpecificTotals.reduce((s, d)=>s + d.total, 0);\n            const summaryData = {\n                branches: branchesSummary,\n                dailyTotals: [],\n                documentDates,\n                dateSpecificTotals,\n                grandTotal,\n                grandTotalAPagar,\n                grandTotalAReceber,\n                totalAPagar: grandTotalAPagar\n            };\n            _lib_storage__WEBPACK_IMPORTED_MODULE_4__.storage.set(\"summaryData\", summaryData);\n        } catch (summaryErr) {\n            console.warn(\"Falha ao gerar summaryData a partir de processedData:\", summaryErr);\n        }\n        // ===== FIM: GERAÇÃO DE summaryData =====\n        // Create response data without transactions to match client schema\n        const { transactions, ...clientProcessedData } = processedData;\n        return res.status(200).json({\n            success: true,\n            message: `${csvFiles.length} arquivo(s) processado(s) com sucesso`,\n            data: allFilesResults,\n            summaryData: _lib_storage__WEBPACK_IMPORTED_MODULE_4__.storage.get(\"summaryData\") || null,\n            allFilesData\n        });\n    } catch (error) {\n        console.error(\"=== ERROR IN UPLOAD-CSV ===\");\n        console.error(\"Error type:\", typeof error);\n        console.error(\"Error message:\", error instanceof Error ? error.message : String(error));\n        console.error(\"Error stack:\", error instanceof Error ? error.stack : \"No stack trace\");\n        console.error(\"Full error object:\", error);\n        res.status(500).json({\n            success: false,\n            message: \"Erro interno do servidor: \" + (error instanceof Error ? error.message : String(error))\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxPQUFPLEdBQUcySixPQUFPcE0sTUFBSztRQUNoRztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3RhZmxleC1uZXh0anMvLi9wYWdlcy9hcGkvdXBsb2FkLWNzdi50cz82ZGQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gJ25leHQnXHJcbmltcG9ydCBmb3JtaWRhYmxlIGZyb20gJ2Zvcm1pZGFibGUnXHJcbmltcG9ydCBmcyBmcm9tICdmcydcclxuaW1wb3J0IFBhcGEgZnJvbSAncGFwYXBhcnNlJ1xyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xyXG5pbXBvcnQgeyBzdG9yYWdlIH0gZnJvbSAnLi4vLi4vbGliL3N0b3JhZ2UnXHJcbmltcG9ydCB7IFByb2Nlc3NlZERhdGEgYXMgQmFzZVByb2Nlc3NlZERhdGEgfSBmcm9tICdAc2hhcmVkL3NjaGVtYSdcclxuaW1wb3J0IHsgcmFuZG9tVVVJRCB9IGZyb20gJ2NyeXB0byc7XHJcblxyXG4vLyBFeHRlbmQgUHJvY2Vzc2VkRGF0YSB0byBpbmNsdWRlIHRyYW5zYWN0aW9ucyBmb3IgQVBJIHByb2Nlc3NpbmdcclxuaW50ZXJmYWNlIFByb2Nlc3NlZERhdGEgZXh0ZW5kcyBCYXNlUHJvY2Vzc2VkRGF0YSB7XHJcbiAgdHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvbkZvckV4Y2VsW107XHJcbn1cclxuXHJcbi8vIEludGVyZmFjZXMgcGFyYSB0aXBvcyBkZSBkYWRvcyBwcm9jZXNzYWRvc1xyXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25EYXRhIHtcclxuICBkYXRlOiBEYXRlO1xyXG4gIHN1cHBsaWVyOiBzdHJpbmc7XHJcbiAgZG9jTnVtYmVyOiBzdHJpbmc7XHJcbiAgdmFsdWU6IG51bWJlcjtcclxuICBjYXRlZ29yeTogc3RyaW5nO1xyXG4gIGJyYW5jaDogc3RyaW5nO1xyXG4gIGRvY3VtZW50VHlwZTogJ0FfUEFHQVInIHwgJ0FfUkVDRUJFUic7XHJcbiAgc291cmNlRmlsZTogc3RyaW5nOyAvLyBOb21lIG9yaWdpbmFsIGRvIGFycXVpdm8gcGFyYSBzZXBhcmFyIGNhdGVnb3JpYXMgbm8gRXhjZWxcclxufVxyXG5cclxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uRm9yRXhjZWwge1xyXG4gIHZlbmNpbWVudG86IHN0cmluZztcclxuICB0cmFuc2FjaW9uYWRvcjogc3RyaW5nO1xyXG4gIGRvY3VtZW50bzogc3RyaW5nO1xyXG4gIHZhbG9yOiBzdHJpbmc7XHJcbiAgdmFsb3JOdW1lcmljbzogbnVtYmVyO1xyXG4gIGRvY3VtZW50VHlwZT86ICdBX1BBR0FSJyB8ICdBX1JFQ0VCRVInO1xyXG4gIGZpbGlhbD86IHN0cmluZztcclxuICBzb3VyY2VGaWxlPzogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgRG9jdW1lbnRvUHJvY2Vzc2FkbyB7XHJcbiAgZGF0YVZlbmNpbWVudG86IERhdGU7XHJcbiAgdHJhbnNhY2lvbmFkb3I6IHN0cmluZztcclxuICBudW1lcm9Eb2N1bWVudG86IHN0cmluZztcclxuICB2YWxvcjogbnVtYmVyO1xyXG4gIHZhbG9yT3JpZ2luYWw6IHN0cmluZztcclxuICBjYXRlZ29yaWE6ICdBX1BBR0FSJyB8ICdBX1JFQ0VCRVInO1xyXG4gIGZpbGlhbDogc3RyaW5nO1xyXG59XHJcblxyXG4vLyBGdW7Dp8OjbyBwYXJhIHBhcnNpbmcgZGUgZGF0YXMgQ1NWIChFWEFUQSlcclxuZnVuY3Rpb24gcGFyc2VDU1ZEYXRlKGRhdGVTdHI6IHN0cmluZyk6IERhdGUge1xyXG4gIGNvbnN0IGZvcm1hdHMgPSBbXHJcbiAgICAvKFxcZHsxLDJ9KVxcLyhcXGR7MSwyfSlcXC8oXFxkezR9KS8sIC8vIEREL01NL1lZWVkgKGZvcm1hdG8gYnJhc2lsZWlybylcclxuICAgIC8oXFxkezR9KS0oXFxkezEsMn0pLShcXGR7MSwyfSkvLCAgLy8gWVlZWS1NTS1ERCAoZm9ybWF0byBJU08pXHJcbiAgXTtcclxuICBcclxuICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBmb3JtYXRzKSB7XHJcbiAgICBjb25zdCBtYXRjaCA9IGRhdGVTdHIubWF0Y2goZm9ybWF0KTtcclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICBpZiAoZm9ybWF0ID09PSBmb3JtYXRzWzBdKSB7XHJcbiAgICAgICAgLy8gREQvTU0vWVlZWSAtIGZvcm1hdG8gYnJhc2lsZWlyb1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShwYXJzZUludChtYXRjaFszXSksIHBhcnNlSW50KG1hdGNoWzJdKSAtIDEsIHBhcnNlSW50KG1hdGNoWzFdKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gWVlZWS1NTS1ERCAtIGZvcm1hdG8gSVNPXHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlSW50KG1hdGNoWzFdKSwgcGFyc2VJbnQobWF0Y2hbMl0pIC0gMSwgcGFyc2VJbnQobWF0Y2hbM10pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gbmV3IERhdGUoZGF0ZVN0cik7IC8vIEZhbGxiYWNrXHJcbn1cclxuXHJcbi8vIEZ1bsOnw6NvIGF1eGlsaWFyIHBhcmEgc2VtYW5hIChFWEFUQSlcclxuZnVuY3Rpb24gZ2V0V2Vla0JvdW5kYXJpZXMoZGF0ZTogRGF0ZSk6IHsgd2Vla1N0YXJ0OiBEYXRlOyB3ZWVrRW5kOiBEYXRlIH0ge1xyXG4gIGNvbnN0IGRheU9mV2VlayA9IGRhdGUuZ2V0RGF5KCk7XHJcbiAgY29uc3Qgd2Vla1N0YXJ0ID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgd2Vla1N0YXJ0LnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBkYXlPZldlZWsgKyAoZGF5T2ZXZWVrID09PSAwID8gLTYgOiAxKSk7IC8vIE1vbmRheVxyXG4gIHdlZWtTdGFydC5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxuICBjb25zdCB3ZWVrRW5kID0gbmV3IERhdGUod2Vla1N0YXJ0KTtcclxuICB3ZWVrRW5kLnNldERhdGUod2Vla1N0YXJ0LmdldERhdGUoKSArIDYpOyAvLyBTdW5kYXlcclxuICB3ZWVrRW5kLnNldEhvdXJzKDIzLCA1OSwgNTksIDk5OSk7XHJcbiAgcmV0dXJuIHsgd2Vla1N0YXJ0LCB3ZWVrRW5kIH07XHJcbn1cclxuXHJcbi8vIEZ1bsOnw6NvIHBhcmEgcGFyc2luZyBkZSB2YWxvcmVzIG1vbmV0w6FyaW9zXHJcbmZ1bmN0aW9uIHBhcnNlTW9uZXRhcnlWYWx1ZShzdHI6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgbGV0IGNsZWFuVmFsdWUgPSBzdHIucmVwbGFjZSgvW1IkXFxzXS9nLCAnJykucmVwbGFjZSgvXFwuL2csICcnKS5yZXBsYWNlKCcsJywgJy4nKTtcclxuICBcclxuICBjb25zdCBpc05lZ2F0aXZlID0gY2xlYW5WYWx1ZS5zdGFydHNXaXRoKCctJyk7XHJcbiAgaWYgKGlzTmVnYXRpdmUpIHtcclxuICAgIGNsZWFuVmFsdWUgPSBjbGVhblZhbHVlLnN1YnN0cmluZygxKTtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgdmFsdWUgPSBwYXJzZUZsb2F0KGNsZWFuVmFsdWUpO1xyXG4gIHJldHVybiBpc05lZ2F0aXZlID8gLXZhbHVlIDogdmFsdWU7XHJcbn1cclxuXHJcbi8vIEZ1bsOnw6NvIHBhcmEgZGV0ZWN0YXIgZW5jb2RpbmdcclxuZnVuY3Rpb24gZGV0ZWN0RW5jb2RpbmcoYnVmZmVyOiBCdWZmZXIpOiBzdHJpbmcge1xyXG4gIGNvbnN0IGVuY29kaW5ncyA9IFsndXRmLTgnLCAnbGF0aW4xJywgJ2FzY2lpJywgJ3V0ZjE2bGUnXTtcclxuICBcclxuICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIGVuY29kaW5ncykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGVjb2RlZCA9IGJ1ZmZlci50b1N0cmluZyhlbmNvZGluZyBhcyBCdWZmZXJFbmNvZGluZyk7XHJcbiAgICAgIC8vIFZlcmlmaWNhciBzZSBjb250w6ltIGNhcmFjdGVyZXMgZXNwZWNpYWlzIGJyYXNpbGVpcm9zXHJcbiAgICAgIGlmIChkZWNvZGVkLmluY2x1ZGVzKCfDpycpIHx8IGRlY29kZWQuaW5jbHVkZXMoJ8OjJykgfHwgZGVjb2RlZC5pbmNsdWRlcygnw6knKSkge1xyXG4gICAgICAgIHJldHVybiBlbmNvZGluZztcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAndXRmLTgnOyAvLyBmYWxsYmFja1xyXG59XHJcblxyXG4vLyBJbnRlcmZhY2UgcGFyYSBkb2N1bWVudG8gZXh0cmHDrWRvIGNvbmZvcm1lIGVzcGVjaWZpY2HDp8Ojb1xyXG5pbnRlcmZhY2UgRG9jdW1lbnRvRXh0cmFpZG8ge1xyXG4gIGRhdGFWZW5jaW1lbnRvOiBEYXRlOyAgICAgICAgICAgLy8gRGF0YSBwYXJzZWFkYSBkYSBjb2x1bmEgMVxyXG4gIHRyYW5zYWNpb25hZG9yOiBzdHJpbmc7ICAgICAgICAgLy8gVFJBTlNBQ0lPTkFET1IgZGEgY29sdW5hIDIgKERBRE8gUFJJTkNJUEFMKVxyXG4gIG51bWVyb0RvY3VtZW50bzogc3RyaW5nOyAgICAgICAgLy8gTsOaTUVSTyBETyBET0NVTUVOVE8gZGEgY29sdW5hIDMgKERBRE8gUFJJTkNJUEFMKVxyXG4gIHZhbG9yOiBudW1iZXI7ICAgICAgICAgICAgICAgICAgLy8gVmFsb3IgbnVtw6lyaWNvIGRhIGNvbHVuYSA1XHJcbiAgdmFsb3JPcmlnaW5hbDogc3RyaW5nOyAgICAgICAgICAvLyBWYWxvciBvcmlnaW5hbCBjb21vIHN0cmluZ1xyXG4gIGNhdGVnb3JpYTogJ0FfUEFHQVInIHwgJ0FfUkVDRUJFUic7XHJcbiAgZmlsaWFsOiBzdHJpbmc7ICAgICAgICAgICAgICAgICAvLyBOb21lIGRhIGZpbGlhbFxyXG4gIHdlZWtTdGFydDogRGF0ZTsgICAgICAgICAgICAgICAgLy8gSW7DrWNpbyBkYSBzZW1hbmFcclxuICB3ZWVrRW5kOiBEYXRlOyAgICAgICAgICAgICAgICAgIC8vIEZpbSBkYSBzZW1hbmFcclxuICBzb3VyY2VGaWxlOiBzdHJpbmc7ICAgICAgICAgICAgIC8vIE5vbWUgZG8gYXJxdWl2byBmb250ZVxyXG59XHJcblxyXG4vLyBGdW7Dp8OjbyBwYXJhIGV4dHJhaXIgdHJhbnNhY2lvbmFkb3IgZSBkb2N1bWVudG8gc2VndWluZG8gZXNwZWNpZmljYcOnw6NvIEVYQVRBXHJcbmZ1bmN0aW9uIGV4dHJhaXJUcmFuc2FjaW9uYWRvckVEb2N1bWVudG8oY3N2Q29udGVudDogc3RyaW5nLCBkb2N1bWVudFR5cGU6ICdBX1BBR0FSJyB8ICdBX1JFQ0VCRVInLCBub21lRmlsaWFsOiBzdHJpbmcpOiBEb2N1bWVudG9FeHRyYWlkb1tdIHtcclxuICAvLyBQYXJzZSBDU1Ygc2VtIGhlYWRlcnNcclxuICBjb25zdCBwYXJzZVJlc3VsdCA9IFBhcGEucGFyc2UoY3N2Q29udGVudCwge1xyXG4gICAgaGVhZGVyOiBmYWxzZSxcclxuICAgIHNraXBFbXB0eUxpbmVzOiB0cnVlLFxyXG4gIH0pO1xyXG4gIFxyXG4gIGNvbnN0IHJvd3MgPSBwYXJzZVJlc3VsdC5kYXRhIGFzIGFueVtdO1xyXG4gIGNvbnN0IGRvY3VtZW50b3NFeHRyYWlkb3M6IERvY3VtZW50b0V4dHJhaWRvW10gPSBbXTtcclxuICBcclxuICAvLyBQcm9jZXNzYXIgY2FkYSBsaW5oYSBkbyBDU1ZcclxuICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XHJcbiAgICAvLyBWQUxJREHDh8ODTyBFU1RSVVRVUkFMIE9CUklHQVTDk1JJQVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJvdykgfHwgcm93Lmxlbmd0aCA8IDUpIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICBjb25zdCBjYXRlZ29yeSA9IHJvd1swXT8udG9TdHJpbmcoKS50cmltKCkgfHwgJyc7XHJcbiAgICBsZXQgZGF0ZVN0ciA9ICcnO1xyXG4gICAgbGV0IHRyYW5zYWNpb25hZG9yID0gJyc7XHJcbiAgICBsZXQgbnVtZXJvRG9jdW1lbnRvID0gJyc7XHJcbiAgICBsZXQgdmFsdWVTdHIgPSAnJztcclxuICAgIFxyXG4gICAgLy8gTMOTR0lDQSBERSBJREVOVElGSUNBw4fDg08gUE9SIFRJUE8gREUgRE9DVU1FTlRPXHJcbiAgICBpZiAoZG9jdW1lbnRUeXBlID09PSAnQV9QQUdBUicpIHtcclxuICAgICAgLy8gTWF0Y2ggRVhBVE8gLSBuw6NvIHVzYXIgaW5jbHVkZXMoKVxyXG4gICAgICBpZiAoY2F0ZWdvcnkgIT09ICdDb250YXMgYSBwYWdhci0gw4AgdmVuY2VyJykgY29udGludWU7XHJcbiAgICAgIFxyXG4gICAgICAvLyBNQVBFQU1FTlRPIEZJWE8gREFTIENPTFVOQVM6XHJcbiAgICAgIGRhdGVTdHIgPSByb3dbMV0/LnRvU3RyaW5nKCkudHJpbSgpIHx8ICcnOyAgICAgICAgICAgLy8gQ09MVU5BIDE6IERhdGEgVmVuY2ltZW50b1xyXG4gICAgICB0cmFuc2FjaW9uYWRvciA9IHJvd1syXT8udG9TdHJpbmcoKS50cmltKCkgfHwgJyc7ICAgIC8vIENPTFVOQSAyOiBUUkFOU0FDSU9OQURPUlxyXG4gICAgICBudW1lcm9Eb2N1bWVudG8gPSByb3dbM10/LnRvU3RyaW5nKCkudHJpbSgpIHx8ICcnOyAgIC8vIENPTFVOQSAzOiBOw5pNRVJPIERPIERPQ1VNRU5UT1xyXG4gICAgICB2YWx1ZVN0ciA9IHJvd1s1XT8udG9TdHJpbmcoKS50cmltKCkgfHwgJzAnOyAgICAgICAgIC8vIENPTFVOQSA1OiBWYWxvciAoU0VNUFJFIGNvbHVuYSA1KVxyXG4gICAgICBcclxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRUeXBlID09PSAnQV9SRUNFQkVSJykge1xyXG4gICAgICAvLyBNYXRjaCBFWEFUTyAtIG7Do28gdXNhciBpbmNsdWRlcygpXHJcbiAgICAgIGlmIChjYXRlZ29yeSAhPT0gJ0NvbnRhcyBhIHJlY2ViZXIgLSBBIHZlbmNlcicpIGNvbnRpbnVlO1xyXG4gICAgICBcclxuICAgICAgLy8gTUFQRUFNRU5UTyBGSVhPIERBUyBDT0xVTkFTOlxyXG4gICAgICBkYXRlU3RyID0gcm93WzFdPy50b1N0cmluZygpLnRyaW0oKSB8fCAnJzsgICAgICAgICAgIC8vIENPTFVOQSAxOiBEYXRhIFZlbmNpbWVudG9cclxuICAgICAgdHJhbnNhY2lvbmFkb3IgPSByb3dbMl0/LnRvU3RyaW5nKCkudHJpbSgpIHx8ICcnOyAgICAvLyBDT0xVTkEgMjogVFJBTlNBQ0lPTkFET1JcclxuICAgICAgbnVtZXJvRG9jdW1lbnRvID0gcm93WzNdPy50b1N0cmluZygpLnRyaW0oKSB8fCAnJzsgICAvLyBDT0xVTkEgMzogTsOaTUVSTyBETyBET0NVTUVOVE9cclxuICAgICAgdmFsdWVTdHIgPSByb3dbNV0/LnRvU3RyaW5nKCkudHJpbSgpIHx8ICcwJzsgICAgICAgICAvLyBDT0xVTkEgNTogVmFsb3IgKFNFTVBSRSBjb2x1bmEgNSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVkFMSURBw4fDlUVTIE9CUklHQVTDk1JJQVMgRE9TIERBRE9TIEVYVFJBw41ET1NcclxuICAgIGlmICghZGF0ZVN0ciB8fCAhdHJhbnNhY2lvbmFkb3IgfHwgIXZhbHVlU3RyKSBjb250aW51ZTtcclxuICAgIFxyXG4gICAgLy8gUEFSU0lORyBEQSBEQVRBIERFIFZFTkNJTUVOVE9cclxuICAgIGNvbnN0IGRhdGUgPSBwYXJzZUNTVkRhdGUoZGF0ZVN0cik7XHJcbiAgICBpZiAoIWRhdGUgfHwgaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSBjb250aW51ZTtcclxuICAgIFxyXG4gICAgLy8gUEFSU0lORyBETyBWQUxPUiBNT05FVMOBUklPIChmb3JtYXRvIGJyYXNpbGVpcm8pXHJcbiAgICBsZXQgY2xlYW5WYWx1ZSA9IHZhbHVlU3RyLnJlcGxhY2UoL1tSJFxcc10vZywgJycpLnJlcGxhY2UoL1xcLi9nLCAnJykucmVwbGFjZSgnLCcsICcuJyk7XHJcbiAgICBjb25zdCBpc05lZ2F0aXZlID0gY2xlYW5WYWx1ZS5zdGFydHNXaXRoKCctJyk7XHJcbiAgICBpZiAoaXNOZWdhdGl2ZSkge1xyXG4gICAgICBjbGVhblZhbHVlID0gY2xlYW5WYWx1ZS5zdWJzdHJpbmcoMSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQoY2xlYW5WYWx1ZSk7XHJcbiAgICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlIDw9IDApIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICAvLyBBUExJQ0HDh8ODTyBERSBGQUxMQkFDS1MgUEFSQSBDQU1QT1MgT0JSSUdBVMOTUklPU1xyXG4gICAgY29uc3QgdHJhbnNhY2lvbmFkb3JGaW5hbCA9IHRyYW5zYWNpb25hZG9yIHx8ICdGT1JORUNFRE9SIE7Dg08gSURFTlRJRklDQURPJztcclxuICAgIGNvbnN0IG51bWVyb0RvY3VtZW50b0ZpbmFsID0gbnVtZXJvRG9jdW1lbnRvIHx8ICcnOyAvLyBSZW1vdmlkbyBmYWxsYmFjayAnUEVOREVOVEUnXHJcbiAgICBcclxuICAgIC8vIEVTVFJVVFVSQSBGSU5BTCBET1MgREFET1MgRVhUUkHDjURPU1xyXG4gICAgY29uc3QgeyB3ZWVrU3RhcnQsIHdlZWtFbmQgfSA9IGdldFdlZWtCb3VuZGFyaWVzKGRhdGUpO1xyXG4gICAgZG9jdW1lbnRvc0V4dHJhaWRvcy5wdXNoKHtcclxuICAgICAgZGF0YVZlbmNpbWVudG86IGRhdGUsXHJcbiAgICAgIHRyYW5zYWNpb25hZG9yOiB0cmFuc2FjaW9uYWRvckZpbmFsLCAgICAgIC8vIERBRE8gUFJJTkNJUEFMIEVYVFJBw41ET1xyXG4gICAgICBudW1lcm9Eb2N1bWVudG86IG51bWVyb0RvY3VtZW50b0ZpbmFsLCAgICAvLyBEQURPIFBSSU5DSVBBTCBFWFRSQcONRE9cclxuICAgICAgdmFsb3I6IHZhbHVlLFxyXG4gICAgICB2YWxvck9yaWdpbmFsOiB2YWx1ZVN0cixcclxuICAgICAgY2F0ZWdvcmlhOiBkb2N1bWVudFR5cGUsXHJcbiAgICAgIGZpbGlhbDogbm9tZUZpbGlhbCxcclxuICAgICAgLy8gRGFkb3MgZGUgY29tcGF0aWJpbGlkYWRlXHJcbiAgICAgIHdlZWtTdGFydDogd2Vla1N0YXJ0LFxyXG4gICAgICB3ZWVrRW5kOiB3ZWVrRW5kLFxyXG4gICAgICBzb3VyY2VGaWxlOiBgJHtub21lRmlsaWFsfS5jc3ZgXHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGRvY3VtZW50b3NFeHRyYWlkb3M7XHJcbn1cclxuXHJcbi8vIENvbmZpZ3VyYcOnw6NvIHBhcmEgZGVzYWJpbGl0YXIgbyBwYXJzZXIgcGFkcsOjbyBkbyBOZXh0LmpzXHJcbmV4cG9ydCBjb25zdCBjb25maWcgPSB7XHJcbiAgYXBpOiB7XHJcbiAgICBib2R5UGFyc2VyOiBmYWxzZSxcclxuICB9LFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxyXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXHJcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2VcclxuKSB7XHJcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgbWVzc2FnZTogJ01ldGhvZCBub3QgYWxsb3dlZCcgfSlcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBPcGNpb25hbDogbGltcGFyIGRhZG9zIGFudGVyaW9yZXMgc2Ugc29saWNpdGFkb1xyXG4gICAgaWYgKHJlcS5xdWVyeS5jbGVhckRhdGEgPT09ICd0cnVlJykge1xyXG4gICAgICBzdG9yYWdlLmRlbGV0ZSgnc3VtbWFyeURhdGEnKTtcclxuICAgICAgc3RvcmFnZS5kZWxldGUoJ3Byb2Nlc3NlZERhdGEnKTtcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKCc9PT0gREVCVUcgVVBMT0FEIENTViA9PT0nKTtcclxuICAgIGNvbnNvbGUubG9nKCdNZXRob2Q6JywgcmVxLm1ldGhvZCk7XHJcbiAgICBjb25zb2xlLmxvZygnQ29udGVudC1UeXBlOicsIHJlcS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSk7XHJcbiAgICBjb25zb2xlLmxvZygnSGVhZGVyczonLCBKU09OLnN0cmluZ2lmeShyZXEuaGVhZGVycywgbnVsbCwgMikpO1xyXG4gICAgXHJcbiAgICAvLyBHYXJhbnRpciBxdWUgYSBwYXN0YSB0ZW1wIGV4aXN0ZVxyXG4gICAgY29uc3QgdGVtcERpciA9ICcuL3RlbXAnO1xyXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHRlbXBEaXIpKSB7XHJcbiAgICAgIGZzLm1rZGlyU3luYyh0ZW1wRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ29uZmlndXJhciBmb3JtaWRhYmxlIHBhcmEgdXBsb2FkIGRlIG3Dumx0aXBsb3MgYXJxdWl2b3NcclxuICAgIGNvbnN0IGZvcm0gPSBmb3JtaWRhYmxlKHtcclxuICAgICAgdXBsb2FkRGlyOiB0ZW1wRGlyLFxyXG4gICAgICBrZWVwRXh0ZW5zaW9uczogdHJ1ZSxcclxuICAgICAgbWF4RmlsZXM6IDEwLFxyXG4gICAgICBtYXhGaWxlU2l6ZTogMTAgKiAxMDI0ICogMTAyNCwgLy8gMTBNQlxyXG4gICAgICAvLyBSZW1vdmVyIGZpbHRlciBwYXJhIGFjZWl0YXIgdG9kb3Mgb3MgYXJxdWl2b3MgcG9yIGVucXVhbnRvXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBbZmllbGRzLCBmaWxlc10gPSBhd2FpdCBmb3JtLnBhcnNlKHJlcSk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCc9PT0gUEFSU0VEIERBVEEgPT09Jyk7XHJcbiAgICBjb25zb2xlLmxvZygnRmllbGRzOicsIEpTT04uc3RyaW5naWZ5KGZpZWxkcywgbnVsbCwgMikpO1xyXG4gICAgY29uc29sZS5sb2coJ0ZpbGVzIGtleXM6JywgT2JqZWN0LmtleXMoZmlsZXMpKTtcclxuICAgIGNvbnNvbGUubG9nKCdGaWxlcyBzdHJ1Y3R1cmU6JywgSlNPTi5zdHJpbmdpZnkoZmlsZXMsIG51bGwsIDIpKTtcclxuICAgIFxyXG4gICAgLy8gT2J0ZXIgdGlwb3MgZGUgZG9jdW1lbnRvIHNlbGVjaW9uYWRvc1xyXG4gICAgbGV0IHNlbGVjdGVkVHlwZXM6ICgnQV9QQUdBUicgfCAnQV9SRUNFQkVSJylbXSA9IFsnQV9QQUdBUicsICdBX1JFQ0VCRVInXTsgLy8gRGVmYXVsdFxyXG4gICAgXHJcbiAgICBpZiAoZmllbGRzLmRvY3VtZW50VHlwZXMgJiYgZmllbGRzLmRvY3VtZW50VHlwZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBkb2N1bWVudFR5cGVzU3RyaW5nID0gZmllbGRzLmRvY3VtZW50VHlwZXNbMF0gYXMgc3RyaW5nO1xyXG4gICAgICBjb25zb2xlLmxvZygnZG9jdW1lbnRUeXBlc1N0cmluZyByZWNlYmlkbzonLCBkb2N1bWVudFR5cGVzU3RyaW5nKTtcclxuICAgICAgXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gVGVudGFyIGZhemVyIHBhcnNlIHNlIGZvciBKU09OXHJcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkb2N1bWVudFR5cGVzU3RyaW5nKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnSlNPTiBwYXJzZWQ6JywgcGFyc2VkKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWQpKSB7XHJcbiAgICAgICAgICBzZWxlY3RlZFR5cGVzID0gcGFyc2VkO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcnNlZCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIC8vIFNlIGZvciB1bSBvYmpldG8gY29tIGluZGljZXMsIGV4dHJhaXIgb3MgdmFsb3JlcyBlIGZsYXR0ZW5cclxuICAgICAgICAgIGNvbnN0IGFsbFR5cGVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgICAgT2JqZWN0LnZhbHVlcyhwYXJzZWQpLmZvckVhY2godHlwZUFycmF5ID0+IHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZUFycmF5KSkge1xyXG4gICAgICAgICAgICAgIGFsbFR5cGVzLnB1c2goLi4udHlwZUFycmF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICAvLyBSZW1vdmVyIGR1cGxpY2F0YXNcclxuICAgICAgICAgIGNvbnN0IHVuaXF1ZVR5cGVzID0gQXJyYXkuZnJvbShuZXcgU2V0KGFsbFR5cGVzKSk7XHJcbiAgICAgICAgICBzZWxlY3RlZFR5cGVzID0gdW5pcXVlVHlwZXMgYXMgKCdBX1BBR0FSJyB8ICdBX1JFQ0VCRVInKVtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdFcnJvIG5vIHBhcnNlIEpTT046JywgZSk7XHJcbiAgICAgICAgLy8gU2UgbsOjbyBmb3IgSlNPTiwgdXNhciBjb21vIGFycmF5IGRpcmV0b1xyXG4gICAgICAgIHNlbGVjdGVkVHlwZXMgPSBBcnJheS5pc0FycmF5KGZpZWxkcy5kb2N1bWVudFR5cGVzKSBcclxuICAgICAgICAgID8gZmllbGRzLmRvY3VtZW50VHlwZXMgYXMgKCdBX1BBR0FSJyB8ICdBX1JFQ0VCRVInKVtdXHJcbiAgICAgICAgICA6IFtkb2N1bWVudFR5cGVzU3RyaW5nIGFzICdBX1BBR0FSJyB8ICdBX1JFQ0VCRVInXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnU2VsZWN0ZWQgdHlwZXMgcHJvY2Vzc2Fkb3M6Jywgc2VsZWN0ZWRUeXBlcyk7XHJcbiAgICBcclxuICAgIC8vIE5PUk1BTElaQcOHw4NPIFJPQlVTVEEgREUgQVJRVUlWT1MgKG11bHRpLWZpZWxkLCBtdWx0aS1maWxlKVxyXG4gICAgY29uc3QgYWxsRmlsZXMgPSBPYmplY3QudmFsdWVzKGZpbGVzKS5mbGF0KCkuZmlsdGVyKEJvb2xlYW4pIGFzIGZvcm1pZGFibGUuRmlsZVtdO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnPT09IEZJTEUgUFJPQ0VTU0lORyA9PT0nKTtcclxuICAgIGNvbnNvbGUubG9nKCdhbGxGaWxlcyAobm9ybWFsaXphZG8pOicsIGFsbEZpbGVzLm1hcChmID0+ICh7IG9yaWdpbmFsRmlsZW5hbWU6IGYub3JpZ2luYWxGaWxlbmFtZSwgcGF0aDogZi5maWxlcGF0aCB9KSkpO1xyXG4gICAgY29uc29sZS5sb2coJ2FsbEZpbGVzIGxlbmd0aDonLCBhbGxGaWxlcy5sZW5ndGgpO1xyXG4gICAgXHJcbiAgICAvLyBGaWx0cmFyIGFwZW5hcyBhcnF1aXZvcyBDU1YgLSBzZW5kbyBtYWlzIHBlcm1pc3Npdm8gcGFyYSBkZWJ1Z1xyXG4gICAgY29uc3QgY3N2RmlsZXMgPSBhbGxGaWxlcy5maWx0ZXIoZmlsZSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBmaWxlOicsIGZpbGUgPyB7XHJcbiAgICAgICAgb3JpZ2luYWxGaWxlbmFtZTogZmlsZS5vcmlnaW5hbEZpbGVuYW1lLFxyXG4gICAgICAgIG1pbWV0eXBlOiBmaWxlLm1pbWV0eXBlLFxyXG4gICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcclxuICAgICAgICBmaWxlcGF0aDogZmlsZS5maWxlcGF0aFxyXG4gICAgICB9IDogJ251bGwgZmlsZScpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFmaWxlIHx8ICFmaWxlLm9yaWdpbmFsRmlsZW5hbWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgLy8gQWNlaXRhciAuY3N2IG91IC50eHQgKGFsZ3VucyBzaXN0ZW1hcyBleHBvcnRhbSBhc3NpbSksIGNhc2UgaW5zZW5zaXRpdmVcclxuICAgICAgcmV0dXJuIC9cXC4oY3N2fHR4dCkkL2kudGVzdChmaWxlLm9yaWdpbmFsRmlsZW5hbWUpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCc9PT0gRklMVEVSSU5HIFJFU1VMVFMgPT09Jyk7XHJcbiAgICBjb25zb2xlLmxvZygnQ1NWIEZpbGVzIGZvdW5kOicsIGNzdkZpbGVzLmxlbmd0aCk7XHJcbiAgICBjb25zb2xlLmxvZygnU2VsZWN0ZWQgdHlwZXM6Jywgc2VsZWN0ZWRUeXBlcyk7XHJcbiAgICBjb25zb2xlLmxvZygnQ1NWIEZpbGVzIGRldGFpbHM6JywgY3N2RmlsZXMubWFwKGYgPT4gZiA/IHtcclxuICAgICAgbmFtZTogZi5vcmlnaW5hbEZpbGVuYW1lLFxyXG4gICAgICB0eXBlOiBmLm1pbWV0eXBlLFxyXG4gICAgICBzaXplOiBmLnNpemVcclxuICAgIH0gOiBudWxsKSk7XHJcbiAgICBcclxuICAgIGlmIChjc3ZGaWxlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coJz09PSBFUlJPUjogTk8gRklMRVMgPT09Jyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdObyBDU1YgZmlsZXMgZm91bmQgYWZ0ZXIgZmlsdGVyaW5nJyk7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgbWVzc2FnZTogYE5lbmh1bSBhcnF1aXZvIGZvaSBlbmNvbnRyYWRvLiBBcnF1aXZvcyByZWNlYmlkb3M6ICR7YWxsRmlsZXMubGVuZ3RofS4gVmVyaWZpcXVlIHNlIG8gYXJxdWl2byDDqSB1bSBDU1YgdsOhbGlkby5gXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFsbFRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25EYXRhW10gPSBbXTtcclxuICAgIGNvbnN0IGFsbEZpbGVzRGF0YTogYW55W10gPSBbXTtcclxuICAgIGNvbnN0IGFsbEZpbGVzUmVzdWx0czogYW55W10gPSBbXTtcclxuICAgIC8vIFByb2Nlc3NhciBjYWRhIGFycXVpdm8gQ1NWXHJcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgY3N2RmlsZXMpIHtcclxuICAgICAgY29uc29sZS5sb2coYD09PSBQUk9DRVNTSU5HIEZJTEU6ICR7ZmlsZT8ub3JpZ2luYWxGaWxlbmFtZX0gPT09YCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWZpbGUgfHwgIWZpbGUuZmlsZXBhdGgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnU2tpcHBpbmcgaW52YWxpZCBmaWxlOicsIGZpbGUpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnRmlsZSBwYXRoOicsIGZpbGUuZmlsZXBhdGgpO1xyXG4gICAgICBjb25zb2xlLmxvZygnRmlsZSBleGlzdHM6JywgZnMuZXhpc3RzU3luYyhmaWxlLmZpbGVwYXRoKSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBidWZmZXIgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZS5maWxlcGF0aCk7XHJcbiAgICAgIGNvbnN0IGVuY29kaW5nID0gZGV0ZWN0RW5jb2RpbmcoYnVmZmVyKTtcclxuICAgICAgY29uc3QgY3N2Q29udGVudCA9IGJ1ZmZlci50b1N0cmluZyhlbmNvZGluZyBhcyBCdWZmZXJFbmNvZGluZyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWlyIG5vbWUgZGEgZmlsaWFsXHJcbiAgICAgIGNvbnN0IGJyYW5jaE5hbWUgPSAoZmlsZS5vcmlnaW5hbEZpbGVuYW1lIHx8ICdGSUxJQUxfREVTQ09OSEVDSURBJylcclxuICAgICAgICAucmVwbGFjZSgvXFwuKGNzdnx0eHQpJC9pLCAnJylcclxuICAgICAgICAudG9VcHBlckNhc2UoKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGZpbGVUcmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uRGF0YVtdID0gW107XHJcbiAgICAgIFxyXG4gICAgICAvLyBQcm9jZXNzYXIgY2FkYSB0aXBvIGRlIGRvY3VtZW50byBzZWxlY2lvbmFkbyB1c2FuZG8gYSBub3ZhIGzDs2dpY2FcclxuICAgICAgZm9yIChjb25zdCBkb2N1bWVudFR5cGUgb2Ygc2VsZWN0ZWRUeXBlcyBhcyAoJ0FfUEFHQVInIHwgJ0FfUkVDRUJFUicpW10pIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2FuZG8gdGlwbyBkZSBkb2N1bWVudG86ICR7ZG9jdW1lbnRUeXBlfSBwYXJhIGFycXVpdm86ICR7ZmlsZS5vcmlnaW5hbEZpbGVuYW1lfWApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVzYXIgYSBmdW7Dp8OjbyBkZSBleHRyYcOnw6NvIGVzcGVjw61maWNhIGNvbSBhIGzDs2dpY2EgY29ycmV0YVxyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50b3NFeHRyYWlkb3MgPSBleHRyYWlyVHJhbnNhY2lvbmFkb3JFRG9jdW1lbnRvKGNzdkNvbnRlbnQsIGRvY3VtZW50VHlwZSwgYnJhbmNoTmFtZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coYERvY3VtZW50b3MgZXh0cmHDrWRvcyBwYXJhICR7ZG9jdW1lbnRUeXBlfTpgLCBkb2N1bWVudG9zRXh0cmFpZG9zLmxlbmd0aCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTG9nIGRvcyBwcmltZWlyb3MgZG9jdW1lbnRvcyBwYXJhIGRlYnVnXHJcbiAgICAgICAgaWYgKGRvY3VtZW50b3NFeHRyYWlkb3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1ByaW1laXJvcyBkb2N1bWVudG9zIGV4dHJhw61kb3M6JywgZG9jdW1lbnRvc0V4dHJhaWRvcy5zbGljZSgwLCAzKS5tYXAoZG9jID0+ICh7XHJcbiAgICAgICAgICAgIHRyYW5zYWNpb25hZG9yOiBkb2MudHJhbnNhY2lvbmFkb3IsXHJcbiAgICAgICAgICAgIG51bWVyb0RvY3VtZW50bzogZG9jLm51bWVyb0RvY3VtZW50byxcclxuICAgICAgICAgICAgdmFsb3I6IGRvYy52YWxvcixcclxuICAgICAgICAgICAgZGF0YVZlbmNpbWVudG86IGRvYy5kYXRhVmVuY2ltZW50by50b0xvY2FsZURhdGVTdHJpbmcoJ3B0LUJSJylcclxuICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENvbnZlcnRlciBwYXJhIG8gZm9ybWF0byBUcmFuc2FjdGlvbkRhdGEgKG1hbnRlciBjb21wYXRpYmlsaWRhZGUpXHJcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jdW1lbnRvc0V4dHJhaWRvcykge1xyXG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uRGF0YSA9IHtcclxuICAgICAgICAgICAgZGF0ZTogZG9jLmRhdGFWZW5jaW1lbnRvLFxyXG4gICAgICAgICAgICBzdXBwbGllcjogZG9jLnRyYW5zYWNpb25hZG9yLCAgICAgICAgLy8gVFJBTlNBQ0lPTkFET1IgQ09SUkVUTyBkYSBjb2x1bmEgMlxyXG4gICAgICAgICAgICBkb2NOdW1iZXI6IGRvYy5udW1lcm9Eb2N1bWVudG8sICAgICAgLy8gTsOaTUVSTyBETyBET0NVTUVOVE8gQ09SUkVUTyBkYSBjb2x1bmEgM1xyXG4gICAgICAgICAgICB2YWx1ZTogZG9jLnZhbG9yLFxyXG4gICAgICAgICAgICBjYXRlZ29yeTogZG9jdW1lbnRUeXBlID09PSAnQV9QQUdBUicgPyAnQ29udGFzIGEgcGFnYXItIMOAIHZlbmNlcicgOiAnQ29udGFzIGEgcmVjZWJlciAtIEEgdmVuY2VyJyxcclxuICAgICAgICAgICAgYnJhbmNoOiBkb2MuZmlsaWFsLFxyXG4gICAgICAgICAgICBkb2N1bWVudFR5cGU6IGRvYy5jYXRlZ29yaWEsXHJcbiAgICAgICAgICAgIHNvdXJjZUZpbGU6IGZpbGUub3JpZ2luYWxGaWxlbmFtZSB8fCBgJHticmFuY2hOYW1lfS5jc3ZgXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBmaWxlVHJhbnNhY3Rpb25zLnB1c2godHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgYWxsVHJhbnNhY3Rpb25zLnB1c2godHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgYWxsRmlsZXNEYXRhLnB1c2goe1xyXG4gICAgICAgIGZpbGVuYW1lOiBmaWxlLm9yaWdpbmFsRmlsZW5hbWUsXHJcbiAgICAgICAgYnJhbmNoOiBicmFuY2hOYW1lLFxyXG4gICAgICAgIHRyYW5zYWN0aW9uczogZmlsZVRyYW5zYWN0aW9ucyxcclxuICAgICAgICB0b3RhbFRyYW5zYWN0aW9uczogZmlsZVRyYW5zYWN0aW9ucy5sZW5ndGhcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBBZ3JlZ2HDp8OjbyBpbmRpdmlkdWFsIHBvciBhcnF1aXZvXHJcbiAgICAgIGNvbnN0IGJyYW5jaFRvdGFsc01hcCA9IG5ldyBNYXA8c3RyaW5nLCB7XHJcbiAgICAgICAgaW52b2ljZUNvdW50OiBudW1iZXI7XHJcbiAgICAgICAgdG90YWxWYWx1ZTogbnVtYmVyO1xyXG4gICAgICAgIHdlZWtTdGFydDogRGF0ZTtcclxuICAgICAgICB3ZWVrRW5kOiBEYXRlO1xyXG4gICAgICB9PigpO1xyXG4gICAgICBjb25zdCBkYWlseVRvdGFsc01hcCA9IG5ldyBNYXA8c3RyaW5nLCB7XHJcbiAgICAgICAgZGF0ZTogRGF0ZTtcclxuICAgICAgICBkYXlPZldlZWs6IHN0cmluZztcclxuICAgICAgICB0b3RhbFZhbHVlOiBudW1iZXI7XHJcbiAgICAgICAgaW52b2ljZUNvdW50OiBudW1iZXI7XHJcbiAgICAgICAgYnJhbmNoOiBzdHJpbmc7XHJcbiAgICAgIH0+KCk7XHJcbiAgICAgIGxldCB0b3RhbFBheWFibGUgPSAwO1xyXG4gICAgICBsZXQgdG90YWxSZWNlaXZhYmxlID0gMDtcclxuICAgICAgbGV0IGdyYW5kVG90YWxWYWx1ZSA9IDA7XHJcbiAgICAgIGZpbGVUcmFuc2FjdGlvbnMuZm9yRWFjaCh0cmFuc2FjdGlvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBicmFuY2gsIGRhdGUsIHZhbHVlLCBkb2N1bWVudFR5cGUgfSA9IHRyYW5zYWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IHsgd2Vla1N0YXJ0LCB3ZWVrRW5kIH0gPSBnZXRXZWVrQm91bmRhcmllcyhkYXRlKTtcclxuICAgICAgICBjb25zdCBicmFuY2hLZXkgPSBicmFuY2g7XHJcbiAgICAgICAgaWYgKCFicmFuY2hUb3RhbHNNYXAuaGFzKGJyYW5jaEtleSkpIHtcclxuICAgICAgICAgIGJyYW5jaFRvdGFsc01hcC5zZXQoYnJhbmNoS2V5LCB7XHJcbiAgICAgICAgICAgIGludm9pY2VDb3VudDogMCxcclxuICAgICAgICAgICAgdG90YWxWYWx1ZTogMCxcclxuICAgICAgICAgICAgd2Vla1N0YXJ0LFxyXG4gICAgICAgICAgICB3ZWVrRW5kXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYnJhbmNoVG90YWwgPSBicmFuY2hUb3RhbHNNYXAuZ2V0KGJyYW5jaEtleSkhO1xyXG4gICAgICAgIGJyYW5jaFRvdGFsLmludm9pY2VDb3VudCsrO1xyXG4gICAgICAgIGJyYW5jaFRvdGFsLnRvdGFsVmFsdWUgKz0gdmFsdWU7XHJcbiAgICAgICAgY29uc3QgZGF0ZUtleSA9IGAke2JyYW5jaH0tJHtkYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXX1gO1xyXG4gICAgICAgIGNvbnN0IGRheU9mV2VlayA9IFsnRG9taW5nbycsICdTZWd1bmRhJywgJ1RlcsOnYScsICdRdWFydGEnLCAnUXVpbnRhJywgJ1NleHRhJywgJ1PDoWJhZG8nXVtkYXRlLmdldERheSgpXTtcclxuICAgICAgICBpZiAoIWRhaWx5VG90YWxzTWFwLmhhcyhkYXRlS2V5KSkge1xyXG4gICAgICAgICAgZGFpbHlUb3RhbHNNYXAuc2V0KGRhdGVLZXksIHtcclxuICAgICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgICAgZGF5T2ZXZWVrLFxyXG4gICAgICAgICAgICB0b3RhbFZhbHVlOiAwLFxyXG4gICAgICAgICAgICBpbnZvaWNlQ291bnQ6IDAsXHJcbiAgICAgICAgICAgIGJyYW5jaFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhaWx5VG90YWwgPSBkYWlseVRvdGFsc01hcC5nZXQoZGF0ZUtleSkhO1xyXG4gICAgICAgIGRhaWx5VG90YWwudG90YWxWYWx1ZSArPSB2YWx1ZTtcclxuICAgICAgICBkYWlseVRvdGFsLmludm9pY2VDb3VudCsrO1xyXG4gICAgICAgIGlmIChkb2N1bWVudFR5cGUgPT09ICdBX1BBR0FSJykge1xyXG4gICAgICAgICAgdG90YWxQYXlhYmxlICs9IHZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRUeXBlID09PSAnQV9SRUNFQkVSJykge1xyXG4gICAgICAgICAgdG90YWxSZWNlaXZhYmxlICs9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBncmFuZFRvdGFsVmFsdWUgKz0gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBicmFuY2hUb3RhbHMgPSBBcnJheS5mcm9tKGJyYW5jaFRvdGFsc01hcC5lbnRyaWVzKCkpLm1hcCgoW2JyYW5jaCwgZGF0YV0pID0+ICh7XHJcbiAgICAgICAgaWQ6IHJhbmRvbVVVSUQoKSxcclxuICAgICAgICBicmFuY2gsXHJcbiAgICAgICAgaW52b2ljZUNvdW50OiBkYXRhLmludm9pY2VDb3VudCxcclxuICAgICAgICB0b3RhbFZhbHVlOiBgUiQgJHtkYXRhLnRvdGFsVmFsdWUudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSl9YCxcclxuICAgICAgICB3ZWVrU3RhcnQ6IGRhdGEud2Vla1N0YXJ0LFxyXG4gICAgICAgIHdlZWtFbmQ6IGRhdGEud2Vla0VuZFxyXG4gICAgICB9KSk7XHJcbiAgICAgIGNvbnN0IGRhaWx5VG90YWxzID0gQXJyYXkuZnJvbShkYWlseVRvdGFsc01hcC52YWx1ZXMoKSkubWFwKGRhdGEgPT4gKHtcclxuICAgICAgICBpZDogcmFuZG9tVVVJRCgpLFxyXG4gICAgICAgIC4uLmRhdGEsXHJcbiAgICAgICAgdG90YWxWYWx1ZTogYFIkICR7ZGF0YS50b3RhbFZhbHVlLnRvTG9jYWxlU3RyaW5nKCdwdC1CUicsIHsgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyIH0pfWBcclxuICAgICAgfSkpO1xyXG4gICAgICBjb25zdCB3b3JraW5nRGF5c1RvdGFsID0gZGFpbHlUb3RhbHNcclxuICAgICAgICAuZmlsdGVyKGQgPT4gIVswLCA2XS5pbmNsdWRlcyhkLmRhdGUuZ2V0RGF5KCkpKVxyXG4gICAgICAgIC5yZWR1Y2UoKHN1bSwgZCkgPT4gc3VtICsgcGFyc2VNb25ldGFyeVZhbHVlKGQudG90YWxWYWx1ZSksIDApO1xyXG4gICAgICBjb25zdCB3ZWVrZW5kVG90YWwgPSBkYWlseVRvdGFsc1xyXG4gICAgICAgIC5maWx0ZXIoZCA9PiBbMCwgNl0uaW5jbHVkZXMoZC5kYXRlLmdldERheSgpKSlcclxuICAgICAgICAucmVkdWNlKChzdW0sIGQpID0+IHN1bSArIHBhcnNlTW9uZXRhcnlWYWx1ZShkLnRvdGFsVmFsdWUpLCAwKTtcclxuICAgICAgY29uc3Qgd29ya2luZ0RheXMgPSBkYWlseVRvdGFscy5maWx0ZXIoZCA9PiAhWzAsIDZdLmluY2x1ZGVzKGQuZGF0ZS5nZXREYXkoKSkpLmxlbmd0aDtcclxuICAgICAgY29uc3Qgd2Vla2VuZERheXMgPSBkYWlseVRvdGFscy5maWx0ZXIoZCA9PiBbMCwgNl0uaW5jbHVkZXMoZC5kYXRlLmdldERheSgpKSkubGVuZ3RoO1xyXG4gICAgICBjb25zdCBtaW5EYXRlID0gZmlsZVRyYW5zYWN0aW9ucy5sZW5ndGggPiAwIFxyXG4gICAgICAgID8gbmV3IERhdGUoTWF0aC5taW4oLi4uZmlsZVRyYW5zYWN0aW9ucy5tYXAodCA9PiB0LmRhdGUuZ2V0VGltZSgpKSkpXHJcbiAgICAgICAgOiBuZXcgRGF0ZSgpO1xyXG4gICAgICBjb25zdCBtYXhEYXRlID0gZmlsZVRyYW5zYWN0aW9ucy5sZW5ndGggPiAwIFxyXG4gICAgICAgID8gbmV3IERhdGUoTWF0aC5tYXgoLi4uZmlsZVRyYW5zYWN0aW9ucy5tYXAodCA9PiB0LmRhdGUuZ2V0VGltZSgpKSkpXHJcbiAgICAgICAgOiBuZXcgRGF0ZSgpO1xyXG4gICAgICBhbGxGaWxlc1Jlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgZmlsZW5hbWU6IGZpbGUub3JpZ2luYWxGaWxlbmFtZSxcclxuICAgICAgICBicmFuY2g6IGJyYW5jaE5hbWUsXHJcbiAgICAgICAgcHJvY2Vzc2VkRGF0YToge1xyXG4gICAgICAgICAgYnJhbmNoVG90YWxzLFxyXG4gICAgICAgICAgZGFpbHlUb3RhbHMsXHJcbiAgICAgICAgICB3ZWVrbHlUb3RhbHM6IHtcclxuICAgICAgICAgICAgd29ya2luZ0RheXNUb3RhbDogYFIkICR7d29ya2luZ0RheXNUb3RhbC50b0xvY2FsZVN0cmluZygncHQtQlInLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gLFxyXG4gICAgICAgICAgICB3ZWVrZW5kVG90YWw6IGBSJCAke3dlZWtlbmRUb3RhbC50b0xvY2FsZVN0cmluZygncHQtQlInLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gLFxyXG4gICAgICAgICAgICB3ZWVrVG90YWw6IGBSJCAke2dyYW5kVG90YWxWYWx1ZS50b0xvY2FsZVN0cmluZygncHQtQlInLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gLFxyXG4gICAgICAgICAgICB3b3JraW5nRGF5cyxcclxuICAgICAgICAgICAgd2Vla2VuZERheXMsXHJcbiAgICAgICAgICAgIHdlZWtQZXJpb2Q6IGAke21pbkRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdwdC1CUicpfSAtICR7bWF4RGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ3B0LUJSJyl9YCxcclxuICAgICAgICAgICAgdG90YWxQYXlhYmxlLFxyXG4gICAgICAgICAgICB0b3RhbFJlY2VpdmFibGVcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBncmFuZFRvdGFsOiBgUiQgJHtncmFuZFRvdGFsVmFsdWUudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSl9YCxcclxuICAgICAgICAgIHRvdGFsSW52b2ljZXM6IGZpbGVUcmFuc2FjdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgLy8gTGltcGFyIGFycXVpdm8gdGVtcG9yw6FyaW9cclxuICAgICAgaWYgKGZpbGUuZmlsZXBhdGggJiYgZnMuZXhpc3RzU3luYyhmaWxlLmZpbGVwYXRoKSkge1xyXG4gICAgICAgIGZzLnVubGlua1N5bmMoZmlsZS5maWxlcGF0aCk7XHJcbiAgICAgIH1cclxuICAgICAgfSBjYXRjaChwcm9jZXNzRmlsZUVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gcHJvY2Vzc2FyIGFycXVpdm8gaW5kaXZpZHVhbCwgY29udGludWFuZG8gY29tIG9zIGRlbWFpczonLCBmaWxlPy5vcmlnaW5hbEZpbGVuYW1lLCBwcm9jZXNzRmlsZUVycik7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQWdyZWdhw6fDo28gZGUgZGFkb3NcclxuICAgIGNvbnN0IGJyYW5jaFRvdGFsc01hcCA9IG5ldyBNYXA8c3RyaW5nLCB7XHJcbiAgICAgIGludm9pY2VDb3VudDogbnVtYmVyO1xyXG4gICAgICB0b3RhbFZhbHVlOiBudW1iZXI7XHJcbiAgICAgIHdlZWtTdGFydDogRGF0ZTtcclxuICAgICAgd2Vla0VuZDogRGF0ZTtcclxuICAgIH0+KCk7XHJcbiAgICBcclxuICAgIGNvbnN0IGRhaWx5VG90YWxzTWFwID0gbmV3IE1hcDxzdHJpbmcsIHtcclxuICAgICAgZGF0ZTogRGF0ZTtcclxuICAgICAgZGF5T2ZXZWVrOiBzdHJpbmc7XHJcbiAgICAgIHRvdGFsVmFsdWU6IG51bWJlcjtcclxuICAgICAgaW52b2ljZUNvdW50OiBudW1iZXI7XHJcbiAgICAgIGJyYW5jaDogc3RyaW5nO1xyXG4gICAgfT4oKTtcclxuICAgIFxyXG4gICAgbGV0IHRvdGFsUGF5YWJsZSA9IDA7XHJcbiAgICBsZXQgdG90YWxSZWNlaXZhYmxlID0gMDtcclxuICAgIGxldCBncmFuZFRvdGFsVmFsdWUgPSAwO1xyXG4gICAgXHJcbiAgICAvLyBQcm9jZXNzYXIgdHJhbnNhw6fDtWVzIHBhcmEgYWdyZWdhw6fDo29cclxuICAgIGFsbFRyYW5zYWN0aW9ucy5mb3JFYWNoKHRyYW5zYWN0aW9uID0+IHtcclxuICAgICAgY29uc3QgeyBicmFuY2gsIGRhdGUsIHZhbHVlLCBkb2N1bWVudFR5cGUgfSA9IHRyYW5zYWN0aW9uO1xyXG4gICAgICBcclxuICAgICAgLy8gQXR1YWxpemFyIHRvdGFpcyBwb3IgZmlsaWFsXHJcbiAgICAgIGNvbnN0IHsgd2Vla1N0YXJ0LCB3ZWVrRW5kIH0gPSBnZXRXZWVrQm91bmRhcmllcyhkYXRlKTtcclxuICAgICAgY29uc3QgYnJhbmNoS2V5ID0gYnJhbmNoO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFicmFuY2hUb3RhbHNNYXAuaGFzKGJyYW5jaEtleSkpIHtcclxuICAgICAgICBicmFuY2hUb3RhbHNNYXAuc2V0KGJyYW5jaEtleSwge1xyXG4gICAgICAgICAgaW52b2ljZUNvdW50OiAwLFxyXG4gICAgICAgICAgdG90YWxWYWx1ZTogMCxcclxuICAgICAgICAgIHdlZWtTdGFydCxcclxuICAgICAgICAgIHdlZWtFbmRcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgYnJhbmNoVG90YWwgPSBicmFuY2hUb3RhbHNNYXAuZ2V0KGJyYW5jaEtleSkhO1xyXG4gICAgICBicmFuY2hUb3RhbC5pbnZvaWNlQ291bnQrKztcclxuICAgICAgYnJhbmNoVG90YWwudG90YWxWYWx1ZSArPSB2YWx1ZTtcclxuICAgICAgXHJcbiAgICAgIC8vIEF0dWFsaXphciB0b3RhaXMgZGnDoXJpb3NcclxuICAgICAgY29uc3QgZGF0ZUtleSA9IGAke2JyYW5jaH0tJHtkYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXX1gO1xyXG4gICAgICBjb25zdCBkYXlPZldlZWsgPSBbJ0RvbWluZ28nLCAnU2VndW5kYScsICdUZXLDp2EnLCAnUXVhcnRhJywgJ1F1aW50YScsICdTZXh0YScsICdTw6FiYWRvJ11bZGF0ZS5nZXREYXkoKV07XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWRhaWx5VG90YWxzTWFwLmhhcyhkYXRlS2V5KSkge1xyXG4gICAgICAgIGRhaWx5VG90YWxzTWFwLnNldChkYXRlS2V5LCB7XHJcbiAgICAgICAgICBkYXRlLFxyXG4gICAgICAgICAgZGF5T2ZXZWVrLFxyXG4gICAgICAgICAgdG90YWxWYWx1ZTogMCxcclxuICAgICAgICAgIGludm9pY2VDb3VudDogMCxcclxuICAgICAgICAgIGJyYW5jaFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBkYWlseVRvdGFsID0gZGFpbHlUb3RhbHNNYXAuZ2V0KGRhdGVLZXkpITtcclxuICAgICAgZGFpbHlUb3RhbC50b3RhbFZhbHVlICs9IHZhbHVlO1xyXG4gICAgICBkYWlseVRvdGFsLmludm9pY2VDb3VudCsrO1xyXG4gICAgICBcclxuICAgICAgLy8gQXR1YWxpemFyIHRvdGFpcyBwb3IgdGlwb1xyXG4gICAgICBpZiAoZG9jdW1lbnRUeXBlID09PSAnQV9QQUdBUicpIHtcclxuICAgICAgICB0b3RhbFBheWFibGUgKz0gdmFsdWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRUeXBlID09PSAnQV9SRUNFQkVSJykge1xyXG4gICAgICAgIHRvdGFsUmVjZWl2YWJsZSArPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgZ3JhbmRUb3RhbFZhbHVlICs9IHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIENvbnZlcnRlciBNYXBzIHBhcmEgYXJyYXlzXHJcbiAgICBjb25zdCBicmFuY2hUb3RhbHMgPSBBcnJheS5mcm9tKGJyYW5jaFRvdGFsc01hcC5lbnRyaWVzKCkpLm1hcCgoW2JyYW5jaCwgZGF0YV0pID0+ICh7XHJcbiAgICAgIGlkOiByYW5kb21VVUlEKCksXHJcbiAgICAgIGJyYW5jaCxcclxuICAgICAgaW52b2ljZUNvdW50OiBkYXRhLmludm9pY2VDb3VudCxcclxuICAgICAgdG90YWxWYWx1ZTogYFIkICR7ZGF0YS50b3RhbFZhbHVlLnRvTG9jYWxlU3RyaW5nKCdwdC1CUicsIHsgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyIH0pfWAsXHJcbiAgICAgIHdlZWtTdGFydDogZGF0YS53ZWVrU3RhcnQsXHJcbiAgICAgIHdlZWtFbmQ6IGRhdGEud2Vla0VuZFxyXG4gICAgfSkpO1xyXG4gICAgXHJcbiAgICBjb25zdCBkYWlseVRvdGFscyA9IEFycmF5LmZyb20oZGFpbHlUb3RhbHNNYXAudmFsdWVzKCkpLm1hcChkYXRhID0+ICh7XHJcbiAgICAgIGlkOiByYW5kb21VVUlEKCksXHJcbiAgICAgIC4uLmRhdGEsXHJcbiAgICAgIHRvdGFsVmFsdWU6IGBSJCAke2RhdGEudG90YWxWYWx1ZS50b0xvY2FsZVN0cmluZygncHQtQlInLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gXHJcbiAgICB9KSk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGFyIHRvdGFpcyBzZW1hbmFpc1xyXG4gICAgY29uc3Qgd29ya2luZ0RheXNUb3RhbCA9IGRhaWx5VG90YWxzXHJcbiAgICAgIC5maWx0ZXIoZCA9PiAhWzAsIDZdLmluY2x1ZGVzKGQuZGF0ZS5nZXREYXkoKSkpIC8vIE7Do28gZG9taW5nby9zw6FiYWRvXHJcbiAgICAgIC5yZWR1Y2UoKHN1bSwgZCkgPT4gc3VtICsgcGFyc2VNb25ldGFyeVZhbHVlKGQudG90YWxWYWx1ZSksIDApO1xyXG4gICAgICBcclxuICAgIGNvbnN0IHdlZWtlbmRUb3RhbCA9IGRhaWx5VG90YWxzXHJcbiAgICAgIC5maWx0ZXIoZCA9PiBbMCwgNl0uaW5jbHVkZXMoZC5kYXRlLmdldERheSgpKSkgLy8gRG9taW5nby9zw6FiYWRvXHJcbiAgICAgIC5yZWR1Y2UoKHN1bSwgZCkgPT4gc3VtICsgcGFyc2VNb25ldGFyeVZhbHVlKGQudG90YWxWYWx1ZSksIDApO1xyXG4gICAgXHJcbiAgICBjb25zdCB3b3JraW5nRGF5cyA9IGRhaWx5VG90YWxzLmZpbHRlcihkID0+ICFbMCwgNl0uaW5jbHVkZXMoZC5kYXRlLmdldERheSgpKSkubGVuZ3RoO1xyXG4gICAgY29uc3Qgd2Vla2VuZERheXMgPSBkYWlseVRvdGFscy5maWx0ZXIoZCA9PiBbMCwgNl0uaW5jbHVkZXMoZC5kYXRlLmdldERheSgpKSkubGVuZ3RoO1xyXG4gICAgXHJcbiAgICBjb25zdCBtaW5EYXRlID0gYWxsVHJhbnNhY3Rpb25zLmxlbmd0aCA+IDAgXHJcbiAgICAgID8gbmV3IERhdGUoTWF0aC5taW4oLi4uYWxsVHJhbnNhY3Rpb25zLm1hcCh0ID0+IHQuZGF0ZS5nZXRUaW1lKCkpKSlcclxuICAgICAgOiBuZXcgRGF0ZSgpO1xyXG4gICAgY29uc3QgbWF4RGF0ZSA9IGFsbFRyYW5zYWN0aW9ucy5sZW5ndGggPiAwIFxyXG4gICAgICA/IG5ldyBEYXRlKE1hdGgubWF4KC4uLmFsbFRyYW5zYWN0aW9ucy5tYXAodCA9PiB0LmRhdGUuZ2V0VGltZSgpKSkpXHJcbiAgICAgIDogbmV3IERhdGUoKTtcclxuICAgIFxyXG4gICAgY29uc3QgcHJvY2Vzc2VkRGF0YTogUHJvY2Vzc2VkRGF0YSA9IHtcclxuICAgICAgYnJhbmNoVG90YWxzLFxyXG4gICAgICBkYWlseVRvdGFscyxcclxuICAgICAgd2Vla2x5VG90YWxzOiB7XHJcbiAgICAgICAgd29ya2luZ0RheXNUb3RhbDogYFIkICR7d29ya2luZ0RheXNUb3RhbC50b0xvY2FsZVN0cmluZygncHQtQlInLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gLFxyXG4gICAgICAgIHdlZWtlbmRUb3RhbDogYFIkICR7d2Vla2VuZFRvdGFsLnRvTG9jYWxlU3RyaW5nKCdwdC1CUicsIHsgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyIH0pfWAsXHJcbiAgICAgICAgd2Vla1RvdGFsOiBgUiQgJHtncmFuZFRvdGFsVmFsdWUudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSl9YCxcclxuICAgICAgICB3b3JraW5nRGF5cyxcclxuICAgICAgICB3ZWVrZW5kRGF5cyxcclxuICAgICAgICB3ZWVrUGVyaW9kOiBgJHttaW5EYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygncHQtQlInKX0gLSAke21heERhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdwdC1CUicpfWAsXHJcbiAgICAgICAgdG90YWxQYXlhYmxlLFxyXG4gICAgICAgIHRvdGFsUmVjZWl2YWJsZVxyXG4gICAgICB9LFxyXG4gICAgICBncmFuZFRvdGFsOiBgUiQgJHtncmFuZFRvdGFsVmFsdWUudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSl9YCxcclxuICAgICAgdG90YWxJbnZvaWNlczogYWxsVHJhbnNhY3Rpb25zLmxlbmd0aCxcclxuICAgICAgdHJhbnNhY3Rpb25zOiBhbGxUcmFuc2FjdGlvbnMubWFwKHRyYW5zYWN0aW9uID0+ICh7XHJcbiAgICAgICAgdmVuY2ltZW50bzogdHJhbnNhY3Rpb24uZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ3B0LUJSJyksXHJcbiAgICAgICAgdHJhbnNhY2lvbmFkb3I6IHRyYW5zYWN0aW9uLnN1cHBsaWVyLCAgLy8gVVNBTkRPIHN1cHBsaWVyIENPUlJFVE9cclxuICAgICAgICBkb2N1bWVudG86IHRyYW5zYWN0aW9uLmRvY051bWJlciwgICAgICAvLyBVU0FORE8gZG9jTnVtYmVyIENPUlJFVE8gIFxyXG4gICAgICAgIHZhbG9yOiBgUiQgJHt0cmFuc2FjdGlvbi52YWx1ZS50b0xvY2FsZVN0cmluZygncHQtQlInLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gLFxyXG4gICAgICAgIHZhbG9yTnVtZXJpY286IHRyYW5zYWN0aW9uLnZhbHVlLFxyXG4gICAgICAgIGRvY3VtZW50VHlwZTogdHJhbnNhY3Rpb24uZG9jdW1lbnRUeXBlLCAvLyBwcmVzZXJ2YSB0aXBvIHJlYWwgKEFfUEFHQVIgLyBBX1JFQ0VCRVIpXHJcbiAgICAgICAgZmlsaWFsOiB0cmFuc2FjdGlvbi5icmFuY2gsICAgICAgICAgICAgIC8vIHByZXNlcnZhIGZpbGlhbFxyXG4gICAgICAgIHNvdXJjZUZpbGU6IHRyYW5zYWN0aW9uLnNvdXJjZUZpbGUgICAgICAvLyBub21lIG9yaWdpbmFsIGRvIGFycXVpdm9cclxuICAgICAgfSkpXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENhY2hlIGRvcyBkYWRvcyBwcm9jZXNzYWRvcyBwYXJhIGV4cG9ydGHDp8OjbyBwb3N0ZXJpb3Igc2VtIHByZWNpc2FyIHJlZW52aWFyIHBlbG8gZnJvbnRlbmRcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNhY2hlUGF0aCA9IHBhdGguam9pbih0ZW1wRGlyLCAnbGFzdF9wcm9jZXNzZWQuanNvbicpO1xyXG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGNhY2hlUGF0aCwgSlNPTi5zdHJpbmdpZnkocHJvY2Vzc2VkRGF0YSwgbnVsbCwgMiksICd1dGY4Jyk7XHJcbiAgICB9IGNhdGNoIChjYWNoZUVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ07Do28gZm9pIHBvc3PDrXZlbCBzYWx2YXIgY2FjaGUgZGUgcHJvY2Vzc2VkRGF0YTonLCBjYWNoZUVycik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT0gSU7DjUNJTzogR0VSQcOHw4NPIERFIHN1bW1hcnlEYXRhIFBBUkEgL2FwaS9leHBvcnQtc3VtbWFyeS1leGNlbCA9PT09PVxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR3VhcmRhciBwcm9jZXNzZWREYXRhIGVtIG1lbcOzcmlhIHRhbWLDqW1cclxuICAgICAgc3RvcmFnZS5zZXQoJ3Byb2Nlc3NlZERhdGEnLCBwcm9jZXNzZWREYXRhKTtcclxuXHJcbiAgICAgIC8vIE1hcGVhciB0cmFuc2HDp8O1ZXMgZW0gZXN0cnV0dXJhIGNvbXBhdMOtdmVsXHJcbiAgICAgIGludGVyZmFjZSBTdW1tYXJ5QnJhbmNoIHtcclxuICAgICAgICBuYW1lOiBzdHJpbmc7IHRvdGFsQVBhZ2FyOiBudW1iZXI7IHRvdGFsQVJlY2ViZXI6IG51bWJlcjsgdG90YWw6IG51bWJlcjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBicmFuY2hNYXA6IFJlY29yZDxzdHJpbmcsIHsgcGFnYXI6IG51bWJlcjsgcmVjZWJlcjogbnVtYmVyIH0+ID0ge307XHJcbiAgICAgIGNvbnN0IGRhdGVUb3RhbHNNYXA6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuXHJcbiAgICAgIHByb2Nlc3NlZERhdGEudHJhbnNhY3Rpb25zLmZvckVhY2godHIgPT4ge1xyXG4gICAgICAgIGNvbnN0IGJyYW5jaCA9IHRyLmZpbGlhbCB8fCB0ci5zb3VyY2VGaWxlPy5yZXBsYWNlKC9cXC5jc3YkL2ksICcnKSB8fCAnREVTQ09OSEVDSURBJztcclxuICAgICAgICBpZiAoIWJyYW5jaE1hcFticmFuY2hdKSBicmFuY2hNYXBbYnJhbmNoXSA9IHsgcGFnYXI6IDAsIHJlY2ViZXI6IDAgfTtcclxuICAgICAgICBpZiAodHIuZG9jdW1lbnRUeXBlID09PSAnQV9QQUdBUicpIGJyYW5jaE1hcFticmFuY2hdLnBhZ2FyICs9IHRyLnZhbG9yTnVtZXJpY287XHJcbiAgICAgICAgZWxzZSBpZiAodHIuZG9jdW1lbnRUeXBlID09PSAnQV9SRUNFQkVSJykgYnJhbmNoTWFwW2JyYW5jaF0ucmVjZWJlciArPSB0ci52YWxvck51bWVyaWNvO1xyXG5cclxuICAgICAgICAvLyBUb3RhaXMgcG9yIGRhdGEgKHVzYW5kbyBhcGVuYXMgQV9QQUdBUiBwYXJhIG1hbnRlciBjb25zaXN0w6puY2lhIGNvbSByZXN1bW8gYW50ZXJpb3IpXHJcbiAgICAgICAgaWYgKHRyLmRvY3VtZW50VHlwZSA9PT0gJ0FfUEFHQVInKSB7XHJcbiAgICAgICAgICBjb25zdCBkYXRlU3RyID0gdHIudmVuY2ltZW50bzsgLy8gasOhIGVtIEREL01NL1lZWVlcclxuICAgICAgICAgICAgaWYgKCFkYXRlVG90YWxzTWFwW2RhdGVTdHJdKSBkYXRlVG90YWxzTWFwW2RhdGVTdHJdID0gMDtcclxuICAgICAgICAgICAgZGF0ZVRvdGFsc01hcFtkYXRlU3RyXSArPSB0ci52YWxvck51bWVyaWNvO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBicmFuY2hlc1N1bW1hcnk6IFN1bW1hcnlCcmFuY2hbXSA9IE9iamVjdC5lbnRyaWVzKGJyYW5jaE1hcCkubWFwKChbbmFtZSwgdl0pID0+ICh7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICB0b3RhbEFQYWdhcjogdi5wYWdhcixcclxuICAgICAgICB0b3RhbEFSZWNlYmVyOiB2LnJlY2ViZXIsXHJcbiAgICAgICAgdG90YWw6IHYucGFnYXIgKyB2LnJlY2ViZXJcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgLy8gQ29uc3RydWlyIGRhdGVTcGVjaWZpY1RvdGFscyBvcmRlbmFkb1xyXG4gICAgICBjb25zdCBkYXRlU3BlY2lmaWNUb3RhbHMgPSBPYmplY3QuZW50cmllcyhkYXRlVG90YWxzTWFwKS5tYXAoKFtkYXksIHRvdGFsXSkgPT4gKHsgZGF5LCB0b3RhbCB9KSlcclxuICAgICAgICAuZmlsdGVyKGQgPT4gL1xcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7NH0vLnRlc3QoZC5kYXkpKVxyXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBbZGEsIG1hLCB5YV0gPSBhLmRheS5zcGxpdCgnLycpLm1hcChOdW1iZXIpO1xyXG4gICAgICAgICAgY29uc3QgW2RiLCBtYiwgeWJdID0gYi5kYXkuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKTtcclxuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5YSwgbWEgLSAxLCBkYSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoeWIsIG1iIC0gMSwgZGIpLmdldFRpbWUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIC8vIERvY3VtZW50RGF0ZXMgY29tIGRpYSBkYSBzZW1hbmEgKGFwZW5hcyBkaWFzIMO6dGVpcylcclxuICAgICAgY29uc3QgZG9jdW1lbnREYXRlcyA9IGRhdGVTcGVjaWZpY1RvdGFscy5tYXAoZCA9PiB7XHJcbiAgICAgICAgY29uc3QgW2RheSwgbW9udGgsIHllYXJdID0gZC5kYXkuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKTtcclxuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xyXG4gICAgICAgIGNvbnN0IGRheU5hbWVzID0gWydEb21pbmdvJywgJ1NlZ3VuZGEnLCAnVGVyw6dhJywgJ1F1YXJ0YScsICdRdWludGEnLCAnU2V4dGEnLCAnU8OhYmFkbyddO1xyXG4gICAgICAgIHJldHVybiB7IGRheTogZC5kYXksIGRheU9mV2VlazogZGF5TmFtZXNbZGF0ZS5nZXREYXkoKV0sIHRvdGFsOiBkLnRvdGFsLCBkYXRlIH07XHJcbiAgICAgIH0pLmZpbHRlcihpdGVtID0+IHtcclxuICAgICAgICBjb25zdCBkb3cgPSBpdGVtLmRhdGUuZ2V0RGF5KCk7XHJcbiAgICAgICAgcmV0dXJuIGRvdyA+PSAxICYmIGRvdyA8PSA1OyAvLyBkaWFzIMO6dGVpc1xyXG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhLmRhdGUuZ2V0VGltZSgpIC0gYi5kYXRlLmdldFRpbWUoKSlcclxuICAgICAgICAubWFwKCh7IGRheSwgZGF5T2ZXZWVrLCB0b3RhbCB9KSA9PiAoeyBkYXksIGRheU9mV2VlaywgdG90YWwgfSkpO1xyXG5cclxuICAgICAgY29uc3QgZ3JhbmRUb3RhbEFQYWdhciA9IGJyYW5jaGVzU3VtbWFyeS5yZWR1Y2UoKHMsIGIpID0+IHMgKyBiLnRvdGFsQVBhZ2FyLCAwKTtcclxuICAgICAgY29uc3QgZ3JhbmRUb3RhbEFSZWNlYmVyID0gYnJhbmNoZXNTdW1tYXJ5LnJlZHVjZSgocywgYikgPT4gcyArIGIudG90YWxBUmVjZWJlciwgMCk7XHJcbiAgICAgIGNvbnN0IGdyYW5kVG90YWwgPSBkYXRlU3BlY2lmaWNUb3RhbHMucmVkdWNlKChzLCBkKSA9PiBzICsgZC50b3RhbCwgMCk7XHJcblxyXG4gICAgICBjb25zdCBzdW1tYXJ5RGF0YSA9IHtcclxuICAgICAgICBicmFuY2hlczogYnJhbmNoZXNTdW1tYXJ5LFxyXG4gICAgICAgIGRhaWx5VG90YWxzOiBbXSwgLy8gbsOjbyB1dGlsaXphZG8gbm8gZXhwb3J0IGF0dWFsXHJcbiAgICAgICAgZG9jdW1lbnREYXRlcyxcclxuICAgICAgICBkYXRlU3BlY2lmaWNUb3RhbHMsXHJcbiAgICAgICAgZ3JhbmRUb3RhbCxcclxuICAgICAgICBncmFuZFRvdGFsQVBhZ2FyLFxyXG4gICAgICAgIGdyYW5kVG90YWxBUmVjZWJlcixcclxuICAgICAgICB0b3RhbEFQYWdhcjogZ3JhbmRUb3RhbEFQYWdhclxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc3RvcmFnZS5zZXQoJ3N1bW1hcnlEYXRhJywgc3VtbWFyeURhdGEpO1xyXG4gICAgfSBjYXRjaChzdW1tYXJ5RXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignRmFsaGEgYW8gZ2VyYXIgc3VtbWFyeURhdGEgYSBwYXJ0aXIgZGUgcHJvY2Vzc2VkRGF0YTonLCBzdW1tYXJ5RXJyKTtcclxuICAgIH1cclxuICAgIC8vID09PT09IEZJTTogR0VSQcOHw4NPIERFIHN1bW1hcnlEYXRhID09PT09XHJcblxyXG4gICAgLy8gQ3JlYXRlIHJlc3BvbnNlIGRhdGEgd2l0aG91dCB0cmFuc2FjdGlvbnMgdG8gbWF0Y2ggY2xpZW50IHNjaGVtYVxyXG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMsIC4uLmNsaWVudFByb2Nlc3NlZERhdGEgfSA9IHByb2Nlc3NlZERhdGE7XHJcblxyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogYCR7Y3N2RmlsZXMubGVuZ3RofSBhcnF1aXZvKHMpIHByb2Nlc3NhZG8ocykgY29tIHN1Y2Vzc29gLFxyXG4gICAgICBkYXRhOiBhbGxGaWxlc1Jlc3VsdHMsXHJcbiAgICAgIHN1bW1hcnlEYXRhOiBzdG9yYWdlLmdldCgnc3VtbWFyeURhdGEnKSB8fCBudWxsLFxyXG4gICAgICBhbGxGaWxlc0RhdGFcclxuICAgIH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCc9PT0gRVJST1IgSU4gVVBMT0FELUNTViA9PT0nKTtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHR5cGU6JywgdHlwZW9mIGVycm9yKTtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1lc3NhZ2U6JywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpKTtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN0YWNrOicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6ICdObyBzdGFjayB0cmFjZScpO1xyXG4gICAgY29uc29sZS5lcnJvcignRnVsbCBlcnJvciBvYmplY3Q6JywgZXJyb3IpO1xyXG4gICAgXHJcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7IFxyXG4gICAgICBzdWNjZXNzOiBmYWxzZSwgXHJcbiAgICAgIG1lc3NhZ2U6ICdFcnJvIGludGVybm8gZG8gc2Vydmlkb3I6ICcgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpKVxyXG4gICAgfSlcclxuICB9XHJcbn0iXSwibmFtZXMiOlsiZm9ybWlkYWJsZSIsImZzIiwiUGFwYSIsInBhdGgiLCJzdG9yYWdlIiwicmFuZG9tVVVJRCIsInBhcnNlQ1NWRGF0ZSIsImRhdGVTdHIiLCJmb3JtYXRzIiwiZm9ybWF0IiwibWF0Y2giLCJEYXRlIiwicGFyc2VJbnQiLCJnZXRXZWVrQm91bmRhcmllcyIsImRhdGUiLCJkYXlPZldlZWsiLCJnZXREYXkiLCJ3ZWVrU3RhcnQiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInNldEhvdXJzIiwid2Vla0VuZCIsInBhcnNlTW9uZXRhcnlWYWx1ZSIsInN0ciIsImNsZWFuVmFsdWUiLCJyZXBsYWNlIiwiaXNOZWdhdGl2ZSIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJ2YWx1ZSIsInBhcnNlRmxvYXQiLCJkZXRlY3RFbmNvZGluZyIsImJ1ZmZlciIsImVuY29kaW5ncyIsImVuY29kaW5nIiwiZGVjb2RlZCIsInRvU3RyaW5nIiwiaW5jbHVkZXMiLCJlcnJvciIsImV4dHJhaXJUcmFuc2FjaW9uYWRvckVEb2N1bWVudG8iLCJjc3ZDb250ZW50IiwiZG9jdW1lbnRUeXBlIiwibm9tZUZpbGlhbCIsInBhcnNlUmVzdWx0IiwicGFyc2UiLCJoZWFkZXIiLCJza2lwRW1wdHlMaW5lcyIsInJvd3MiLCJkYXRhIiwiZG9jdW1lbnRvc0V4dHJhaWRvcyIsInJvdyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImNhdGVnb3J5IiwidHJpbSIsInRyYW5zYWNpb25hZG9yIiwibnVtZXJvRG9jdW1lbnRvIiwidmFsdWVTdHIiLCJpc05hTiIsImdldFRpbWUiLCJ0cmFuc2FjaW9uYWRvckZpbmFsIiwibnVtZXJvRG9jdW1lbnRvRmluYWwiLCJwdXNoIiwiZGF0YVZlbmNpbWVudG8iLCJ2YWxvciIsInZhbG9yT3JpZ2luYWwiLCJjYXRlZ29yaWEiLCJmaWxpYWwiLCJzb3VyY2VGaWxlIiwiY29uZmlnIiwiYXBpIiwiYm9keVBhcnNlciIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwibWVzc2FnZSIsInF1ZXJ5IiwiY2xlYXJEYXRhIiwiZGVsZXRlIiwiY29uc29sZSIsImxvZyIsImhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5IiwidGVtcERpciIsImV4aXN0c1N5bmMiLCJta2RpclN5bmMiLCJyZWN1cnNpdmUiLCJmb3JtIiwidXBsb2FkRGlyIiwia2VlcEV4dGVuc2lvbnMiLCJtYXhGaWxlcyIsIm1heEZpbGVTaXplIiwiZmllbGRzIiwiZmlsZXMiLCJPYmplY3QiLCJrZXlzIiwic2VsZWN0ZWRUeXBlcyIsImRvY3VtZW50VHlwZXMiLCJkb2N1bWVudFR5cGVzU3RyaW5nIiwicGFyc2VkIiwiYWxsVHlwZXMiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwidHlwZUFycmF5IiwidW5pcXVlVHlwZXMiLCJmcm9tIiwiU2V0IiwiZSIsImFsbEZpbGVzIiwiZmxhdCIsImZpbHRlciIsIkJvb2xlYW4iLCJtYXAiLCJmIiwib3JpZ2luYWxGaWxlbmFtZSIsImZpbGVwYXRoIiwiY3N2RmlsZXMiLCJmaWxlIiwibWltZXR5cGUiLCJzaXplIiwidGVzdCIsIm5hbWUiLCJ0eXBlIiwic3VjY2VzcyIsImFsbFRyYW5zYWN0aW9ucyIsImFsbEZpbGVzRGF0YSIsImFsbEZpbGVzUmVzdWx0cyIsInJlYWRGaWxlU3luYyIsImJyYW5jaE5hbWUiLCJ0b1VwcGVyQ2FzZSIsImZpbGVUcmFuc2FjdGlvbnMiLCJzbGljZSIsImRvYyIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInRyYW5zYWN0aW9uIiwic3VwcGxpZXIiLCJkb2NOdW1iZXIiLCJicmFuY2giLCJmaWxlbmFtZSIsInRyYW5zYWN0aW9ucyIsInRvdGFsVHJhbnNhY3Rpb25zIiwiYnJhbmNoVG90YWxzTWFwIiwiTWFwIiwiZGFpbHlUb3RhbHNNYXAiLCJ0b3RhbFBheWFibGUiLCJ0b3RhbFJlY2VpdmFibGUiLCJncmFuZFRvdGFsVmFsdWUiLCJicmFuY2hLZXkiLCJoYXMiLCJzZXQiLCJpbnZvaWNlQ291bnQiLCJ0b3RhbFZhbHVlIiwiYnJhbmNoVG90YWwiLCJnZXQiLCJkYXRlS2V5IiwidG9JU09TdHJpbmciLCJzcGxpdCIsImRhaWx5VG90YWwiLCJicmFuY2hUb3RhbHMiLCJlbnRyaWVzIiwiaWQiLCJ0b0xvY2FsZVN0cmluZyIsIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsImRhaWx5VG90YWxzIiwid29ya2luZ0RheXNUb3RhbCIsImQiLCJyZWR1Y2UiLCJzdW0iLCJ3ZWVrZW5kVG90YWwiLCJ3b3JraW5nRGF5cyIsIndlZWtlbmREYXlzIiwibWluRGF0ZSIsIk1hdGgiLCJtaW4iLCJ0IiwibWF4RGF0ZSIsIm1heCIsInByb2Nlc3NlZERhdGEiLCJ3ZWVrbHlUb3RhbHMiLCJ3ZWVrVG90YWwiLCJ3ZWVrUGVyaW9kIiwiZ3JhbmRUb3RhbCIsInRvdGFsSW52b2ljZXMiLCJ1bmxpbmtTeW5jIiwicHJvY2Vzc0ZpbGVFcnIiLCJ2ZW5jaW1lbnRvIiwiZG9jdW1lbnRvIiwidmFsb3JOdW1lcmljbyIsImNhY2hlUGF0aCIsImpvaW4iLCJ3cml0ZUZpbGVTeW5jIiwiY2FjaGVFcnIiLCJ3YXJuIiwiYnJhbmNoTWFwIiwiZGF0ZVRvdGFsc01hcCIsInRyIiwicGFnYXIiLCJyZWNlYmVyIiwiYnJhbmNoZXNTdW1tYXJ5IiwidiIsInRvdGFsQVBhZ2FyIiwidG90YWxBUmVjZWJlciIsInRvdGFsIiwiZGF0ZVNwZWNpZmljVG90YWxzIiwiZGF5Iiwic29ydCIsImEiLCJiIiwiZGEiLCJtYSIsInlhIiwiTnVtYmVyIiwiZGIiLCJtYiIsInliIiwiZG9jdW1lbnREYXRlcyIsIm1vbnRoIiwieWVhciIsImRheU5hbWVzIiwiaXRlbSIsImRvdyIsImdyYW5kVG90YWxBUGFnYXIiLCJzIiwiZ3JhbmRUb3RhbEFSZWNlYmVyIiwic3VtbWFyeURhdGEiLCJicmFuY2hlcyIsInN1bW1hcnlFcnIiLCJjbGllbnRQcm9jZXNzZWREYXRhIiwiRXJyb3IiLCJTdHJpbmciLCJzdGFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/upload-csv.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fupload-csv&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cupload-csv.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();