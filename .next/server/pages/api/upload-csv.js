"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/upload-csv";
exports.ids = ["pages/api/upload-csv"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "papaparse":
/*!****************************!*\
  !*** external "papaparse" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("papaparse");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "formidable":
/*!*****************************!*\
  !*** external "formidable" ***!
  \*****************************/
/***/ ((module) => {

module.exports = import("formidable");;

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fupload-csv&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cupload-csv.ts&middlewareConfigBase64=e30%3D!":
/*!**************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fupload-csv&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cupload-csv.ts&middlewareConfigBase64=e30%3D! ***!
  \**************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\upload-csv.ts */ \"(api)/./pages/api/upload-csv.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/upload-csv\",\n        pathname: \"/api/upload-csv\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_upload_csv_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRnVwbG9hZC1jc3YmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZwYWdlcyU1Q2FwaSU1Q3VwbG9hZC1jc3YudHMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ0w7QUFDMUQ7QUFDd0Q7QUFDeEQ7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLHFEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxxREFBUTtBQUNwQztBQUNPLHdCQUF3QixnSEFBbUI7QUFDbEQ7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQscUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3RhZmxleC1uZXh0anMvPzk2YmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzXFxcXGFwaVxcXFx1cGxvYWQtY3N2LnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvdXBsb2FkLWNzdlwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3VwbG9hZC1jc3ZcIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiBcIlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fupload-csv&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cupload-csv.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./lib/storage.ts":
/*!************************!*\
  !*** ./lib/storage.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   storage: () => (/* binding */ storage)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n// lib/storage.ts\n\n\nclass PersistentStorage {\n    constructor(){\n        this.data = {};\n        this.filePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"temp\", \"storage_cache.json\");\n        this.ensureDirectoryExists();\n        this.loadFromFile();\n    }\n    ensureDirectoryExists() {\n        const dir = path__WEBPACK_IMPORTED_MODULE_1___default().dirname(this.filePath);\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(dir)) {\n            fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(dir, {\n                recursive: true\n            });\n        }\n    }\n    loadFromFile() {\n        try {\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(this.filePath)) {\n                const content = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(this.filePath, \"utf-8\");\n                this.data = JSON.parse(content);\n                console.log(\"[STORAGE] Dados carregados do cache:\", Object.keys(this.data));\n            }\n        } catch (error) {\n            console.warn(\"[STORAGE] Erro ao carregar cache:\", error);\n            this.data = {};\n        }\n    }\n    saveToFile() {\n        try {\n            fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(this.filePath, JSON.stringify(this.data, null, 2));\n            console.log(\"[STORAGE] Dados salvos no cache:\", Object.keys(this.data));\n        } catch (error) {\n            console.warn(\"[STORAGE] Erro ao salvar cache:\", error);\n        }\n    }\n    get(key) {\n        return this.data[key];\n    }\n    set(key, value) {\n        this.data[key] = value;\n        this.saveToFile();\n        console.log(`[STORAGE] Definido ${key}:`, typeof value === \"object\" ? JSON.stringify(value).substring(0, 100) + \"...\" : value);\n    }\n    delete(key) {\n        delete this.data[key];\n        this.saveToFile();\n    }\n    keys() {\n        return Object.keys(this.data);\n    }\n    clear() {\n        this.data = {};\n        this.saveToFile();\n    }\n}\n// Criar instância singleton\nconst persistentStorage = new PersistentStorage();\n// Proxy para manter compatibilidade com sintaxe de array\nconst storage = new Proxy(persistentStorage, {\n    get (target, prop) {\n        if (typeof prop === \"string\") {\n            // Se for um método da classe, retornar o método\n            if (typeof target[prop] === \"function\") {\n                return target[prop].bind(target);\n            }\n            // Caso contrário, tratar como chave de dados\n            return target.get(prop);\n        }\n        return target[prop];\n    },\n    set (target, prop, value) {\n        if (typeof prop === \"string\") {\n            target.set(prop, value);\n            return true;\n        }\n        return false;\n    },\n    deleteProperty (target, prop) {\n        if (typeof prop === \"string\") {\n            target.delete(prop);\n            return true;\n        }\n        return false;\n    },\n    ownKeys (target) {\n        return target.keys();\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtJQUNBVCxLQUFJUSxNQUFNLEVBQUVDLElBQXFCLEVBQUVSLEtBQUs7UUFDdEMsSUFBSSxPQUFPUSxTQUFTLFVBQVU7WUFDNUJELE9BQU9SLEdBQUcsQ0FBQ1MsTUFBTVI7WUFDakIsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBQ0FVLGdCQUFlSCxNQUFNLEVBQUVDLElBQXFCO1FBQzFDLElBQUksT0FBT0EsU0FBUyxVQUFVO1lBQzVCRCxPQUFPTCxNQUFNLENBQUNNO1lBQ2QsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBQ0FHLFNBQVFKLE1BQU07UUFDWixPQUFPQSxPQUFPaEIsSUFBSTtJQUNwQjtBQUNGLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3RhZmxleC1uZXh0anMvLi9saWIvc3RvcmFnZS50cz81ZGM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9zdG9yYWdlLnRzXHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuaW50ZXJmYWNlIFN0b3JhZ2VEYXRhIHtcclxuICBba2V5OiBzdHJpbmddOiBhbnk7XHJcbn1cclxuXHJcbmNsYXNzIFBlcnNpc3RlbnRTdG9yYWdlIHtcclxuICBwcml2YXRlIGRhdGE6IFN0b3JhZ2VEYXRhID0ge307XHJcbiAgcHJpdmF0ZSBmaWxlUGF0aDogc3RyaW5nO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuZmlsZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RlbXAnLCAnc3RvcmFnZV9jYWNoZS5qc29uJyk7XHJcbiAgICB0aGlzLmVuc3VyZURpcmVjdG9yeUV4aXN0cygpO1xyXG4gICAgdGhpcy5sb2FkRnJvbUZpbGUoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZW5zdXJlRGlyZWN0b3J5RXhpc3RzKCkge1xyXG4gICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKHRoaXMuZmlsZVBhdGgpO1xyXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcclxuICAgICAgZnMubWtkaXJTeW5jKGRpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGxvYWRGcm9tRmlsZSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKHRoaXMuZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLmZpbGVQYXRoLCAndXRmLTgnKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbU1RPUkFHRV0gRGFkb3MgY2FycmVnYWRvcyBkbyBjYWNoZTonLCBPYmplY3Qua2V5cyh0aGlzLmRhdGEpKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdbU1RPUkFHRV0gRXJybyBhbyBjYXJyZWdhciBjYWNoZTonLCBlcnJvcik7XHJcbiAgICAgIHRoaXMuZGF0YSA9IHt9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzYXZlVG9GaWxlKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLmZpbGVQYXRoLCBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEsIG51bGwsIDIpKTtcclxuICAgICAgY29uc29sZS5sb2coJ1tTVE9SQUdFXSBEYWRvcyBzYWx2b3Mgbm8gY2FjaGU6JywgT2JqZWN0LmtleXModGhpcy5kYXRhKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1tTVE9SQUdFXSBFcnJvIGFvIHNhbHZhciBjYWNoZTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQoa2V5OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcclxuICB9XHJcblxyXG4gIHNldChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkge1xyXG4gICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgIHRoaXMuc2F2ZVRvRmlsZSgpO1xyXG4gICAgY29uc29sZS5sb2coYFtTVE9SQUdFXSBEZWZpbmlkbyAke2tleX06YCwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKS5zdWJzdHJpbmcoMCwgMTAwKSArICcuLi4nIDogdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgZGVsZXRlKGtleTogc3RyaW5nKSB7XHJcbiAgICBkZWxldGUgdGhpcy5kYXRhW2tleV07XHJcbiAgICB0aGlzLnNhdmVUb0ZpbGUoKTtcclxuICB9XHJcblxyXG4gIGtleXMoKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhKTtcclxuICB9XHJcblxyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5kYXRhID0ge307XHJcbiAgICB0aGlzLnNhdmVUb0ZpbGUoKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIENyaWFyIGluc3TDom5jaWEgc2luZ2xldG9uXHJcbmNvbnN0IHBlcnNpc3RlbnRTdG9yYWdlID0gbmV3IFBlcnNpc3RlbnRTdG9yYWdlKCk7XHJcblxyXG4vLyBQcm94eSBwYXJhIG1hbnRlciBjb21wYXRpYmlsaWRhZGUgY29tIHNpbnRheGUgZGUgYXJyYXlcclxuZXhwb3J0IGNvbnN0IHN0b3JhZ2UgPSBuZXcgUHJveHkocGVyc2lzdGVudFN0b3JhZ2UsIHtcclxuICBnZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcgfCBzeW1ib2wpIHtcclxuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgLy8gU2UgZm9yIHVtIG3DqXRvZG8gZGEgY2xhc3NlLCByZXRvcm5hciBvIG3DqXRvZG9cclxuICAgICAgaWYgKHR5cGVvZiAodGFyZ2V0IGFzIGFueSlbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gKHRhcmdldCBhcyBhbnkpW3Byb3BdLmJpbmQodGFyZ2V0KTtcclxuICAgICAgfVxyXG4gICAgICAvLyBDYXNvIGNvbnRyw6FyaW8sIHRyYXRhciBjb21vIGNoYXZlIGRlIGRhZG9zXHJcbiAgICAgIHJldHVybiB0YXJnZXQuZ2V0KHByb3ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICh0YXJnZXQgYXMgYW55KVtwcm9wXTtcclxuICB9LFxyXG4gIHNldCh0YXJnZXQsIHByb3A6IHN0cmluZyB8IHN5bWJvbCwgdmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdGFyZ2V0LnNldChwcm9wLCB2YWx1ZSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wOiBzdHJpbmcgfCBzeW1ib2wpIHtcclxuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdGFyZ2V0LmRlbGV0ZShwcm9wKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuICBvd25LZXlzKHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHRhcmdldC5rZXlzKCk7XHJcbiAgfVxyXG59KTtcclxuIl0sIm5hbWVzIjpbImZzIiwicGF0aCIsIlBlcnNpc3RlbnRTdG9yYWdlIiwiY29uc3RydWN0b3IiLCJkYXRhIiwiZmlsZVBhdGgiLCJqb2luIiwicHJvY2VzcyIsImN3ZCIsImVuc3VyZURpcmVjdG9yeUV4aXN0cyIsImxvYWRGcm9tRmlsZSIsImRpciIsImRpcm5hbWUiLCJleGlzdHNTeW5jIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwiY29udGVudCIsInJlYWRGaWxlU3luYyIsIkpTT04iLCJwYXJzZSIsImNvbnNvbGUiLCJsb2ciLCJPYmplY3QiLCJrZXlzIiwiZXJyb3IiLCJ3YXJuIiwic2F2ZVRvRmlsZSIsIndyaXRlRmlsZVN5bmMiLCJzdHJpbmdpZnkiLCJnZXQiLCJrZXkiLCJzZXQiLCJ2YWx1ZSIsInN1YnN0cmluZyIsImRlbGV0ZSIsImNsZWFyIiwicGVyc2lzdGVudFN0b3JhZ2UiLCJzdG9yYWdlIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwiYmluZCIsImRlbGV0ZVByb3BlcnR5Iiwib3duS2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./lib/storage.ts\n");

/***/ }),

/***/ "(api)/./pages/api/upload-csv.ts":
/*!*********************************!*\
  !*** ./pages/api/upload-csv.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var formidable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! formidable */ \"formidable\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! papaparse */ \"papaparse\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lib_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/storage */ \"(api)/./lib/storage.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([formidable__WEBPACK_IMPORTED_MODULE_0__]);\nformidable__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n// Função para parsing de datas CSV (EXATA)\nfunction parseCSVDate(dateStr) {\n    const formats = [\n        /(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/,\n        /(\\d{4})-(\\d{1,2})-(\\d{1,2})/\n    ];\n    for (const format of formats){\n        const match = dateStr.match(format);\n        if (match) {\n            if (format === formats[0]) {\n                // DD/MM/YYYY - formato brasileiro\n                return new Date(parseInt(match[3]), parseInt(match[2]) - 1, parseInt(match[1]));\n            } else {\n                // YYYY-MM-DD - formato ISO\n                return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));\n            }\n        }\n    }\n    return new Date(dateStr); // Fallback\n}\n// Função auxiliar para semana (EXATA)\nfunction getWeekBoundaries(date) {\n    const dayOfWeek = date.getDay();\n    const weekStart = new Date(date);\n    weekStart.setDate(date.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1)); // Monday\n    weekStart.setHours(0, 0, 0, 0);\n    const weekEnd = new Date(weekStart);\n    weekEnd.setDate(weekStart.getDate() + 6); // Sunday\n    weekEnd.setHours(23, 59, 59, 999);\n    return {\n        weekStart,\n        weekEnd\n    };\n}\n// Função para parsing de valores monetários\nfunction parseMonetaryValue(str) {\n    let cleanValue = str.replace(/[R$\\s]/g, \"\").replace(/\\./g, \"\").replace(\",\", \".\");\n    const isNegative = cleanValue.startsWith(\"-\");\n    if (isNegative) {\n        cleanValue = cleanValue.substring(1);\n    }\n    const value = parseFloat(cleanValue);\n    return isNegative ? -value : value;\n}\n// Função para detectar encoding\nfunction detectEncoding(buffer) {\n    const encodings = [\n        \"utf-8\",\n        \"latin1\",\n        \"ascii\",\n        \"utf16le\"\n    ];\n    for (const encoding of encodings){\n        try {\n            const decoded = buffer.toString(encoding);\n            // Verificar se contém caracteres especiais brasileiros\n            if (decoded.includes(\"\\xe7\") || decoded.includes(\"\\xe3\") || decoded.includes(\"\\xe9\")) {\n                return encoding;\n            }\n        } catch (error) {\n            continue;\n        }\n    }\n    return \"utf-8\"; // fallback\n}\n// Função para extrair transacionador e documento seguindo especificação EXATA\nfunction extrairTransacionadorEDocumento(csvContent, documentType, nomeFilial) {\n    // Parse CSV sem headers\n    const parseResult = papaparse__WEBPACK_IMPORTED_MODULE_2___default().parse(csvContent, {\n        header: false,\n        skipEmptyLines: true\n    });\n    const rows = parseResult.data;\n    const documentosExtraidos = [];\n    // Processar cada linha do CSV\n    for (const row of rows){\n        // VALIDAÇÃO ESTRUTURAL OBRIGATÓRIA\n        if (!Array.isArray(row) || row.length < 5) continue;\n        const category = row[0]?.toString().trim() || \"\";\n        let dateStr = \"\";\n        let transacionador = \"\";\n        let numeroDocumento = \"\";\n        let valueStr = \"\";\n        // LÓGICA DE IDENTIFICAÇÃO POR TIPO DE DOCUMENTO\n        if (documentType === \"A_PAGAR\") {\n            // Match EXATO - não usar includes()\n            if (category !== \"Contas a pagar- \\xc0 vencer\") continue;\n            // MAPEAMENTO FIXO DAS COLUNAS:\n            dateStr = row[1]?.toString().trim() || \"\"; // COLUNA 1: Data Vencimento\n            transacionador = row[2]?.toString().trim() || \"\"; // COLUNA 2: TRANSACIONADOR\n            numeroDocumento = row[3]?.toString().trim() || \"\"; // COLUNA 3: NÚMERO DO DOCUMENTO\n            valueStr = row[5]?.toString().trim() || \"0\"; // COLUNA 5: Valor (SEMPRE coluna 5)\n        } else if (documentType === \"A_RECEBER\") {\n            // Match EXATO - não usar includes()\n            if (category !== \"Contas a receber - A vencer\") continue;\n            // MAPEAMENTO FIXO DAS COLUNAS:\n            dateStr = row[1]?.toString().trim() || \"\"; // COLUNA 1: Data Vencimento\n            transacionador = row[2]?.toString().trim() || \"\"; // COLUNA 2: TRANSACIONADOR\n            numeroDocumento = row[3]?.toString().trim() || \"\"; // COLUNA 3: NÚMERO DO DOCUMENTO\n            valueStr = row[5]?.toString().trim() || \"0\"; // COLUNA 5: Valor (SEMPRE coluna 5)\n        }\n        // VALIDAÇÕES OBRIGATÓRIAS DOS DADOS EXTRAÍDOS\n        if (!dateStr || !transacionador || !valueStr) continue;\n        // PARSING DA DATA DE VENCIMENTO\n        const date = parseCSVDate(dateStr);\n        if (!date || isNaN(date.getTime())) continue;\n        // PARSING DO VALOR MONETÁRIO (formato brasileiro)\n        let cleanValue = valueStr.replace(/[R$\\s]/g, \"\").replace(/\\./g, \"\").replace(\",\", \".\");\n        const isNegative = cleanValue.startsWith(\"-\");\n        if (isNegative) {\n            cleanValue = cleanValue.substring(1);\n        }\n        const value = parseFloat(cleanValue);\n        if (isNaN(value) || value <= 0) continue;\n        // APLICAÇÃO DE FALLBACKS PARA CAMPOS OBRIGATÓRIOS\n        const transacionadorFinal = transacionador || \"FORNECEDOR N\\xc3O IDENTIFICADO\";\n        const numeroDocumentoFinal = numeroDocumento || \"\"; // Removido fallback 'PENDENTE'\n        // ESTRUTURA FINAL DOS DADOS EXTRAÍDOS\n        const { weekStart, weekEnd } = getWeekBoundaries(date);\n        documentosExtraidos.push({\n            dataVencimento: date,\n            transacionador: transacionadorFinal,\n            numeroDocumento: numeroDocumentoFinal,\n            valor: value,\n            valorOriginal: valueStr,\n            categoria: documentType,\n            filial: nomeFilial,\n            // Dados de compatibilidade\n            weekStart: weekStart,\n            weekEnd: weekEnd,\n            sourceFile: `${nomeFilial}.csv`\n        });\n    }\n    return documentosExtraidos;\n}\n// Configuração para desabilitar o parser padrão do Next.js\nconst config = {\n    api: {\n        bodyParser: false\n    }\n};\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            message: \"Method not allowed\"\n        });\n    }\n    try {\n        // Opcional: limpar dados anteriores se solicitado\n        if (req.query.clearData === \"true\") {\n            _lib_storage__WEBPACK_IMPORTED_MODULE_4__.storage.delete(\"summaryData\");\n            _lib_storage__WEBPACK_IMPORTED_MODULE_4__.storage.delete(\"processedData\");\n        }\n        console.log(\"=== DEBUG UPLOAD CSV ===\");\n        console.log(\"Method:\", req.method);\n        console.log(\"Content-Type:\", req.headers[\"content-type\"]);\n        console.log(\"Headers:\", JSON.stringify(req.headers, null, 2));\n        // Garantir que a pasta temp existe\n        const tempDir = \"./temp\";\n        if (!fs__WEBPACK_IMPORTED_MODULE_1___default().existsSync(tempDir)) {\n            fs__WEBPACK_IMPORTED_MODULE_1___default().mkdirSync(tempDir, {\n                recursive: true\n            });\n        }\n        // Configurar formidable para upload de múltiplos arquivos\n        const form = (0,formidable__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            uploadDir: tempDir,\n            keepExtensions: true,\n            maxFiles: 10,\n            maxFileSize: 10 * 1024 * 1024\n        });\n        const [fields, files] = await form.parse(req);\n        console.log(\"=== PARSED DATA ===\");\n        console.log(\"Fields:\", JSON.stringify(fields, null, 2));\n        console.log(\"Files keys:\", Object.keys(files));\n        console.log(\"Files structure:\", JSON.stringify(files, null, 2));\n        // Obter tipos de documento selecionados\n        let selectedTypes = [\n            \"A_PAGAR\",\n            \"A_RECEBER\"\n        ]; // Default\n        if (fields.documentTypes && fields.documentTypes.length > 0) {\n            const documentTypesString = fields.documentTypes[0];\n            console.log(\"documentTypesString recebido:\", documentTypesString);\n            try {\n                // Tentar fazer parse se for JSON\n                const parsed = JSON.parse(documentTypesString);\n                console.log(\"JSON parsed:\", parsed);\n                if (Array.isArray(parsed)) {\n                    selectedTypes = parsed;\n                } else if (typeof parsed === \"object\") {\n                    // Se for um objeto com indices, extrair os valores e flatten\n                    const allTypes = [];\n                    Object.values(parsed).forEach((typeArray)=>{\n                        if (Array.isArray(typeArray)) {\n                            allTypes.push(...typeArray);\n                        }\n                    });\n                    // Remover duplicatas\n                    const uniqueTypes = Array.from(new Set(allTypes));\n                    selectedTypes = uniqueTypes;\n                }\n            } catch (e) {\n                console.log(\"Erro no parse JSON:\", e);\n                // Se não for JSON, usar como array direto\n                selectedTypes = Array.isArray(fields.documentTypes) ? fields.documentTypes : [\n                    documentTypesString\n                ];\n            }\n        }\n        console.log(\"Selected types processados:\", selectedTypes);\n        // NORMALIZAÇÃO ROBUSTA DE ARQUIVOS (multi-field, multi-file)\n        const allFiles = Object.values(files).flat().filter(Boolean);\n        console.log(\"=== FILE PROCESSING ===\");\n        console.log(\"allFiles (normalizado):\", allFiles.map((f)=>({\n                originalFilename: f.originalFilename,\n                path: f.filepath\n            })));\n        console.log(\"allFiles length:\", allFiles.length);\n        // Filtrar apenas arquivos CSV - sendo mais permissivo para debug\n        const csvFiles = allFiles.filter((file)=>{\n            console.log(\"Checking file:\", file ? {\n                originalFilename: file.originalFilename,\n                mimetype: file.mimetype,\n                size: file.size,\n                filepath: file.filepath\n            } : \"null file\");\n            if (!file || !file.originalFilename) return false;\n            // Aceitar .csv ou .txt (alguns sistemas exportam assim), case insensitive\n            return /\\.(csv|txt)$/i.test(file.originalFilename);\n        });\n        console.log(\"=== FILTERING RESULTS ===\");\n        console.log(\"CSV Files found:\", csvFiles.length);\n        console.log(\"Selected types:\", selectedTypes);\n        console.log(\"CSV Files details:\", csvFiles.map((f)=>f ? {\n                name: f.originalFilename,\n                type: f.mimetype,\n                size: f.size\n            } : null));\n        if (csvFiles.length === 0) {\n            console.log(\"=== ERROR: NO FILES ===\");\n            console.log(\"No CSV files found after filtering\");\n            return res.status(400).json({\n                success: false,\n                message: `Nenhum arquivo foi encontrado. Arquivos recebidos: ${allFiles.length}. Verifique se o arquivo é um CSV válido.`\n            });\n        }\n        const allTransactions = [];\n        const allFilesData = [];\n        // Processar cada arquivo CSV\n        for (const file of csvFiles){\n            console.log(`=== PROCESSING FILE: ${file?.originalFilename} ===`);\n            if (!file || !file.filepath) {\n                console.log(\"Skipping invalid file:\", file);\n                continue;\n            }\n            try {\n                console.log(\"File path:\", file.filepath);\n                console.log(\"File exists:\", fs__WEBPACK_IMPORTED_MODULE_1___default().existsSync(file.filepath));\n                const buffer = fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(file.filepath);\n                const encoding = detectEncoding(buffer);\n                const csvContent = buffer.toString(encoding);\n                // Extrair nome da filial\n                const branchName = (file.originalFilename || \"FILIAL_DESCONHECIDA\").replace(/\\.(csv|txt)$/i, \"\").toUpperCase();\n                const fileTransactions = [];\n                // Processar cada tipo de documento selecionado usando a nova lógica\n                for (const documentType of selectedTypes){\n                    console.log(`Processando tipo de documento: ${documentType} para arquivo: ${file.originalFilename}`);\n                    // Usar a função de extração específica com a lógica correta\n                    const documentosExtraidos = extrairTransacionadorEDocumento(csvContent, documentType, branchName);\n                    console.log(`Documentos extraídos para ${documentType}:`, documentosExtraidos.length);\n                    // Log dos primeiros documentos para debug\n                    if (documentosExtraidos.length > 0) {\n                        console.log(\"Primeiros documentos extra\\xeddos:\", documentosExtraidos.slice(0, 3).map((doc)=>({\n                                transacionador: doc.transacionador,\n                                numeroDocumento: doc.numeroDocumento,\n                                valor: doc.valor,\n                                dataVencimento: doc.dataVencimento.toLocaleDateString(\"pt-BR\")\n                            })));\n                    }\n                    // Converter para o formato TransactionData (manter compatibilidade)\n                    for (const doc of documentosExtraidos){\n                        const transaction = {\n                            date: doc.dataVencimento,\n                            supplier: doc.transacionador,\n                            docNumber: doc.numeroDocumento,\n                            value: doc.valor,\n                            category: documentType === \"A_PAGAR\" ? \"Contas a pagar- \\xc0 vencer\" : \"Contas a receber - A vencer\",\n                            branch: doc.filial,\n                            documentType: doc.categoria,\n                            sourceFile: file.originalFilename || `${branchName}.csv`\n                        };\n                        fileTransactions.push(transaction);\n                        allTransactions.push(transaction);\n                    }\n                }\n                allFilesData.push({\n                    filename: file.originalFilename,\n                    branch: branchName,\n                    transactions: fileTransactions,\n                    totalTransactions: fileTransactions.length\n                });\n                // Limpar arquivo temporário\n                if (file.filepath && fs__WEBPACK_IMPORTED_MODULE_1___default().existsSync(file.filepath)) {\n                    fs__WEBPACK_IMPORTED_MODULE_1___default().unlinkSync(file.filepath);\n                }\n            } catch (processFileErr) {\n                console.error(\"Erro ao processar arquivo individual, continuando com os demais:\", file?.originalFilename, processFileErr);\n                continue;\n            }\n        }\n        // Agregação de dados\n        const branchTotalsMap = new Map();\n        const dailyTotalsMap = new Map();\n        let totalPayable = 0;\n        let totalReceivable = 0;\n        let grandTotalValue = 0;\n        // Processar transações para agregação\n        allTransactions.forEach((transaction)=>{\n            const { branch, date, value, documentType } = transaction;\n            // Atualizar totais por filial\n            const { weekStart, weekEnd } = getWeekBoundaries(date);\n            const branchKey = branch;\n            if (!branchTotalsMap.has(branchKey)) {\n                branchTotalsMap.set(branchKey, {\n                    invoiceCount: 0,\n                    totalValue: 0,\n                    weekStart,\n                    weekEnd\n                });\n            }\n            const branchTotal = branchTotalsMap.get(branchKey);\n            branchTotal.invoiceCount++;\n            branchTotal.totalValue += value;\n            // Atualizar totais diários\n            const dateKey = `${branch}-${date.toISOString().split(\"T\")[0]}`;\n            const dayOfWeek = [\n                \"Domingo\",\n                \"Segunda\",\n                \"Ter\\xe7a\",\n                \"Quarta\",\n                \"Quinta\",\n                \"Sexta\",\n                \"S\\xe1bado\"\n            ][date.getDay()];\n            if (!dailyTotalsMap.has(dateKey)) {\n                dailyTotalsMap.set(dateKey, {\n                    date,\n                    dayOfWeek,\n                    totalValue: 0,\n                    invoiceCount: 0,\n                    branch\n                });\n            }\n            const dailyTotal = dailyTotalsMap.get(dateKey);\n            dailyTotal.totalValue += value;\n            dailyTotal.invoiceCount++;\n            // Atualizar totais por tipo\n            if (documentType === \"A_PAGAR\") {\n                totalPayable += value;\n            } else if (documentType === \"A_RECEBER\") {\n                totalReceivable += value;\n            }\n            grandTotalValue += value;\n        });\n        // Converter Maps para arrays\n        const branchTotals = Array.from(branchTotalsMap.entries()).map(([branch, data])=>({\n                branch,\n                invoiceCount: data.invoiceCount,\n                totalValue: `R$ ${data.totalValue.toLocaleString(\"pt-BR\", {\n                    minimumFractionDigits: 2\n                })}`,\n                weekStart: data.weekStart,\n                weekEnd: data.weekEnd\n            }));\n        const dailyTotals = Array.from(dailyTotalsMap.values()).map((data)=>({\n                ...data,\n                totalValue: `R$ ${data.totalValue.toLocaleString(\"pt-BR\", {\n                    minimumFractionDigits: 2\n                })}`\n            }));\n        // Calcular totais semanais\n        const workingDaysTotal = dailyTotals.filter((d)=>![\n                0,\n                6\n            ].includes(d.date.getDay())) // Não domingo/sábado\n        .reduce((sum, d)=>sum + parseMonetaryValue(d.totalValue), 0);\n        const weekendTotal = dailyTotals.filter((d)=>[\n                0,\n                6\n            ].includes(d.date.getDay())) // Domingo/sábado\n        .reduce((sum, d)=>sum + parseMonetaryValue(d.totalValue), 0);\n        const workingDays = dailyTotals.filter((d)=>![\n                0,\n                6\n            ].includes(d.date.getDay())).length;\n        const weekendDays = dailyTotals.filter((d)=>[\n                0,\n                6\n            ].includes(d.date.getDay())).length;\n        const minDate = allTransactions.length > 0 ? new Date(Math.min(...allTransactions.map((t)=>t.date.getTime()))) : new Date();\n        const maxDate = allTransactions.length > 0 ? new Date(Math.max(...allTransactions.map((t)=>t.date.getTime()))) : new Date();\n        const processedData = {\n            branchTotals,\n            dailyTotals,\n            weeklyTotals: {\n                workingDaysTotal: `R$ ${workingDaysTotal.toLocaleString(\"pt-BR\", {\n                    minimumFractionDigits: 2\n                })}`,\n                weekendTotal: `R$ ${weekendTotal.toLocaleString(\"pt-BR\", {\n                    minimumFractionDigits: 2\n                })}`,\n                weekTotal: `R$ ${grandTotalValue.toLocaleString(\"pt-BR\", {\n                    minimumFractionDigits: 2\n                })}`,\n                workingDays,\n                weekendDays,\n                weekPeriod: `${minDate.toLocaleDateString(\"pt-BR\")} - ${maxDate.toLocaleDateString(\"pt-BR\")}`,\n                totalPayable,\n                totalReceivable\n            },\n            grandTotal: `R$ ${grandTotalValue.toLocaleString(\"pt-BR\", {\n                minimumFractionDigits: 2\n            })}`,\n            totalInvoices: allTransactions.length,\n            transactions: allTransactions.map((transaction)=>({\n                    vencimento: transaction.date.toLocaleDateString(\"pt-BR\"),\n                    transacionador: transaction.supplier,\n                    documento: transaction.docNumber,\n                    valor: `R$ ${transaction.value.toLocaleString(\"pt-BR\", {\n                        minimumFractionDigits: 2\n                    })}`,\n                    valorNumerico: transaction.value,\n                    documentType: transaction.documentType,\n                    filial: transaction.branch,\n                    sourceFile: transaction.sourceFile // nome original do arquivo\n                }))\n        };\n        // Cache dos dados processados para exportação posterior sem precisar reenviar pelo frontend\n        try {\n            const cachePath = path__WEBPACK_IMPORTED_MODULE_3___default().join(tempDir, \"last_processed.json\");\n            fs__WEBPACK_IMPORTED_MODULE_1___default().writeFileSync(cachePath, JSON.stringify(processedData, null, 2), \"utf8\");\n        } catch (cacheErr) {\n            console.warn(\"N\\xe3o foi poss\\xedvel salvar cache de processedData:\", cacheErr);\n        }\n        // ===== INÍCIO: GERAÇÃO DE summaryData PARA /api/export-summary-excel =====\n        try {\n            // Guardar processedData em memória também\n            _lib_storage__WEBPACK_IMPORTED_MODULE_4__.storage.set(\"processedData\", processedData);\n            const branchMap = {};\n            const dateTotalsMap = {};\n            processedData.transactions.forEach((tr)=>{\n                const branch = tr.filial || tr.sourceFile?.replace(/\\.csv$/i, \"\") || \"DESCONHECIDA\";\n                if (!branchMap[branch]) branchMap[branch] = {\n                    pagar: 0,\n                    receber: 0\n                };\n                if (tr.documentType === \"A_PAGAR\") branchMap[branch].pagar += tr.valorNumerico;\n                else if (tr.documentType === \"A_RECEBER\") branchMap[branch].receber += tr.valorNumerico;\n                // Totais por data (usando apenas A_PAGAR para manter consistência com resumo anterior)\n                if (tr.documentType === \"A_PAGAR\") {\n                    const dateStr = tr.vencimento; // já em DD/MM/YYYY\n                    if (!dateTotalsMap[dateStr]) dateTotalsMap[dateStr] = 0;\n                    dateTotalsMap[dateStr] += tr.valorNumerico;\n                }\n            });\n            const branchesSummary = Object.entries(branchMap).map(([name, v])=>({\n                    name,\n                    totalAPagar: v.pagar,\n                    totalAReceber: v.receber,\n                    total: v.pagar + v.receber\n                }));\n            // Construir dateSpecificTotals ordenado\n            const dateSpecificTotals = Object.entries(dateTotalsMap).map(([day, total])=>({\n                    day,\n                    total\n                })).filter((d)=>/\\d{1,2}\\/\\d{1,2}\\/\\d{4}/.test(d.day)).sort((a, b)=>{\n                const [da, ma, ya] = a.day.split(\"/\").map(Number);\n                const [db, mb, yb] = b.day.split(\"/\").map(Number);\n                return new Date(ya, ma - 1, da).getTime() - new Date(yb, mb - 1, db).getTime();\n            });\n            // DocumentDates com dia da semana (apenas dias úteis)\n            const documentDates = dateSpecificTotals.map((d)=>{\n                const [day, month, year] = d.day.split(\"/\").map(Number);\n                const date = new Date(year, month - 1, day);\n                const dayNames = [\n                    \"Domingo\",\n                    \"Segunda\",\n                    \"Ter\\xe7a\",\n                    \"Quarta\",\n                    \"Quinta\",\n                    \"Sexta\",\n                    \"S\\xe1bado\"\n                ];\n                return {\n                    day: d.day,\n                    dayOfWeek: dayNames[date.getDay()],\n                    total: d.total,\n                    date\n                };\n            }).filter((item)=>{\n                const dow = item.date.getDay();\n                return dow >= 1 && dow <= 5; // dias úteis\n            }).sort((a, b)=>a.date.getTime() - b.date.getTime()).map(({ day, dayOfWeek, total })=>({\n                    day,\n                    dayOfWeek,\n                    total\n                }));\n            const grandTotalAPagar = branchesSummary.reduce((s, b)=>s + b.totalAPagar, 0);\n            const grandTotalAReceber = branchesSummary.reduce((s, b)=>s + b.totalAReceber, 0);\n            const grandTotal = dateSpecificTotals.reduce((s, d)=>s + d.total, 0);\n            const summaryData = {\n                branches: branchesSummary,\n                dailyTotals: [],\n                documentDates,\n                dateSpecificTotals,\n                grandTotal,\n                grandTotalAPagar,\n                grandTotalAReceber,\n                totalAPagar: grandTotalAPagar\n            };\n            _lib_storage__WEBPACK_IMPORTED_MODULE_4__.storage.set(\"summaryData\", summaryData);\n        } catch (summaryErr) {\n            console.warn(\"Falha ao gerar summaryData a partir de processedData:\", summaryErr);\n        }\n        // ===== FIM: GERAÇÃO DE summaryData =====\n        return res.status(200).json({\n            success: true,\n            message: `${csvFiles.length} arquivo(s) processado(s) com sucesso`,\n            data: processedData,\n            summaryData: _lib_storage__WEBPACK_IMPORTED_MODULE_4__.storage.get(\"summaryData\") || null,\n            allFilesData\n        });\n    } catch (error) {\n        console.error(\"=== ERROR IN UPLOAD-CSV ===\");\n        console.error(\"Error type:\", typeof error);\n        console.error(\"Error message:\", error instanceof Error ? error.message : String(error));\n        console.error(\"Error stack:\", error instanceof Error ? error.stack : \"No stack trace\");\n        console.error(\"Full error object:\", error);\n        res.status(500).json({\n            success: false,\n            message: \"Erro interno do servidor: \" + (error instanceof Error ? error.message : String(error))\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFrQjtZQUMzQzdCO1FBQ0Y7SUFDRixFQUFFLE9BQU81RixPQUFPO1FBQ2Q2QyxRQUFRN0MsS0FBSyxDQUFDO1FBQ2Q2QyxRQUFRN0MsS0FBSyxDQUFDLGVBQWUsT0FBT0E7UUFDcEM2QyxRQUFRN0MsS0FBSyxDQUFDLGtCQUFrQkEsaUJBQWlCZ00sUUFBUWhNLE1BQU15QyxPQUFPLEdBQUd3SixPQUFPak07UUFDaEY2QyxRQUFRN0MsS0FBSyxDQUFDLGdCQUFnQkEsaUJBQWlCZ00sUUFBUWhNLE1BQU1rTSxLQUFLLEdBQUc7UUFDckVySixRQUFRN0MsS0FBSyxDQUFDLHNCQUFzQkE7UUFFcENxQyxJQUFJRSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQ25Ca0QsU0FBUztZQUNUakQsU0FBUywrQkFBZ0N6QyxDQUFBQSxpQkFBaUJnTSxRQUFRaE0sTUFBTXlDLE9BQU8sR0FBR3dKLE9BQU9qTSxNQUFLO1FBQ2hHO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGFmbGV4LW5leHRqcy8uL3BhZ2VzL2FwaS91cGxvYWQtY3N2LnRzPzZkZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCdcclxuaW1wb3J0IGZvcm1pZGFibGUgZnJvbSAnZm9ybWlkYWJsZSdcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xyXG5pbXBvcnQgUGFwYSBmcm9tICdwYXBhcGFyc2UnXHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXHJcbmltcG9ydCB7IHN0b3JhZ2UgfSBmcm9tICcuLi8uLi9saWIvc3RvcmFnZSdcclxuXHJcbi8vIEludGVyZmFjZXMgcGFyYSB0aXBvcyBkZSBkYWRvcyBwcm9jZXNzYWRvc1xyXG5pbnRlcmZhY2UgUHJvY2Vzc2VkRGF0YSB7XHJcbiAgYnJhbmNoVG90YWxzOiBBcnJheTx7XHJcbiAgICBicmFuY2g6IHN0cmluZztcclxuICAgIGludm9pY2VDb3VudDogbnVtYmVyO1xyXG4gICAgdG90YWxWYWx1ZTogc3RyaW5nO1xyXG4gICAgd2Vla1N0YXJ0OiBEYXRlO1xyXG4gICAgd2Vla0VuZDogRGF0ZTtcclxuICB9PjtcclxuICBkYWlseVRvdGFsczogQXJyYXk8e1xyXG4gICAgZGF0ZTogRGF0ZTtcclxuICAgIGRheU9mV2Vlazogc3RyaW5nO1xyXG4gICAgdG90YWxWYWx1ZTogc3RyaW5nO1xyXG4gICAgaW52b2ljZUNvdW50OiBudW1iZXI7XHJcbiAgICBicmFuY2g6IHN0cmluZztcclxuICB9PjtcclxuICB3ZWVrbHlUb3RhbHM6IHtcclxuICAgIHdvcmtpbmdEYXlzVG90YWw6IHN0cmluZztcclxuICAgIHdlZWtlbmRUb3RhbDogc3RyaW5nO1xyXG4gICAgd2Vla1RvdGFsOiBzdHJpbmc7XHJcbiAgICB3b3JraW5nRGF5czogbnVtYmVyO1xyXG4gICAgd2Vla2VuZERheXM6IG51bWJlcjtcclxuICAgIHdlZWtQZXJpb2Q6IHN0cmluZztcclxuICAgIHRvdGFsUGF5YWJsZTogbnVtYmVyO1xyXG4gICAgdG90YWxSZWNlaXZhYmxlOiBudW1iZXI7XHJcbiAgfTtcclxuICBncmFuZFRvdGFsOiBzdHJpbmc7XHJcbiAgdG90YWxJbnZvaWNlczogbnVtYmVyO1xyXG4gIHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25Gb3JFeGNlbFtdOyAvLyBBZGljaW9uYWRvIHBhcmEgZXhwb3J0YcOnw6NvIEV4Y2VsXHJcbn1cclxuXHJcbmludGVyZmFjZSBUcmFuc2FjdGlvbkRhdGEge1xyXG4gIGRhdGU6IERhdGU7XHJcbiAgc3VwcGxpZXI6IHN0cmluZztcclxuICBkb2NOdW1iZXI6IHN0cmluZztcclxuICB2YWx1ZTogbnVtYmVyO1xyXG4gIGNhdGVnb3J5OiBzdHJpbmc7XHJcbiAgYnJhbmNoOiBzdHJpbmc7XHJcbiAgZG9jdW1lbnRUeXBlOiAnQV9QQUdBUicgfCAnQV9SRUNFQkVSJztcclxuICBzb3VyY2VGaWxlOiBzdHJpbmc7IC8vIE5vbWUgb3JpZ2luYWwgZG8gYXJxdWl2byBwYXJhIHNlcGFyYXIgY2F0ZWdvcmlhcyBubyBFeGNlbFxyXG59XHJcblxyXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25Gb3JFeGNlbCB7XHJcbiAgdmVuY2ltZW50bzogc3RyaW5nO1xyXG4gIHRyYW5zYWNpb25hZG9yOiBzdHJpbmc7XHJcbiAgZG9jdW1lbnRvOiBzdHJpbmc7XHJcbiAgdmFsb3I6IHN0cmluZztcclxuICB2YWxvck51bWVyaWNvOiBudW1iZXI7XHJcbiAgZG9jdW1lbnRUeXBlPzogJ0FfUEFHQVInIHwgJ0FfUkVDRUJFUic7XHJcbiAgZmlsaWFsPzogc3RyaW5nO1xyXG4gIHNvdXJjZUZpbGU/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBEb2N1bWVudG9Qcm9jZXNzYWRvIHtcclxuICBkYXRhVmVuY2ltZW50bzogRGF0ZTtcclxuICB0cmFuc2FjaW9uYWRvcjogc3RyaW5nO1xyXG4gIG51bWVyb0RvY3VtZW50bzogc3RyaW5nO1xyXG4gIHZhbG9yOiBudW1iZXI7XHJcbiAgdmFsb3JPcmlnaW5hbDogc3RyaW5nO1xyXG4gIGNhdGVnb3JpYTogJ0FfUEFHQVInIHwgJ0FfUkVDRUJFUic7XHJcbiAgZmlsaWFsOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8vIEZ1bsOnw6NvIHBhcmEgcGFyc2luZyBkZSBkYXRhcyBDU1YgKEVYQVRBKVxyXG5mdW5jdGlvbiBwYXJzZUNTVkRhdGUoZGF0ZVN0cjogc3RyaW5nKTogRGF0ZSB7XHJcbiAgY29uc3QgZm9ybWF0cyA9IFtcclxuICAgIC8oXFxkezEsMn0pXFwvKFxcZHsxLDJ9KVxcLyhcXGR7NH0pLywgLy8gREQvTU0vWVlZWSAoZm9ybWF0byBicmFzaWxlaXJvKVxyXG4gICAgLyhcXGR7NH0pLShcXGR7MSwyfSktKFxcZHsxLDJ9KS8sICAvLyBZWVlZLU1NLUREIChmb3JtYXRvIElTTylcclxuICBdO1xyXG4gIFxyXG4gIGZvciAoY29uc3QgZm9ybWF0IG9mIGZvcm1hdHMpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gZGF0ZVN0ci5tYXRjaChmb3JtYXQpO1xyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgIGlmIChmb3JtYXQgPT09IGZvcm1hdHNbMF0pIHtcclxuICAgICAgICAvLyBERC9NTS9ZWVlZIC0gZm9ybWF0byBicmFzaWxlaXJvXHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlSW50KG1hdGNoWzNdKSwgcGFyc2VJbnQobWF0Y2hbMl0pIC0gMSwgcGFyc2VJbnQobWF0Y2hbMV0pKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBZWVlZLU1NLUREIC0gZm9ybWF0byBJU09cclxuICAgICAgICByZXR1cm4gbmV3IERhdGUocGFyc2VJbnQobWF0Y2hbMV0pLCBwYXJzZUludChtYXRjaFsyXSkgLSAxLCBwYXJzZUludChtYXRjaFszXSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBuZXcgRGF0ZShkYXRlU3RyKTsgLy8gRmFsbGJhY2tcclxufVxyXG5cclxuLy8gRnVuw6fDo28gYXV4aWxpYXIgcGFyYSBzZW1hbmEgKEVYQVRBKVxyXG5mdW5jdGlvbiBnZXRXZWVrQm91bmRhcmllcyhkYXRlOiBEYXRlKTogeyB3ZWVrU3RhcnQ6IERhdGU7IHdlZWtFbmQ6IERhdGUgfSB7XHJcbiAgY29uc3QgZGF5T2ZXZWVrID0gZGF0ZS5nZXREYXkoKTtcclxuICBjb25zdCB3ZWVrU3RhcnQgPSBuZXcgRGF0ZShkYXRlKTtcclxuICB3ZWVrU3RhcnQuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIGRheU9mV2VlayArIChkYXlPZldlZWsgPT09IDAgPyAtNiA6IDEpKTsgLy8gTW9uZGF5XHJcbiAgd2Vla1N0YXJ0LnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG4gIGNvbnN0IHdlZWtFbmQgPSBuZXcgRGF0ZSh3ZWVrU3RhcnQpO1xyXG4gIHdlZWtFbmQuc2V0RGF0ZSh3ZWVrU3RhcnQuZ2V0RGF0ZSgpICsgNik7IC8vIFN1bmRheVxyXG4gIHdlZWtFbmQuc2V0SG91cnMoMjMsIDU5LCA1OSwgOTk5KTtcclxuICByZXR1cm4geyB3ZWVrU3RhcnQsIHdlZWtFbmQgfTtcclxufVxyXG5cclxuLy8gRnVuw6fDo28gcGFyYSBwYXJzaW5nIGRlIHZhbG9yZXMgbW9uZXTDoXJpb3NcclxuZnVuY3Rpb24gcGFyc2VNb25ldGFyeVZhbHVlKHN0cjogc3RyaW5nKTogbnVtYmVyIHtcclxuICBsZXQgY2xlYW5WYWx1ZSA9IHN0ci5yZXBsYWNlKC9bUiRcXHNdL2csICcnKS5yZXBsYWNlKC9cXC4vZywgJycpLnJlcGxhY2UoJywnLCAnLicpO1xyXG4gIFxyXG4gIGNvbnN0IGlzTmVnYXRpdmUgPSBjbGVhblZhbHVlLnN0YXJ0c1dpdGgoJy0nKTtcclxuICBpZiAoaXNOZWdhdGl2ZSkge1xyXG4gICAgY2xlYW5WYWx1ZSA9IGNsZWFuVmFsdWUuc3Vic3RyaW5nKDEpO1xyXG4gIH1cclxuICBcclxuICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQoY2xlYW5WYWx1ZSk7XHJcbiAgcmV0dXJuIGlzTmVnYXRpdmUgPyAtdmFsdWUgOiB2YWx1ZTtcclxufVxyXG5cclxuLy8gRnVuw6fDo28gcGFyYSBkZXRlY3RhciBlbmNvZGluZ1xyXG5mdW5jdGlvbiBkZXRlY3RFbmNvZGluZyhidWZmZXI6IEJ1ZmZlcik6IHN0cmluZyB7XHJcbiAgY29uc3QgZW5jb2RpbmdzID0gWyd1dGYtOCcsICdsYXRpbjEnLCAnYXNjaWknLCAndXRmMTZsZSddO1xyXG4gIFxyXG4gIGZvciAoY29uc3QgZW5jb2Rpbmcgb2YgZW5jb2RpbmdzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkZWNvZGVkID0gYnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nIGFzIEJ1ZmZlckVuY29kaW5nKTtcclxuICAgICAgLy8gVmVyaWZpY2FyIHNlIGNvbnTDqW0gY2FyYWN0ZXJlcyBlc3BlY2lhaXMgYnJhc2lsZWlyb3NcclxuICAgICAgaWYgKGRlY29kZWQuaW5jbHVkZXMoJ8OnJykgfHwgZGVjb2RlZC5pbmNsdWRlcygnw6MnKSB8fCBkZWNvZGVkLmluY2x1ZGVzKCfDqScpKSB7XHJcbiAgICAgICAgcmV0dXJuIGVuY29kaW5nO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuICd1dGYtOCc7IC8vIGZhbGxiYWNrXHJcbn1cclxuXHJcbi8vIEludGVyZmFjZSBwYXJhIGRvY3VtZW50byBleHRyYcOtZG8gY29uZm9ybWUgZXNwZWNpZmljYcOnw6NvXHJcbmludGVyZmFjZSBEb2N1bWVudG9FeHRyYWlkbyB7XHJcbiAgZGF0YVZlbmNpbWVudG86IERhdGU7ICAgICAgICAgICAvLyBEYXRhIHBhcnNlYWRhIGRhIGNvbHVuYSAxXHJcbiAgdHJhbnNhY2lvbmFkb3I6IHN0cmluZzsgICAgICAgICAvLyBUUkFOU0FDSU9OQURPUiBkYSBjb2x1bmEgMiAoREFETyBQUklOQ0lQQUwpXHJcbiAgbnVtZXJvRG9jdW1lbnRvOiBzdHJpbmc7ICAgICAgICAvLyBOw5pNRVJPIERPIERPQ1VNRU5UTyBkYSBjb2x1bmEgMyAoREFETyBQUklOQ0lQQUwpXHJcbiAgdmFsb3I6IG51bWJlcjsgICAgICAgICAgICAgICAgICAvLyBWYWxvciBudW3DqXJpY28gZGEgY29sdW5hIDVcclxuICB2YWxvck9yaWdpbmFsOiBzdHJpbmc7ICAgICAgICAgIC8vIFZhbG9yIG9yaWdpbmFsIGNvbW8gc3RyaW5nXHJcbiAgY2F0ZWdvcmlhOiAnQV9QQUdBUicgfCAnQV9SRUNFQkVSJztcclxuICBmaWxpYWw6IHN0cmluZzsgICAgICAgICAgICAgICAgIC8vIE5vbWUgZGEgZmlsaWFsXHJcbiAgd2Vla1N0YXJ0OiBEYXRlOyAgICAgICAgICAgICAgICAvLyBJbsOtY2lvIGRhIHNlbWFuYVxyXG4gIHdlZWtFbmQ6IERhdGU7ICAgICAgICAgICAgICAgICAgLy8gRmltIGRhIHNlbWFuYVxyXG4gIHNvdXJjZUZpbGU6IHN0cmluZzsgICAgICAgICAgICAgLy8gTm9tZSBkbyBhcnF1aXZvIGZvbnRlXHJcbn1cclxuXHJcbi8vIEZ1bsOnw6NvIHBhcmEgZXh0cmFpciB0cmFuc2FjaW9uYWRvciBlIGRvY3VtZW50byBzZWd1aW5kbyBlc3BlY2lmaWNhw6fDo28gRVhBVEFcclxuZnVuY3Rpb24gZXh0cmFpclRyYW5zYWNpb25hZG9yRURvY3VtZW50byhjc3ZDb250ZW50OiBzdHJpbmcsIGRvY3VtZW50VHlwZTogJ0FfUEFHQVInIHwgJ0FfUkVDRUJFUicsIG5vbWVGaWxpYWw6IHN0cmluZyk6IERvY3VtZW50b0V4dHJhaWRvW10ge1xyXG4gIC8vIFBhcnNlIENTViBzZW0gaGVhZGVyc1xyXG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gUGFwYS5wYXJzZShjc3ZDb250ZW50LCB7XHJcbiAgICBoZWFkZXI6IGZhbHNlLFxyXG4gICAgc2tpcEVtcHR5TGluZXM6IHRydWUsXHJcbiAgfSk7XHJcbiAgXHJcbiAgY29uc3Qgcm93cyA9IHBhcnNlUmVzdWx0LmRhdGEgYXMgYW55W107XHJcbiAgY29uc3QgZG9jdW1lbnRvc0V4dHJhaWRvczogRG9jdW1lbnRvRXh0cmFpZG9bXSA9IFtdO1xyXG4gIFxyXG4gIC8vIFByb2Nlc3NhciBjYWRhIGxpbmhhIGRvIENTVlxyXG4gIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcclxuICAgIC8vIFZBTElEQcOHw4NPIEVTVFJVVFVSQUwgT0JSSUdBVMOTUklBXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocm93KSB8fCByb3cubGVuZ3RoIDwgNSkgY29udGludWU7XHJcbiAgICBcclxuICAgIGNvbnN0IGNhdGVnb3J5ID0gcm93WzBdPy50b1N0cmluZygpLnRyaW0oKSB8fCAnJztcclxuICAgIGxldCBkYXRlU3RyID0gJyc7XHJcbiAgICBsZXQgdHJhbnNhY2lvbmFkb3IgPSAnJztcclxuICAgIGxldCBudW1lcm9Eb2N1bWVudG8gPSAnJztcclxuICAgIGxldCB2YWx1ZVN0ciA9ICcnO1xyXG4gICAgXHJcbiAgICAvLyBMw5NHSUNBIERFIElERU5USUZJQ0HDh8ODTyBQT1IgVElQTyBERSBET0NVTUVOVE9cclxuICAgIGlmIChkb2N1bWVudFR5cGUgPT09ICdBX1BBR0FSJykge1xyXG4gICAgICAvLyBNYXRjaCBFWEFUTyAtIG7Do28gdXNhciBpbmNsdWRlcygpXHJcbiAgICAgIGlmIChjYXRlZ29yeSAhPT0gJ0NvbnRhcyBhIHBhZ2FyLSDDgCB2ZW5jZXInKSBjb250aW51ZTtcclxuICAgICAgXHJcbiAgICAgIC8vIE1BUEVBTUVOVE8gRklYTyBEQVMgQ09MVU5BUzpcclxuICAgICAgZGF0ZVN0ciA9IHJvd1sxXT8udG9TdHJpbmcoKS50cmltKCkgfHwgJyc7ICAgICAgICAgICAvLyBDT0xVTkEgMTogRGF0YSBWZW5jaW1lbnRvXHJcbiAgICAgIHRyYW5zYWNpb25hZG9yID0gcm93WzJdPy50b1N0cmluZygpLnRyaW0oKSB8fCAnJzsgICAgLy8gQ09MVU5BIDI6IFRSQU5TQUNJT05BRE9SXHJcbiAgICAgIG51bWVyb0RvY3VtZW50byA9IHJvd1szXT8udG9TdHJpbmcoKS50cmltKCkgfHwgJyc7ICAgLy8gQ09MVU5BIDM6IE7Dmk1FUk8gRE8gRE9DVU1FTlRPXHJcbiAgICAgIHZhbHVlU3RyID0gcm93WzVdPy50b1N0cmluZygpLnRyaW0oKSB8fCAnMCc7ICAgICAgICAgLy8gQ09MVU5BIDU6IFZhbG9yIChTRU1QUkUgY29sdW5hIDUpXHJcbiAgICAgIFxyXG4gICAgfSBlbHNlIGlmIChkb2N1bWVudFR5cGUgPT09ICdBX1JFQ0VCRVInKSB7XHJcbiAgICAgIC8vIE1hdGNoIEVYQVRPIC0gbsOjbyB1c2FyIGluY2x1ZGVzKClcclxuICAgICAgaWYgKGNhdGVnb3J5ICE9PSAnQ29udGFzIGEgcmVjZWJlciAtIEEgdmVuY2VyJykgY29udGludWU7XHJcbiAgICAgIFxyXG4gICAgICAvLyBNQVBFQU1FTlRPIEZJWE8gREFTIENPTFVOQVM6XHJcbiAgICAgIGRhdGVTdHIgPSByb3dbMV0/LnRvU3RyaW5nKCkudHJpbSgpIHx8ICcnOyAgICAgICAgICAgLy8gQ09MVU5BIDE6IERhdGEgVmVuY2ltZW50b1xyXG4gICAgICB0cmFuc2FjaW9uYWRvciA9IHJvd1syXT8udG9TdHJpbmcoKS50cmltKCkgfHwgJyc7ICAgIC8vIENPTFVOQSAyOiBUUkFOU0FDSU9OQURPUlxyXG4gICAgICBudW1lcm9Eb2N1bWVudG8gPSByb3dbM10/LnRvU3RyaW5nKCkudHJpbSgpIHx8ICcnOyAgIC8vIENPTFVOQSAzOiBOw5pNRVJPIERPIERPQ1VNRU5UT1xyXG4gICAgICB2YWx1ZVN0ciA9IHJvd1s1XT8udG9TdHJpbmcoKS50cmltKCkgfHwgJzAnOyAgICAgICAgIC8vIENPTFVOQSA1OiBWYWxvciAoU0VNUFJFIGNvbHVuYSA1KVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBWQUxJREHDh8OVRVMgT0JSSUdBVMOTUklBUyBET1MgREFET1MgRVhUUkHDjURPU1xyXG4gICAgaWYgKCFkYXRlU3RyIHx8ICF0cmFuc2FjaW9uYWRvciB8fCAhdmFsdWVTdHIpIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICAvLyBQQVJTSU5HIERBIERBVEEgREUgVkVOQ0lNRU5UT1xyXG4gICAgY29uc3QgZGF0ZSA9IHBhcnNlQ1NWRGF0ZShkYXRlU3RyKTtcclxuICAgIGlmICghZGF0ZSB8fCBpc05hTihkYXRlLmdldFRpbWUoKSkpIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICAvLyBQQVJTSU5HIERPIFZBTE9SIE1PTkVUw4FSSU8gKGZvcm1hdG8gYnJhc2lsZWlybylcclxuICAgIGxldCBjbGVhblZhbHVlID0gdmFsdWVTdHIucmVwbGFjZSgvW1IkXFxzXS9nLCAnJykucmVwbGFjZSgvXFwuL2csICcnKS5yZXBsYWNlKCcsJywgJy4nKTtcclxuICAgIGNvbnN0IGlzTmVnYXRpdmUgPSBjbGVhblZhbHVlLnN0YXJ0c1dpdGgoJy0nKTtcclxuICAgIGlmIChpc05lZ2F0aXZlKSB7XHJcbiAgICAgIGNsZWFuVmFsdWUgPSBjbGVhblZhbHVlLnN1YnN0cmluZygxKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VGbG9hdChjbGVhblZhbHVlKTtcclxuICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPD0gMCkgY29udGludWU7XHJcbiAgICBcclxuICAgIC8vIEFQTElDQcOHw4NPIERFIEZBTExCQUNLUyBQQVJBIENBTVBPUyBPQlJJR0FUw5NSSU9TXHJcbiAgICBjb25zdCB0cmFuc2FjaW9uYWRvckZpbmFsID0gdHJhbnNhY2lvbmFkb3IgfHwgJ0ZPUk5FQ0VET1IgTsODTyBJREVOVElGSUNBRE8nO1xyXG4gICAgY29uc3QgbnVtZXJvRG9jdW1lbnRvRmluYWwgPSBudW1lcm9Eb2N1bWVudG8gfHwgJyc7IC8vIFJlbW92aWRvIGZhbGxiYWNrICdQRU5ERU5URSdcclxuICAgIFxyXG4gICAgLy8gRVNUUlVUVVJBIEZJTkFMIERPUyBEQURPUyBFWFRSQcONRE9TXHJcbiAgICBjb25zdCB7IHdlZWtTdGFydCwgd2Vla0VuZCB9ID0gZ2V0V2Vla0JvdW5kYXJpZXMoZGF0ZSk7XHJcbiAgICBkb2N1bWVudG9zRXh0cmFpZG9zLnB1c2goe1xyXG4gICAgICBkYXRhVmVuY2ltZW50bzogZGF0ZSxcclxuICAgICAgdHJhbnNhY2lvbmFkb3I6IHRyYW5zYWNpb25hZG9yRmluYWwsICAgICAgLy8gREFETyBQUklOQ0lQQUwgRVhUUkHDjURPXHJcbiAgICAgIG51bWVyb0RvY3VtZW50bzogbnVtZXJvRG9jdW1lbnRvRmluYWwsICAgIC8vIERBRE8gUFJJTkNJUEFMIEVYVFJBw41ET1xyXG4gICAgICB2YWxvcjogdmFsdWUsXHJcbiAgICAgIHZhbG9yT3JpZ2luYWw6IHZhbHVlU3RyLFxyXG4gICAgICBjYXRlZ29yaWE6IGRvY3VtZW50VHlwZSxcclxuICAgICAgZmlsaWFsOiBub21lRmlsaWFsLFxyXG4gICAgICAvLyBEYWRvcyBkZSBjb21wYXRpYmlsaWRhZGVcclxuICAgICAgd2Vla1N0YXJ0OiB3ZWVrU3RhcnQsXHJcbiAgICAgIHdlZWtFbmQ6IHdlZWtFbmQsXHJcbiAgICAgIHNvdXJjZUZpbGU6IGAke25vbWVGaWxpYWx9LmNzdmBcclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gZG9jdW1lbnRvc0V4dHJhaWRvcztcclxufVxyXG5cclxuLy8gQ29uZmlndXJhw6fDo28gcGFyYSBkZXNhYmlsaXRhciBvIHBhcnNlciBwYWRyw6NvIGRvIE5leHQuanNcclxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHtcclxuICBhcGk6IHtcclxuICAgIGJvZHlQYXJzZXI6IGZhbHNlLFxyXG4gIH0sXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIoXHJcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcclxuICByZXM6IE5leHRBcGlSZXNwb25zZVxyXG4pIHtcclxuICBpZiAocmVxLm1ldGhvZCAhPT0gJ1BPU1QnKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmpzb24oeyBtZXNzYWdlOiAnTWV0aG9kIG5vdCBhbGxvd2VkJyB9KVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIE9wY2lvbmFsOiBsaW1wYXIgZGFkb3MgYW50ZXJpb3JlcyBzZSBzb2xpY2l0YWRvXHJcbiAgICBpZiAocmVxLnF1ZXJ5LmNsZWFyRGF0YSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgIHN0b3JhZ2UuZGVsZXRlKCdzdW1tYXJ5RGF0YScpO1xyXG4gICAgICBzdG9yYWdlLmRlbGV0ZSgncHJvY2Vzc2VkRGF0YScpO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coJz09PSBERUJVRyBVUExPQUQgQ1NWID09PScpO1xyXG4gICAgY29uc29sZS5sb2coJ01ldGhvZDonLCByZXEubWV0aG9kKTtcclxuICAgIGNvbnNvbGUubG9nKCdDb250ZW50LVR5cGU6JywgcmVxLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKTtcclxuICAgIGNvbnNvbGUubG9nKCdIZWFkZXJzOicsIEpTT04uc3RyaW5naWZ5KHJlcS5oZWFkZXJzLCBudWxsLCAyKSk7XHJcbiAgICBcclxuICAgIC8vIEdhcmFudGlyIHF1ZSBhIHBhc3RhIHRlbXAgZXhpc3RlXHJcbiAgICBjb25zdCB0ZW1wRGlyID0gJy4vdGVtcCc7XHJcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmModGVtcERpcikpIHtcclxuICAgICAgZnMubWtkaXJTeW5jKHRlbXBEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDb25maWd1cmFyIGZvcm1pZGFibGUgcGFyYSB1cGxvYWQgZGUgbcO6bHRpcGxvcyBhcnF1aXZvc1xyXG4gICAgY29uc3QgZm9ybSA9IGZvcm1pZGFibGUoe1xyXG4gICAgICB1cGxvYWREaXI6IHRlbXBEaXIsXHJcbiAgICAgIGtlZXBFeHRlbnNpb25zOiB0cnVlLFxyXG4gICAgICBtYXhGaWxlczogMTAsXHJcbiAgICAgIG1heEZpbGVTaXplOiAxMCAqIDEwMjQgKiAxMDI0LCAvLyAxME1CXHJcbiAgICAgIC8vIFJlbW92ZXIgZmlsdGVyIHBhcmEgYWNlaXRhciB0b2RvcyBvcyBhcnF1aXZvcyBwb3IgZW5xdWFudG9cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IFtmaWVsZHMsIGZpbGVzXSA9IGF3YWl0IGZvcm0ucGFyc2UocmVxKTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJz09PSBQQVJTRUQgREFUQSA9PT0nKTtcclxuICAgIGNvbnNvbGUubG9nKCdGaWVsZHM6JywgSlNPTi5zdHJpbmdpZnkoZmllbGRzLCBudWxsLCAyKSk7XHJcbiAgICBjb25zb2xlLmxvZygnRmlsZXMga2V5czonLCBPYmplY3Qua2V5cyhmaWxlcykpO1xyXG4gICAgY29uc29sZS5sb2coJ0ZpbGVzIHN0cnVjdHVyZTonLCBKU09OLnN0cmluZ2lmeShmaWxlcywgbnVsbCwgMikpO1xyXG4gICAgXHJcbiAgICAvLyBPYnRlciB0aXBvcyBkZSBkb2N1bWVudG8gc2VsZWNpb25hZG9zXHJcbiAgICBsZXQgc2VsZWN0ZWRUeXBlczogKCdBX1BBR0FSJyB8ICdBX1JFQ0VCRVInKVtdID0gWydBX1BBR0FSJywgJ0FfUkVDRUJFUiddOyAvLyBEZWZhdWx0XHJcbiAgICBcclxuICAgIGlmIChmaWVsZHMuZG9jdW1lbnRUeXBlcyAmJiBmaWVsZHMuZG9jdW1lbnRUeXBlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGRvY3VtZW50VHlwZXNTdHJpbmcgPSBmaWVsZHMuZG9jdW1lbnRUeXBlc1swXSBhcyBzdHJpbmc7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdkb2N1bWVudFR5cGVzU3RyaW5nIHJlY2ViaWRvOicsIGRvY3VtZW50VHlwZXNTdHJpbmcpO1xyXG4gICAgICBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBUZW50YXIgZmF6ZXIgcGFyc2Ugc2UgZm9yIEpTT05cclxuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRvY3VtZW50VHlwZXNTdHJpbmcpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdKU09OIHBhcnNlZDonLCBwYXJzZWQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcclxuICAgICAgICAgIHNlbGVjdGVkVHlwZXMgPSBwYXJzZWQ7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyc2VkID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgLy8gU2UgZm9yIHVtIG9iamV0byBjb20gaW5kaWNlcywgZXh0cmFpciBvcyB2YWxvcmVzIGUgZmxhdHRlblxyXG4gICAgICAgICAgY29uc3QgYWxsVHlwZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgICBPYmplY3QudmFsdWVzKHBhcnNlZCkuZm9yRWFjaCh0eXBlQXJyYXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgYWxsVHlwZXMucHVzaCguLi50eXBlQXJyYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIC8vIFJlbW92ZXIgZHVwbGljYXRhc1xyXG4gICAgICAgICAgY29uc3QgdW5pcXVlVHlwZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoYWxsVHlwZXMpKTtcclxuICAgICAgICAgIHNlbGVjdGVkVHlwZXMgPSB1bmlxdWVUeXBlcyBhcyAoJ0FfUEFHQVInIHwgJ0FfUkVDRUJFUicpW107XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0Vycm8gbm8gcGFyc2UgSlNPTjonLCBlKTtcclxuICAgICAgICAvLyBTZSBuw6NvIGZvciBKU09OLCB1c2FyIGNvbW8gYXJyYXkgZGlyZXRvXHJcbiAgICAgICAgc2VsZWN0ZWRUeXBlcyA9IEFycmF5LmlzQXJyYXkoZmllbGRzLmRvY3VtZW50VHlwZXMpIFxyXG4gICAgICAgICAgPyBmaWVsZHMuZG9jdW1lbnRUeXBlcyBhcyAoJ0FfUEFHQVInIHwgJ0FfUkVDRUJFUicpW11cclxuICAgICAgICAgIDogW2RvY3VtZW50VHlwZXNTdHJpbmcgYXMgJ0FfUEFHQVInIHwgJ0FfUkVDRUJFUiddO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdTZWxlY3RlZCB0eXBlcyBwcm9jZXNzYWRvczonLCBzZWxlY3RlZFR5cGVzKTtcclxuICAgIFxyXG4gICAgLy8gTk9STUFMSVpBw4fDg08gUk9CVVNUQSBERSBBUlFVSVZPUyAobXVsdGktZmllbGQsIG11bHRpLWZpbGUpXHJcbiAgICBjb25zdCBhbGxGaWxlcyA9IE9iamVjdC52YWx1ZXMoZmlsZXMpLmZsYXQoKS5maWx0ZXIoQm9vbGVhbikgYXMgZm9ybWlkYWJsZS5GaWxlW107XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCc9PT0gRklMRSBQUk9DRVNTSU5HID09PScpO1xyXG4gICAgY29uc29sZS5sb2coJ2FsbEZpbGVzIChub3JtYWxpemFkbyk6JywgYWxsRmlsZXMubWFwKGYgPT4gKHsgb3JpZ2luYWxGaWxlbmFtZTogZi5vcmlnaW5hbEZpbGVuYW1lLCBwYXRoOiBmLmZpbGVwYXRoIH0pKSk7XHJcbiAgICBjb25zb2xlLmxvZygnYWxsRmlsZXMgbGVuZ3RoOicsIGFsbEZpbGVzLmxlbmd0aCk7XHJcbiAgICBcclxuICAgIC8vIEZpbHRyYXIgYXBlbmFzIGFycXVpdm9zIENTViAtIHNlbmRvIG1haXMgcGVybWlzc2l2byBwYXJhIGRlYnVnXHJcbiAgICBjb25zdCBjc3ZGaWxlcyA9IGFsbEZpbGVzLmZpbHRlcihmaWxlID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGZpbGU6JywgZmlsZSA/IHtcclxuICAgICAgICBvcmlnaW5hbEZpbGVuYW1lOiBmaWxlLm9yaWdpbmFsRmlsZW5hbWUsXHJcbiAgICAgICAgbWltZXR5cGU6IGZpbGUubWltZXR5cGUsXHJcbiAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxyXG4gICAgICAgIGZpbGVwYXRoOiBmaWxlLmZpbGVwYXRoXHJcbiAgICAgIH0gOiAnbnVsbCBmaWxlJyk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWZpbGUgfHwgIWZpbGUub3JpZ2luYWxGaWxlbmFtZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAvLyBBY2VpdGFyIC5jc3Ygb3UgLnR4dCAoYWxndW5zIHNpc3RlbWFzIGV4cG9ydGFtIGFzc2ltKSwgY2FzZSBpbnNlbnNpdGl2ZVxyXG4gICAgICByZXR1cm4gL1xcLihjc3Z8dHh0KSQvaS50ZXN0KGZpbGUub3JpZ2luYWxGaWxlbmFtZSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJz09PSBGSUxURVJJTkcgUkVTVUxUUyA9PT0nKTtcclxuICAgIGNvbnNvbGUubG9nKCdDU1YgRmlsZXMgZm91bmQ6JywgY3N2RmlsZXMubGVuZ3RoKTtcclxuICAgIGNvbnNvbGUubG9nKCdTZWxlY3RlZCB0eXBlczonLCBzZWxlY3RlZFR5cGVzKTtcclxuICAgIGNvbnNvbGUubG9nKCdDU1YgRmlsZXMgZGV0YWlsczonLCBjc3ZGaWxlcy5tYXAoZiA9PiBmID8ge1xyXG4gICAgICBuYW1lOiBmLm9yaWdpbmFsRmlsZW5hbWUsXHJcbiAgICAgIHR5cGU6IGYubWltZXR5cGUsXHJcbiAgICAgIHNpemU6IGYuc2l6ZVxyXG4gICAgfSA6IG51bGwpKTtcclxuICAgIFxyXG4gICAgaWYgKGNzdkZpbGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnPT09IEVSUk9SOiBOTyBGSUxFUyA9PT0nKTtcclxuICAgICAgY29uc29sZS5sb2coJ05vIENTViBmaWxlcyBmb3VuZCBhZnRlciBmaWx0ZXJpbmcnKTtcclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBtZXNzYWdlOiBgTmVuaHVtIGFycXVpdm8gZm9pIGVuY29udHJhZG8uIEFycXVpdm9zIHJlY2ViaWRvczogJHthbGxGaWxlcy5sZW5ndGh9LiBWZXJpZmlxdWUgc2UgbyBhcnF1aXZvIMOpIHVtIENTViB2w6FsaWRvLmBcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWxsVHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvbkRhdGFbXSA9IFtdO1xyXG4gICAgY29uc3QgYWxsRmlsZXNEYXRhOiBhbnlbXSA9IFtdO1xyXG4gICAgXHJcbiAgICAvLyBQcm9jZXNzYXIgY2FkYSBhcnF1aXZvIENTVlxyXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGNzdkZpbGVzKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGA9PT0gUFJPQ0VTU0lORyBGSUxFOiAke2ZpbGU/Lm9yaWdpbmFsRmlsZW5hbWV9ID09PWApO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFmaWxlIHx8ICFmaWxlLmZpbGVwYXRoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1NraXBwaW5nIGludmFsaWQgZmlsZTonLCBmaWxlKTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ0ZpbGUgcGF0aDonLCBmaWxlLmZpbGVwYXRoKTtcclxuICAgICAgY29uc29sZS5sb2coJ0ZpbGUgZXhpc3RzOicsIGZzLmV4aXN0c1N5bmMoZmlsZS5maWxlcGF0aCkpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgYnVmZmVyID0gZnMucmVhZEZpbGVTeW5jKGZpbGUuZmlsZXBhdGgpO1xyXG4gICAgICBjb25zdCBlbmNvZGluZyA9IGRldGVjdEVuY29kaW5nKGJ1ZmZlcik7XHJcbiAgICAgIGNvbnN0IGNzdkNvbnRlbnQgPSBidWZmZXIudG9TdHJpbmcoZW5jb2RpbmcgYXMgQnVmZmVyRW5jb2RpbmcpO1xyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFpciBub21lIGRhIGZpbGlhbFxyXG4gICAgICBjb25zdCBicmFuY2hOYW1lID0gKGZpbGUub3JpZ2luYWxGaWxlbmFtZSB8fCAnRklMSUFMX0RFU0NPTkhFQ0lEQScpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcLihjc3Z8dHh0KSQvaSwgJycpXHJcbiAgICAgICAgLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBmaWxlVHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvbkRhdGFbXSA9IFtdO1xyXG4gICAgICBcclxuICAgICAgLy8gUHJvY2Vzc2FyIGNhZGEgdGlwbyBkZSBkb2N1bWVudG8gc2VsZWNpb25hZG8gdXNhbmRvIGEgbm92YSBsw7NnaWNhXHJcbiAgICAgIGZvciAoY29uc3QgZG9jdW1lbnRUeXBlIG9mIHNlbGVjdGVkVHlwZXMgYXMgKCdBX1BBR0FSJyB8ICdBX1JFQ0VCRVInKVtdKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc3NhbmRvIHRpcG8gZGUgZG9jdW1lbnRvOiAke2RvY3VtZW50VHlwZX0gcGFyYSBhcnF1aXZvOiAke2ZpbGUub3JpZ2luYWxGaWxlbmFtZX1gKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBVc2FyIGEgZnVuw6fDo28gZGUgZXh0cmHDp8OjbyBlc3BlY8OtZmljYSBjb20gYSBsw7NnaWNhIGNvcnJldGFcclxuICAgICAgICBjb25zdCBkb2N1bWVudG9zRXh0cmFpZG9zID0gZXh0cmFpclRyYW5zYWNpb25hZG9yRURvY3VtZW50byhjc3ZDb250ZW50LCBkb2N1bWVudFR5cGUsIGJyYW5jaE5hbWUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBEb2N1bWVudG9zIGV4dHJhw61kb3MgcGFyYSAke2RvY3VtZW50VHlwZX06YCwgZG9jdW1lbnRvc0V4dHJhaWRvcy5sZW5ndGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIExvZyBkb3MgcHJpbWVpcm9zIGRvY3VtZW50b3MgcGFyYSBkZWJ1Z1xyXG4gICAgICAgIGlmIChkb2N1bWVudG9zRXh0cmFpZG9zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdQcmltZWlyb3MgZG9jdW1lbnRvcyBleHRyYcOtZG9zOicsIGRvY3VtZW50b3NFeHRyYWlkb3Muc2xpY2UoMCwgMykubWFwKGRvYyA9PiAoe1xyXG4gICAgICAgICAgICB0cmFuc2FjaW9uYWRvcjogZG9jLnRyYW5zYWNpb25hZG9yLFxyXG4gICAgICAgICAgICBudW1lcm9Eb2N1bWVudG86IGRvYy5udW1lcm9Eb2N1bWVudG8sXHJcbiAgICAgICAgICAgIHZhbG9yOiBkb2MudmFsb3IsXHJcbiAgICAgICAgICAgIGRhdGFWZW5jaW1lbnRvOiBkb2MuZGF0YVZlbmNpbWVudG8udG9Mb2NhbGVEYXRlU3RyaW5nKCdwdC1CUicpXHJcbiAgICAgICAgICB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDb252ZXJ0ZXIgcGFyYSBvIGZvcm1hdG8gVHJhbnNhY3Rpb25EYXRhIChtYW50ZXIgY29tcGF0aWJpbGlkYWRlKVxyXG4gICAgICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3VtZW50b3NFeHRyYWlkb3MpIHtcclxuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbkRhdGEgPSB7XHJcbiAgICAgICAgICAgIGRhdGU6IGRvYy5kYXRhVmVuY2ltZW50byxcclxuICAgICAgICAgICAgc3VwcGxpZXI6IGRvYy50cmFuc2FjaW9uYWRvciwgICAgICAgIC8vIFRSQU5TQUNJT05BRE9SIENPUlJFVE8gZGEgY29sdW5hIDJcclxuICAgICAgICAgICAgZG9jTnVtYmVyOiBkb2MubnVtZXJvRG9jdW1lbnRvLCAgICAgIC8vIE7Dmk1FUk8gRE8gRE9DVU1FTlRPIENPUlJFVE8gZGEgY29sdW5hIDNcclxuICAgICAgICAgICAgdmFsdWU6IGRvYy52YWxvcixcclxuICAgICAgICAgICAgY2F0ZWdvcnk6IGRvY3VtZW50VHlwZSA9PT0gJ0FfUEFHQVInID8gJ0NvbnRhcyBhIHBhZ2FyLSDDgCB2ZW5jZXInIDogJ0NvbnRhcyBhIHJlY2ViZXIgLSBBIHZlbmNlcicsXHJcbiAgICAgICAgICAgIGJyYW5jaDogZG9jLmZpbGlhbCxcclxuICAgICAgICAgICAgZG9jdW1lbnRUeXBlOiBkb2MuY2F0ZWdvcmlhLFxyXG4gICAgICAgICAgICBzb3VyY2VGaWxlOiBmaWxlLm9yaWdpbmFsRmlsZW5hbWUgfHwgYCR7YnJhbmNoTmFtZX0uY3N2YFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZmlsZVRyYW5zYWN0aW9ucy5wdXNoKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgIGFsbFRyYW5zYWN0aW9ucy5wdXNoKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGFsbEZpbGVzRGF0YS5wdXNoKHtcclxuICAgICAgICBmaWxlbmFtZTogZmlsZS5vcmlnaW5hbEZpbGVuYW1lLFxyXG4gICAgICAgIGJyYW5jaDogYnJhbmNoTmFtZSxcclxuICAgICAgICB0cmFuc2FjdGlvbnM6IGZpbGVUcmFuc2FjdGlvbnMsXHJcbiAgICAgICAgdG90YWxUcmFuc2FjdGlvbnM6IGZpbGVUcmFuc2FjdGlvbnMubGVuZ3RoXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgLy8gTGltcGFyIGFycXVpdm8gdGVtcG9yw6FyaW9cclxuICAgICAgaWYgKGZpbGUuZmlsZXBhdGggJiYgZnMuZXhpc3RzU3luYyhmaWxlLmZpbGVwYXRoKSkge1xyXG4gICAgICAgIGZzLnVubGlua1N5bmMoZmlsZS5maWxlcGF0aCk7XHJcbiAgICAgIH1cclxuICAgICAgfSBjYXRjaChwcm9jZXNzRmlsZUVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gcHJvY2Vzc2FyIGFycXVpdm8gaW5kaXZpZHVhbCwgY29udGludWFuZG8gY29tIG9zIGRlbWFpczonLCBmaWxlPy5vcmlnaW5hbEZpbGVuYW1lLCBwcm9jZXNzRmlsZUVycik7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQWdyZWdhw6fDo28gZGUgZGFkb3NcclxuICAgIGNvbnN0IGJyYW5jaFRvdGFsc01hcCA9IG5ldyBNYXA8c3RyaW5nLCB7XHJcbiAgICAgIGludm9pY2VDb3VudDogbnVtYmVyO1xyXG4gICAgICB0b3RhbFZhbHVlOiBudW1iZXI7XHJcbiAgICAgIHdlZWtTdGFydDogRGF0ZTtcclxuICAgICAgd2Vla0VuZDogRGF0ZTtcclxuICAgIH0+KCk7XHJcbiAgICBcclxuICAgIGNvbnN0IGRhaWx5VG90YWxzTWFwID0gbmV3IE1hcDxzdHJpbmcsIHtcclxuICAgICAgZGF0ZTogRGF0ZTtcclxuICAgICAgZGF5T2ZXZWVrOiBzdHJpbmc7XHJcbiAgICAgIHRvdGFsVmFsdWU6IG51bWJlcjtcclxuICAgICAgaW52b2ljZUNvdW50OiBudW1iZXI7XHJcbiAgICAgIGJyYW5jaDogc3RyaW5nO1xyXG4gICAgfT4oKTtcclxuICAgIFxyXG4gICAgbGV0IHRvdGFsUGF5YWJsZSA9IDA7XHJcbiAgICBsZXQgdG90YWxSZWNlaXZhYmxlID0gMDtcclxuICAgIGxldCBncmFuZFRvdGFsVmFsdWUgPSAwO1xyXG4gICAgXHJcbiAgICAvLyBQcm9jZXNzYXIgdHJhbnNhw6fDtWVzIHBhcmEgYWdyZWdhw6fDo29cclxuICAgIGFsbFRyYW5zYWN0aW9ucy5mb3JFYWNoKHRyYW5zYWN0aW9uID0+IHtcclxuICAgICAgY29uc3QgeyBicmFuY2gsIGRhdGUsIHZhbHVlLCBkb2N1bWVudFR5cGUgfSA9IHRyYW5zYWN0aW9uO1xyXG4gICAgICBcclxuICAgICAgLy8gQXR1YWxpemFyIHRvdGFpcyBwb3IgZmlsaWFsXHJcbiAgICAgIGNvbnN0IHsgd2Vla1N0YXJ0LCB3ZWVrRW5kIH0gPSBnZXRXZWVrQm91bmRhcmllcyhkYXRlKTtcclxuICAgICAgY29uc3QgYnJhbmNoS2V5ID0gYnJhbmNoO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFicmFuY2hUb3RhbHNNYXAuaGFzKGJyYW5jaEtleSkpIHtcclxuICAgICAgICBicmFuY2hUb3RhbHNNYXAuc2V0KGJyYW5jaEtleSwge1xyXG4gICAgICAgICAgaW52b2ljZUNvdW50OiAwLFxyXG4gICAgICAgICAgdG90YWxWYWx1ZTogMCxcclxuICAgICAgICAgIHdlZWtTdGFydCxcclxuICAgICAgICAgIHdlZWtFbmRcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgYnJhbmNoVG90YWwgPSBicmFuY2hUb3RhbHNNYXAuZ2V0KGJyYW5jaEtleSkhO1xyXG4gICAgICBicmFuY2hUb3RhbC5pbnZvaWNlQ291bnQrKztcclxuICAgICAgYnJhbmNoVG90YWwudG90YWxWYWx1ZSArPSB2YWx1ZTtcclxuICAgICAgXHJcbiAgICAgIC8vIEF0dWFsaXphciB0b3RhaXMgZGnDoXJpb3NcclxuICAgICAgY29uc3QgZGF0ZUtleSA9IGAke2JyYW5jaH0tJHtkYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXX1gO1xyXG4gICAgICBjb25zdCBkYXlPZldlZWsgPSBbJ0RvbWluZ28nLCAnU2VndW5kYScsICdUZXLDp2EnLCAnUXVhcnRhJywgJ1F1aW50YScsICdTZXh0YScsICdTw6FiYWRvJ11bZGF0ZS5nZXREYXkoKV07XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWRhaWx5VG90YWxzTWFwLmhhcyhkYXRlS2V5KSkge1xyXG4gICAgICAgIGRhaWx5VG90YWxzTWFwLnNldChkYXRlS2V5LCB7XHJcbiAgICAgICAgICBkYXRlLFxyXG4gICAgICAgICAgZGF5T2ZXZWVrLFxyXG4gICAgICAgICAgdG90YWxWYWx1ZTogMCxcclxuICAgICAgICAgIGludm9pY2VDb3VudDogMCxcclxuICAgICAgICAgIGJyYW5jaFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBkYWlseVRvdGFsID0gZGFpbHlUb3RhbHNNYXAuZ2V0KGRhdGVLZXkpITtcclxuICAgICAgZGFpbHlUb3RhbC50b3RhbFZhbHVlICs9IHZhbHVlO1xyXG4gICAgICBkYWlseVRvdGFsLmludm9pY2VDb3VudCsrO1xyXG4gICAgICBcclxuICAgICAgLy8gQXR1YWxpemFyIHRvdGFpcyBwb3IgdGlwb1xyXG4gICAgICBpZiAoZG9jdW1lbnRUeXBlID09PSAnQV9QQUdBUicpIHtcclxuICAgICAgICB0b3RhbFBheWFibGUgKz0gdmFsdWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRUeXBlID09PSAnQV9SRUNFQkVSJykge1xyXG4gICAgICAgIHRvdGFsUmVjZWl2YWJsZSArPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgZ3JhbmRUb3RhbFZhbHVlICs9IHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIENvbnZlcnRlciBNYXBzIHBhcmEgYXJyYXlzXHJcbiAgICBjb25zdCBicmFuY2hUb3RhbHMgPSBBcnJheS5mcm9tKGJyYW5jaFRvdGFsc01hcC5lbnRyaWVzKCkpLm1hcCgoW2JyYW5jaCwgZGF0YV0pID0+ICh7XHJcbiAgICAgIGJyYW5jaCxcclxuICAgICAgaW52b2ljZUNvdW50OiBkYXRhLmludm9pY2VDb3VudCxcclxuICAgICAgdG90YWxWYWx1ZTogYFIkICR7ZGF0YS50b3RhbFZhbHVlLnRvTG9jYWxlU3RyaW5nKCdwdC1CUicsIHsgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyIH0pfWAsXHJcbiAgICAgIHdlZWtTdGFydDogZGF0YS53ZWVrU3RhcnQsXHJcbiAgICAgIHdlZWtFbmQ6IGRhdGEud2Vla0VuZFxyXG4gICAgfSkpO1xyXG4gICAgXHJcbiAgICBjb25zdCBkYWlseVRvdGFscyA9IEFycmF5LmZyb20oZGFpbHlUb3RhbHNNYXAudmFsdWVzKCkpLm1hcChkYXRhID0+ICh7XHJcbiAgICAgIC4uLmRhdGEsXHJcbiAgICAgIHRvdGFsVmFsdWU6IGBSJCAke2RhdGEudG90YWxWYWx1ZS50b0xvY2FsZVN0cmluZygncHQtQlInLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gXHJcbiAgICB9KSk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGFyIHRvdGFpcyBzZW1hbmFpc1xyXG4gICAgY29uc3Qgd29ya2luZ0RheXNUb3RhbCA9IGRhaWx5VG90YWxzXHJcbiAgICAgIC5maWx0ZXIoZCA9PiAhWzAsIDZdLmluY2x1ZGVzKGQuZGF0ZS5nZXREYXkoKSkpIC8vIE7Do28gZG9taW5nby9zw6FiYWRvXHJcbiAgICAgIC5yZWR1Y2UoKHN1bSwgZCkgPT4gc3VtICsgcGFyc2VNb25ldGFyeVZhbHVlKGQudG90YWxWYWx1ZSksIDApO1xyXG4gICAgICBcclxuICAgIGNvbnN0IHdlZWtlbmRUb3RhbCA9IGRhaWx5VG90YWxzXHJcbiAgICAgIC5maWx0ZXIoZCA9PiBbMCwgNl0uaW5jbHVkZXMoZC5kYXRlLmdldERheSgpKSkgLy8gRG9taW5nby9zw6FiYWRvXHJcbiAgICAgIC5yZWR1Y2UoKHN1bSwgZCkgPT4gc3VtICsgcGFyc2VNb25ldGFyeVZhbHVlKGQudG90YWxWYWx1ZSksIDApO1xyXG4gICAgXHJcbiAgICBjb25zdCB3b3JraW5nRGF5cyA9IGRhaWx5VG90YWxzLmZpbHRlcihkID0+ICFbMCwgNl0uaW5jbHVkZXMoZC5kYXRlLmdldERheSgpKSkubGVuZ3RoO1xyXG4gICAgY29uc3Qgd2Vla2VuZERheXMgPSBkYWlseVRvdGFscy5maWx0ZXIoZCA9PiBbMCwgNl0uaW5jbHVkZXMoZC5kYXRlLmdldERheSgpKSkubGVuZ3RoO1xyXG4gICAgXHJcbiAgICBjb25zdCBtaW5EYXRlID0gYWxsVHJhbnNhY3Rpb25zLmxlbmd0aCA+IDAgXHJcbiAgICAgID8gbmV3IERhdGUoTWF0aC5taW4oLi4uYWxsVHJhbnNhY3Rpb25zLm1hcCh0ID0+IHQuZGF0ZS5nZXRUaW1lKCkpKSlcclxuICAgICAgOiBuZXcgRGF0ZSgpO1xyXG4gICAgY29uc3QgbWF4RGF0ZSA9IGFsbFRyYW5zYWN0aW9ucy5sZW5ndGggPiAwIFxyXG4gICAgICA/IG5ldyBEYXRlKE1hdGgubWF4KC4uLmFsbFRyYW5zYWN0aW9ucy5tYXAodCA9PiB0LmRhdGUuZ2V0VGltZSgpKSkpXHJcbiAgICAgIDogbmV3IERhdGUoKTtcclxuICAgIFxyXG4gICAgY29uc3QgcHJvY2Vzc2VkRGF0YTogUHJvY2Vzc2VkRGF0YSA9IHtcclxuICAgICAgYnJhbmNoVG90YWxzLFxyXG4gICAgICBkYWlseVRvdGFscyxcclxuICAgICAgd2Vla2x5VG90YWxzOiB7XHJcbiAgICAgICAgd29ya2luZ0RheXNUb3RhbDogYFIkICR7d29ya2luZ0RheXNUb3RhbC50b0xvY2FsZVN0cmluZygncHQtQlInLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gLFxyXG4gICAgICAgIHdlZWtlbmRUb3RhbDogYFIkICR7d2Vla2VuZFRvdGFsLnRvTG9jYWxlU3RyaW5nKCdwdC1CUicsIHsgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyIH0pfWAsXHJcbiAgICAgICAgd2Vla1RvdGFsOiBgUiQgJHtncmFuZFRvdGFsVmFsdWUudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSl9YCxcclxuICAgICAgICB3b3JraW5nRGF5cyxcclxuICAgICAgICB3ZWVrZW5kRGF5cyxcclxuICAgICAgICB3ZWVrUGVyaW9kOiBgJHttaW5EYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygncHQtQlInKX0gLSAke21heERhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdwdC1CUicpfWAsXHJcbiAgICAgICAgdG90YWxQYXlhYmxlLFxyXG4gICAgICAgIHRvdGFsUmVjZWl2YWJsZVxyXG4gICAgICB9LFxyXG4gICAgICBncmFuZFRvdGFsOiBgUiQgJHtncmFuZFRvdGFsVmFsdWUudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSl9YCxcclxuICAgICAgdG90YWxJbnZvaWNlczogYWxsVHJhbnNhY3Rpb25zLmxlbmd0aCxcclxuICAgICAgdHJhbnNhY3Rpb25zOiBhbGxUcmFuc2FjdGlvbnMubWFwKHRyYW5zYWN0aW9uID0+ICh7XHJcbiAgICAgICAgdmVuY2ltZW50bzogdHJhbnNhY3Rpb24uZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ3B0LUJSJyksXHJcbiAgICAgICAgdHJhbnNhY2lvbmFkb3I6IHRyYW5zYWN0aW9uLnN1cHBsaWVyLCAgLy8gVVNBTkRPIHN1cHBsaWVyIENPUlJFVE9cclxuICAgICAgICBkb2N1bWVudG86IHRyYW5zYWN0aW9uLmRvY051bWJlciwgICAgICAvLyBVU0FORE8gZG9jTnVtYmVyIENPUlJFVE8gIFxyXG4gICAgICAgIHZhbG9yOiBgUiQgJHt0cmFuc2FjdGlvbi52YWx1ZS50b0xvY2FsZVN0cmluZygncHQtQlInLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gLFxyXG4gICAgICAgIHZhbG9yTnVtZXJpY286IHRyYW5zYWN0aW9uLnZhbHVlLFxyXG4gICAgICAgIGRvY3VtZW50VHlwZTogdHJhbnNhY3Rpb24uZG9jdW1lbnRUeXBlLCAvLyBwcmVzZXJ2YSB0aXBvIHJlYWwgKEFfUEFHQVIgLyBBX1JFQ0VCRVIpXHJcbiAgICAgICAgZmlsaWFsOiB0cmFuc2FjdGlvbi5icmFuY2gsICAgICAgICAgICAgIC8vIHByZXNlcnZhIGZpbGlhbFxyXG4gICAgICAgIHNvdXJjZUZpbGU6IHRyYW5zYWN0aW9uLnNvdXJjZUZpbGUgICAgICAvLyBub21lIG9yaWdpbmFsIGRvIGFycXVpdm9cclxuICAgICAgfSkpXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENhY2hlIGRvcyBkYWRvcyBwcm9jZXNzYWRvcyBwYXJhIGV4cG9ydGHDp8OjbyBwb3N0ZXJpb3Igc2VtIHByZWNpc2FyIHJlZW52aWFyIHBlbG8gZnJvbnRlbmRcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNhY2hlUGF0aCA9IHBhdGguam9pbih0ZW1wRGlyLCAnbGFzdF9wcm9jZXNzZWQuanNvbicpO1xyXG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGNhY2hlUGF0aCwgSlNPTi5zdHJpbmdpZnkocHJvY2Vzc2VkRGF0YSwgbnVsbCwgMiksICd1dGY4Jyk7XHJcbiAgICB9IGNhdGNoIChjYWNoZUVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ07Do28gZm9pIHBvc3PDrXZlbCBzYWx2YXIgY2FjaGUgZGUgcHJvY2Vzc2VkRGF0YTonLCBjYWNoZUVycik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT0gSU7DjUNJTzogR0VSQcOHw4NPIERFIHN1bW1hcnlEYXRhIFBBUkEgL2FwaS9leHBvcnQtc3VtbWFyeS1leGNlbCA9PT09PVxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR3VhcmRhciBwcm9jZXNzZWREYXRhIGVtIG1lbcOzcmlhIHRhbWLDqW1cclxuICAgICAgc3RvcmFnZS5zZXQoJ3Byb2Nlc3NlZERhdGEnLCBwcm9jZXNzZWREYXRhKTtcclxuXHJcbiAgICAgIC8vIE1hcGVhciB0cmFuc2HDp8O1ZXMgZW0gZXN0cnV0dXJhIGNvbXBhdMOtdmVsXHJcbiAgICAgIGludGVyZmFjZSBTdW1tYXJ5QnJhbmNoIHtcclxuICAgICAgICBuYW1lOiBzdHJpbmc7IHRvdGFsQVBhZ2FyOiBudW1iZXI7IHRvdGFsQVJlY2ViZXI6IG51bWJlcjsgdG90YWw6IG51bWJlcjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBicmFuY2hNYXA6IFJlY29yZDxzdHJpbmcsIHsgcGFnYXI6IG51bWJlcjsgcmVjZWJlcjogbnVtYmVyIH0+ID0ge307XHJcbiAgICAgIGNvbnN0IGRhdGVUb3RhbHNNYXA6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuXHJcbiAgICAgIHByb2Nlc3NlZERhdGEudHJhbnNhY3Rpb25zLmZvckVhY2godHIgPT4ge1xyXG4gICAgICAgIGNvbnN0IGJyYW5jaCA9IHRyLmZpbGlhbCB8fCB0ci5zb3VyY2VGaWxlPy5yZXBsYWNlKC9cXC5jc3YkL2ksICcnKSB8fCAnREVTQ09OSEVDSURBJztcclxuICAgICAgICBpZiAoIWJyYW5jaE1hcFticmFuY2hdKSBicmFuY2hNYXBbYnJhbmNoXSA9IHsgcGFnYXI6IDAsIHJlY2ViZXI6IDAgfTtcclxuICAgICAgICBpZiAodHIuZG9jdW1lbnRUeXBlID09PSAnQV9QQUdBUicpIGJyYW5jaE1hcFticmFuY2hdLnBhZ2FyICs9IHRyLnZhbG9yTnVtZXJpY287XHJcbiAgICAgICAgZWxzZSBpZiAodHIuZG9jdW1lbnRUeXBlID09PSAnQV9SRUNFQkVSJykgYnJhbmNoTWFwW2JyYW5jaF0ucmVjZWJlciArPSB0ci52YWxvck51bWVyaWNvO1xyXG5cclxuICAgICAgICAvLyBUb3RhaXMgcG9yIGRhdGEgKHVzYW5kbyBhcGVuYXMgQV9QQUdBUiBwYXJhIG1hbnRlciBjb25zaXN0w6puY2lhIGNvbSByZXN1bW8gYW50ZXJpb3IpXHJcbiAgICAgICAgaWYgKHRyLmRvY3VtZW50VHlwZSA9PT0gJ0FfUEFHQVInKSB7XHJcbiAgICAgICAgICBjb25zdCBkYXRlU3RyID0gdHIudmVuY2ltZW50bzsgLy8gasOhIGVtIEREL01NL1lZWVlcclxuICAgICAgICAgICAgaWYgKCFkYXRlVG90YWxzTWFwW2RhdGVTdHJdKSBkYXRlVG90YWxzTWFwW2RhdGVTdHJdID0gMDtcclxuICAgICAgICAgICAgZGF0ZVRvdGFsc01hcFtkYXRlU3RyXSArPSB0ci52YWxvck51bWVyaWNvO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBicmFuY2hlc1N1bW1hcnk6IFN1bW1hcnlCcmFuY2hbXSA9IE9iamVjdC5lbnRyaWVzKGJyYW5jaE1hcCkubWFwKChbbmFtZSwgdl0pID0+ICh7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICB0b3RhbEFQYWdhcjogdi5wYWdhcixcclxuICAgICAgICB0b3RhbEFSZWNlYmVyOiB2LnJlY2ViZXIsXHJcbiAgICAgICAgdG90YWw6IHYucGFnYXIgKyB2LnJlY2ViZXJcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgLy8gQ29uc3RydWlyIGRhdGVTcGVjaWZpY1RvdGFscyBvcmRlbmFkb1xyXG4gICAgICBjb25zdCBkYXRlU3BlY2lmaWNUb3RhbHMgPSBPYmplY3QuZW50cmllcyhkYXRlVG90YWxzTWFwKS5tYXAoKFtkYXksIHRvdGFsXSkgPT4gKHsgZGF5LCB0b3RhbCB9KSlcclxuICAgICAgICAuZmlsdGVyKGQgPT4gL1xcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7NH0vLnRlc3QoZC5kYXkpKVxyXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBbZGEsIG1hLCB5YV0gPSBhLmRheS5zcGxpdCgnLycpLm1hcChOdW1iZXIpO1xyXG4gICAgICAgICAgY29uc3QgW2RiLCBtYiwgeWJdID0gYi5kYXkuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKTtcclxuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5YSwgbWEgLSAxLCBkYSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoeWIsIG1iIC0gMSwgZGIpLmdldFRpbWUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIC8vIERvY3VtZW50RGF0ZXMgY29tIGRpYSBkYSBzZW1hbmEgKGFwZW5hcyBkaWFzIMO6dGVpcylcclxuICAgICAgY29uc3QgZG9jdW1lbnREYXRlcyA9IGRhdGVTcGVjaWZpY1RvdGFscy5tYXAoZCA9PiB7XHJcbiAgICAgICAgY29uc3QgW2RheSwgbW9udGgsIHllYXJdID0gZC5kYXkuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKTtcclxuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xyXG4gICAgICAgIGNvbnN0IGRheU5hbWVzID0gWydEb21pbmdvJywgJ1NlZ3VuZGEnLCAnVGVyw6dhJywgJ1F1YXJ0YScsICdRdWludGEnLCAnU2V4dGEnLCAnU8OhYmFkbyddO1xyXG4gICAgICAgIHJldHVybiB7IGRheTogZC5kYXksIGRheU9mV2VlazogZGF5TmFtZXNbZGF0ZS5nZXREYXkoKV0sIHRvdGFsOiBkLnRvdGFsLCBkYXRlIH07XHJcbiAgICAgIH0pLmZpbHRlcihpdGVtID0+IHtcclxuICAgICAgICBjb25zdCBkb3cgPSBpdGVtLmRhdGUuZ2V0RGF5KCk7XHJcbiAgICAgICAgcmV0dXJuIGRvdyA+PSAxICYmIGRvdyA8PSA1OyAvLyBkaWFzIMO6dGVpc1xyXG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhLmRhdGUuZ2V0VGltZSgpIC0gYi5kYXRlLmdldFRpbWUoKSlcclxuICAgICAgICAubWFwKCh7IGRheSwgZGF5T2ZXZWVrLCB0b3RhbCB9KSA9PiAoeyBkYXksIGRheU9mV2VlaywgdG90YWwgfSkpO1xyXG5cclxuICAgICAgY29uc3QgZ3JhbmRUb3RhbEFQYWdhciA9IGJyYW5jaGVzU3VtbWFyeS5yZWR1Y2UoKHMsIGIpID0+IHMgKyBiLnRvdGFsQVBhZ2FyLCAwKTtcclxuICAgICAgY29uc3QgZ3JhbmRUb3RhbEFSZWNlYmVyID0gYnJhbmNoZXNTdW1tYXJ5LnJlZHVjZSgocywgYikgPT4gcyArIGIudG90YWxBUmVjZWJlciwgMCk7XHJcbiAgICAgIGNvbnN0IGdyYW5kVG90YWwgPSBkYXRlU3BlY2lmaWNUb3RhbHMucmVkdWNlKChzLCBkKSA9PiBzICsgZC50b3RhbCwgMCk7XHJcblxyXG4gICAgICBjb25zdCBzdW1tYXJ5RGF0YSA9IHtcclxuICAgICAgICBicmFuY2hlczogYnJhbmNoZXNTdW1tYXJ5LFxyXG4gICAgICAgIGRhaWx5VG90YWxzOiBbXSwgLy8gbsOjbyB1dGlsaXphZG8gbm8gZXhwb3J0IGF0dWFsXHJcbiAgICAgICAgZG9jdW1lbnREYXRlcyxcclxuICAgICAgICBkYXRlU3BlY2lmaWNUb3RhbHMsXHJcbiAgICAgICAgZ3JhbmRUb3RhbCxcclxuICAgICAgICBncmFuZFRvdGFsQVBhZ2FyLFxyXG4gICAgICAgIGdyYW5kVG90YWxBUmVjZWJlcixcclxuICAgICAgICB0b3RhbEFQYWdhcjogZ3JhbmRUb3RhbEFQYWdhclxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc3RvcmFnZS5zZXQoJ3N1bW1hcnlEYXRhJywgc3VtbWFyeURhdGEpO1xyXG4gICAgfSBjYXRjaChzdW1tYXJ5RXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignRmFsaGEgYW8gZ2VyYXIgc3VtbWFyeURhdGEgYSBwYXJ0aXIgZGUgcHJvY2Vzc2VkRGF0YTonLCBzdW1tYXJ5RXJyKTtcclxuICAgIH1cclxuICAgIC8vID09PT09IEZJTTogR0VSQcOHw4NPIERFIHN1bW1hcnlEYXRhID09PT09XHJcblxyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogYCR7Y3N2RmlsZXMubGVuZ3RofSBhcnF1aXZvKHMpIHByb2Nlc3NhZG8ocykgY29tIHN1Y2Vzc29gLFxyXG4gICAgICBkYXRhOiBwcm9jZXNzZWREYXRhLFxyXG4gICAgICBzdW1tYXJ5RGF0YTogc3RvcmFnZS5nZXQoJ3N1bW1hcnlEYXRhJykgfHwgbnVsbCxcclxuICAgICAgYWxsRmlsZXNEYXRhXHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignPT09IEVSUk9SIElOIFVQTE9BRC1DU1YgPT09Jyk7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB0eXBlOicsIHR5cGVvZiBlcnJvcik7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtZXNzYWdlOicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSk7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdGFjazonLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiAnTm8gc3RhY2sgdHJhY2UnKTtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Z1bGwgZXJyb3Igb2JqZWN0OicsIGVycm9yKTtcclxuICAgIFxyXG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oeyBcclxuICAgICAgc3VjY2VzczogZmFsc2UsIFxyXG4gICAgICBtZXNzYWdlOiAnRXJybyBpbnRlcm5vIGRvIHNlcnZpZG9yOiAnICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSlcclxuICAgIH0pXHJcbiAgfVxyXG59Il0sIm5hbWVzIjpbImZvcm1pZGFibGUiLCJmcyIsIlBhcGEiLCJwYXRoIiwic3RvcmFnZSIsInBhcnNlQ1NWRGF0ZSIsImRhdGVTdHIiLCJmb3JtYXRzIiwiZm9ybWF0IiwibWF0Y2giLCJEYXRlIiwicGFyc2VJbnQiLCJnZXRXZWVrQm91bmRhcmllcyIsImRhdGUiLCJkYXlPZldlZWsiLCJnZXREYXkiLCJ3ZWVrU3RhcnQiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInNldEhvdXJzIiwid2Vla0VuZCIsInBhcnNlTW9uZXRhcnlWYWx1ZSIsInN0ciIsImNsZWFuVmFsdWUiLCJyZXBsYWNlIiwiaXNOZWdhdGl2ZSIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJ2YWx1ZSIsInBhcnNlRmxvYXQiLCJkZXRlY3RFbmNvZGluZyIsImJ1ZmZlciIsImVuY29kaW5ncyIsImVuY29kaW5nIiwiZGVjb2RlZCIsInRvU3RyaW5nIiwiaW5jbHVkZXMiLCJlcnJvciIsImV4dHJhaXJUcmFuc2FjaW9uYWRvckVEb2N1bWVudG8iLCJjc3ZDb250ZW50IiwiZG9jdW1lbnRUeXBlIiwibm9tZUZpbGlhbCIsInBhcnNlUmVzdWx0IiwicGFyc2UiLCJoZWFkZXIiLCJza2lwRW1wdHlMaW5lcyIsInJvd3MiLCJkYXRhIiwiZG9jdW1lbnRvc0V4dHJhaWRvcyIsInJvdyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImNhdGVnb3J5IiwidHJpbSIsInRyYW5zYWNpb25hZG9yIiwibnVtZXJvRG9jdW1lbnRvIiwidmFsdWVTdHIiLCJpc05hTiIsImdldFRpbWUiLCJ0cmFuc2FjaW9uYWRvckZpbmFsIiwibnVtZXJvRG9jdW1lbnRvRmluYWwiLCJwdXNoIiwiZGF0YVZlbmNpbWVudG8iLCJ2YWxvciIsInZhbG9yT3JpZ2luYWwiLCJjYXRlZ29yaWEiLCJmaWxpYWwiLCJzb3VyY2VGaWxlIiwiY29uZmlnIiwiYXBpIiwiYm9keVBhcnNlciIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwibWVzc2FnZSIsInF1ZXJ5IiwiY2xlYXJEYXRhIiwiZGVsZXRlIiwiY29uc29sZSIsImxvZyIsImhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5IiwidGVtcERpciIsImV4aXN0c1N5bmMiLCJta2RpclN5bmMiLCJyZWN1cnNpdmUiLCJmb3JtIiwidXBsb2FkRGlyIiwia2VlcEV4dGVuc2lvbnMiLCJtYXhGaWxlcyIsIm1heEZpbGVTaXplIiwiZmllbGRzIiwiZmlsZXMiLCJPYmplY3QiLCJrZXlzIiwic2VsZWN0ZWRUeXBlcyIsImRvY3VtZW50VHlwZXMiLCJkb2N1bWVudFR5cGVzU3RyaW5nIiwicGFyc2VkIiwiYWxsVHlwZXMiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwidHlwZUFycmF5IiwidW5pcXVlVHlwZXMiLCJmcm9tIiwiU2V0IiwiZSIsImFsbEZpbGVzIiwiZmxhdCIsImZpbHRlciIsIkJvb2xlYW4iLCJtYXAiLCJmIiwib3JpZ2luYWxGaWxlbmFtZSIsImZpbGVwYXRoIiwiY3N2RmlsZXMiLCJmaWxlIiwibWltZXR5cGUiLCJzaXplIiwidGVzdCIsIm5hbWUiLCJ0eXBlIiwic3VjY2VzcyIsImFsbFRyYW5zYWN0aW9ucyIsImFsbEZpbGVzRGF0YSIsInJlYWRGaWxlU3luYyIsImJyYW5jaE5hbWUiLCJ0b1VwcGVyQ2FzZSIsImZpbGVUcmFuc2FjdGlvbnMiLCJzbGljZSIsImRvYyIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInRyYW5zYWN0aW9uIiwic3VwcGxpZXIiLCJkb2NOdW1iZXIiLCJicmFuY2giLCJmaWxlbmFtZSIsInRyYW5zYWN0aW9ucyIsInRvdGFsVHJhbnNhY3Rpb25zIiwidW5saW5rU3luYyIsInByb2Nlc3NGaWxlRXJyIiwiYnJhbmNoVG90YWxzTWFwIiwiTWFwIiwiZGFpbHlUb3RhbHNNYXAiLCJ0b3RhbFBheWFibGUiLCJ0b3RhbFJlY2VpdmFibGUiLCJncmFuZFRvdGFsVmFsdWUiLCJicmFuY2hLZXkiLCJoYXMiLCJzZXQiLCJpbnZvaWNlQ291bnQiLCJ0b3RhbFZhbHVlIiwiYnJhbmNoVG90YWwiLCJnZXQiLCJkYXRlS2V5IiwidG9JU09TdHJpbmciLCJzcGxpdCIsImRhaWx5VG90YWwiLCJicmFuY2hUb3RhbHMiLCJlbnRyaWVzIiwidG9Mb2NhbGVTdHJpbmciLCJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCJkYWlseVRvdGFscyIsIndvcmtpbmdEYXlzVG90YWwiLCJkIiwicmVkdWNlIiwic3VtIiwid2Vla2VuZFRvdGFsIiwid29ya2luZ0RheXMiLCJ3ZWVrZW5kRGF5cyIsIm1pbkRhdGUiLCJNYXRoIiwibWluIiwidCIsIm1heERhdGUiLCJtYXgiLCJwcm9jZXNzZWREYXRhIiwid2Vla2x5VG90YWxzIiwid2Vla1RvdGFsIiwid2Vla1BlcmlvZCIsImdyYW5kVG90YWwiLCJ0b3RhbEludm9pY2VzIiwidmVuY2ltZW50byIsImRvY3VtZW50byIsInZhbG9yTnVtZXJpY28iLCJjYWNoZVBhdGgiLCJqb2luIiwid3JpdGVGaWxlU3luYyIsImNhY2hlRXJyIiwid2FybiIsImJyYW5jaE1hcCIsImRhdGVUb3RhbHNNYXAiLCJ0ciIsInBhZ2FyIiwicmVjZWJlciIsImJyYW5jaGVzU3VtbWFyeSIsInYiLCJ0b3RhbEFQYWdhciIsInRvdGFsQVJlY2ViZXIiLCJ0b3RhbCIsImRhdGVTcGVjaWZpY1RvdGFscyIsImRheSIsInNvcnQiLCJhIiwiYiIsImRhIiwibWEiLCJ5YSIsIk51bWJlciIsImRiIiwibWIiLCJ5YiIsImRvY3VtZW50RGF0ZXMiLCJtb250aCIsInllYXIiLCJkYXlOYW1lcyIsIml0ZW0iLCJkb3ciLCJncmFuZFRvdGFsQVBhZ2FyIiwicyIsImdyYW5kVG90YWxBUmVjZWJlciIsInN1bW1hcnlEYXRhIiwiYnJhbmNoZXMiLCJzdW1tYXJ5RXJyIiwiRXJyb3IiLCJTdHJpbmciLCJzdGFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/upload-csv.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fupload-csv&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cupload-csv.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();