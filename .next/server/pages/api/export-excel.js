"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/export-excel";
exports.ids = ["pages/api/export-excel"];
exports.modules = {

/***/ "exceljs":
/*!**************************!*\
  !*** external "exceljs" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("exceljs");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexport-excel&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexport-excel.ts&middlewareConfigBase64=e30%3D!":
/*!******************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexport-excel&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexport-excel.ts&middlewareConfigBase64=e30%3D! ***!
  \******************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_export_excel_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\export-excel.ts */ \"(api)/./pages/api/export-excel.ts\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_export_excel_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_export_excel_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/export-excel\",\n        pathname: \"/api/export-excel\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_export_excel_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmV4cG9ydC1leGNlbCZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnBhZ2VzJTVDYXBpJTVDZXhwb3J0LWV4Y2VsLnRzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNMO0FBQzFEO0FBQzBEO0FBQzFEO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyx1REFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMsdURBQVE7QUFDcEM7QUFDTyx3QkFBd0IsZ0hBQW1CO0FBQ2xEO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90YWZsZXgtbmV4dGpzLz9kNGZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhZ2VzQVBJUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9wYWdlcy1hcGkvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgaG9pc3QgfSBmcm9tIFwibmV4dC9kaXN0L2J1aWxkL3RlbXBsYXRlcy9oZWxwZXJzXCI7XG4vLyBJbXBvcnQgdGhlIHVzZXJsYW5kIGNvZGUuXG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiLi9wYWdlc1xcXFxhcGlcXFxcZXhwb3J0LWV4Y2VsLnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvZXhwb3J0LWV4Y2VsXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZXhwb3J0LWV4Y2VsXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogXCJcIixcbiAgICAgICAgZmlsZW5hbWU6IFwiXCJcbiAgICB9LFxuICAgIHVzZXJsYW5kXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMtYXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexport-excel&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexport-excel.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./pages/api/export-excel.ts":
/*!***********************************!*\
  !*** ./pages/api/export-excel.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var exceljs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! exceljs */ \"exceljs\");\n/* harmony import */ var exceljs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(exceljs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n// Utilitário seguro para parse de datas DD/MM/AAAA\nfunction parsePtBrDate(dateStr) {\n    if (dateStr instanceof Date) return dateStr;\n    if (typeof dateStr !== \"string\") return new Date();\n    const trimmed = dateStr.trim();\n    const m = trimmed.match(/^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/);\n    if (m) {\n        const d = parseInt(m[1], 10);\n        const mo = parseInt(m[2], 10) - 1;\n        const y = parseInt(m[3], 10);\n        const dt = new Date(y, mo, d);\n        // Validar (Date auto corrige overflow; precisamos garantir integridade)\n        if (dt.getFullYear() === y && dt.getMonth() === mo && dt.getDate() === d) {\n            return dt;\n        }\n    }\n    // Tentar fallback ISO\n    const iso = new Date(trimmed);\n    if (!isNaN(iso.getTime())) return iso;\n    return new Date(); // fallback seguro\n}\n// Estilos Excel obrigatórios\nconst headerStyle = {\n    font: {\n        bold: true,\n        color: {\n            argb: \"FFFFFF\"\n        }\n    },\n    fill: {\n        type: \"pattern\",\n        pattern: \"solid\",\n        fgColor: {\n            argb: \"2F5597\"\n        }\n    },\n    alignment: {\n        horizontal: \"center\",\n        vertical: \"middle\"\n    },\n    border: {\n        top: {\n            style: \"thin\"\n        },\n        left: {\n            style: \"thin\"\n        },\n        bottom: {\n            style: \"thin\"\n        },\n        right: {\n            style: \"thin\"\n        }\n    }\n};\nconst cellStyle = {\n    border: {\n        top: {\n            style: \"thin\"\n        },\n        left: {\n            style: \"thin\"\n        },\n        bottom: {\n            style: \"thin\"\n        },\n        right: {\n            style: \"thin\"\n        }\n    }\n};\nconst titleStyle = {\n    font: {\n        bold: true,\n        size: 16,\n        color: {\n            argb: \"FFFFFF\"\n        }\n    },\n    alignment: {\n        horizontal: \"center\",\n        vertical: \"middle\"\n    },\n    fill: {\n        type: \"pattern\",\n        pattern: \"solid\",\n        fgColor: {\n            argb: \"2F5597\"\n        }\n    }\n};\nconst subHeaderStyle = {\n    font: {\n        bold: true,\n        size: 14,\n        color: {\n            argb: \"FFFFFF\"\n        }\n    },\n    fill: {\n        type: \"pattern\",\n        pattern: \"solid\",\n        fgColor: {\n            argb: \"1F4E79\"\n        }\n    },\n    alignment: {\n        horizontal: \"center\",\n        vertical: \"middle\"\n    }\n};\nconst totalRowStyle = {\n    font: {\n        bold: true,\n        color: {\n            argb: \"FFFFFF\"\n        }\n    },\n    fill: {\n        type: \"pattern\",\n        pattern: \"solid\",\n        fgColor: {\n            argb: \"366092\"\n        }\n    },\n    alignment: {\n        horizontal: \"center\",\n        vertical: \"middle\"\n    }\n};\nasync function handler(req, res) {\n    console.log(\"=== INICIANDO EXPORT-EXCEL ===\");\n    console.log(\"Method:\", req.method);\n    console.log(\"Headers:\", req.headers);\n    try {\n        // Extrair informações do relatório com proteção caso body seja undefined\n        const body = req.body || {};\n        console.log(\"Body keys:\", Object.keys(body));\n        console.log(\"Body type:\", typeof body);\n        const { name: reportName, startDate, endDate, categories, processedData } = body;\n        let summaryData = null;\n        let allInvoices = [];\n        let allBranchSummaries = [];\n        // Verificar se existe dados processados reais do upload-csv\n        if (req.method === \"POST\") {\n            console.log(\"=== DADOS RECEBIDOS NO EXPORT-EXCEL ===\");\n            console.log(\"Has processedData:\", !!body.processedData);\n            if (body.processedData && Array.isArray(body.processedData.transactions)) {\n                console.log(\"=== USANDO DADOS REAIS DO UPLOAD ===\");\n                console.log(\"Total transactions:\", body.processedData.transactions.length);\n                console.log(\"Primeiras transa\\xe7\\xf5es:\", body.processedData.transactions.slice(0, 3));\n                // Converter dados reais para formato esperado pelo Excel\n                const realData = body.processedData;\n                // Agrupar transações por filial para criar summaryData\n                const branchMap = new Map();\n                const allTransactions = [];\n                realData.transactions.forEach((transaction, index)=>{\n                    try {\n                        if (!transaction) {\n                            console.warn(\"[EXPORT] Transa\\xe7\\xe3o nula encontrada no \\xedndice:\", index);\n                            return;\n                        }\n                        console.log(`[EXPORT] Processando transação ${index}:`, {\n                            vencimento: transaction.vencimento,\n                            transacionador: transaction.transacionador,\n                            valor: transaction.valorNumerico,\n                            tipo: transaction.documentType\n                        });\n                        const branch = transaction.filial || realData.branchTotals?.[0]?.branch || \"FILIAL PRINCIPAL\";\n                        const sourceFile = transaction.sourceFile || `${branch}.csv`;\n                        if (!branchMap.has(branch)) {\n                            branchMap.set(branch, {\n                                totalAPagar: 0,\n                                totalAReceber: 0\n                            });\n                        }\n                        const branchData = branchMap.get(branch);\n                        const valorNumerico = transaction.valorNumerico || 0;\n                        // Usar tipo vindo do processamento (valor default A_PAGAR caso ausente)\n                        const documentType = transaction.documentType === \"A_RECEBER\" ? \"A_RECEBER\" : \"A_PAGAR\";\n                        // Parse data robusto\n                        const parsedDate = parsePtBrDate(transaction.vencimento);\n                        if (isNaN(parsedDate.getTime())) {\n                            console.warn(\"[EXPORT] Ignorando transa\\xe7\\xe3o com data inv\\xe1lida:\", transaction.vencimento, transaction);\n                            return;\n                        }\n                        if (typeof valorNumerico !== \"number\" || isNaN(Number(valorNumerico))) {\n                            console.warn(\"[EXPORT] Ignorando transa\\xe7\\xe3o com valor inv\\xe1lido:\", valorNumerico, transaction);\n                            return;\n                        }\n                        if (documentType === \"A_PAGAR\") {\n                            branchData.totalAPagar += Math.abs(valorNumerico);\n                        } else {\n                            branchData.totalAReceber += Math.abs(valorNumerico);\n                        }\n                        // Converter para formato InvoiceData\n                        allTransactions.push({\n                            id: `real_${index}`,\n                            branch: branch,\n                            invoiceNumber: transaction.documento || `DOC-${index}`,\n                            date: parsedDate,\n                            value: transaction.valor || `R$ 0,00`,\n                            supplier: transaction.transacionador || \"FORNECEDOR N\\xc3O IDENTIFICADO\",\n                            documentType: documentType,\n                            sourceFile: sourceFile,\n                            valueNumeric: Math.abs(valorNumerico)\n                        });\n                    } catch (transactionErr) {\n                        console.error(\"[EXPORT] Erro ao processar transa\\xe7\\xe3o:\", index, transactionErr, transaction);\n                    }\n                });\n                // Criar summaryData a partir dos dados reais\n                const branches = Array.from(branchMap.entries()).map(([name, totals])=>({\n                        name,\n                        totalAPagar: totals.totalAPagar,\n                        totalAReceber: totals.totalAReceber,\n                        total: totals.totalAPagar + totals.totalAReceber\n                    }));\n                summaryData = {\n                    branches,\n                    dateSpecificTotals: [],\n                    grandTotal: branches.reduce((sum, b)=>sum + b.total, 0),\n                    grandTotalAPagar: branches.reduce((sum, b)=>sum + b.totalAPagar, 0),\n                    grandTotalAReceber: branches.reduce((sum, b)=>sum + b.totalAReceber, 0)\n                };\n                allInvoices = allTransactions;\n                allBranchSummaries = branches.map((branch)=>({\n                        branch: branch.name,\n                        invoiceCount: allTransactions.filter((inv)=>inv.branch === branch.name).length,\n                        totalValue: branch.total.toLocaleString(\"pt-BR\", {\n                            style: \"currency\",\n                            currency: \"BRL\"\n                        })\n                    }));\n                console.log(\"=== DADOS CONVERTIDOS ===\");\n                console.log(\"Branches criadas:\", branches.length);\n                console.log(\"Total invoices:\", allInvoices.length);\n                console.log(\"Summary grandTotal:\", summaryData.grandTotal);\n            } else if (body.summaryData) {\n                console.log(\"=== USANDO DADOS FORNECIDOS NO BODY ===\");\n                summaryData = body.summaryData;\n            } else {\n                // Tentativa de fallback: carregar cache de upload-csv\n                try {\n                    const cachePath = path__WEBPACK_IMPORTED_MODULE_2___default().join(process.cwd(), \"temp\", \"last_processed.json\");\n                    if (fs__WEBPACK_IMPORTED_MODULE_1___default().existsSync(cachePath)) {\n                        console.log(\"Carregando processedData do cache local (last_processed.json)\");\n                        const cached = JSON.parse(fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(cachePath, \"utf8\"));\n                        if (cached && cached.transactions) {\n                            body.processedData = cached; // reter em memória local\n                            console.log(\"Reinvocando processamento com cache\");\n                            // Forçar pequena recursão lógica manual: duplicar bloco sem recursão HTTP\n                            const realData = cached;\n                            const branchMap = new Map();\n                            const allTransactions = [];\n                            try {\n                                realData.transactions.forEach((transaction, index)=>{\n                                    try {\n                                        console.log(`[EXPORT][CACHE] Processando transação ${index}:`, {\n                                            vencimento: transaction.vencimento,\n                                            transacionador: transaction.transacionador,\n                                            valorNumerico: transaction.valorNumerico\n                                        });\n                                        if (!transaction) return;\n                                        const branch = transaction.filial || realData.branchTotals?.[0]?.branch || \"FILIAL PRINCIPAL\";\n                                        const sourceFile = transaction.sourceFile || `${branch}.csv`;\n                                        if (!branchMap.has(branch)) branchMap.set(branch, {\n                                            totalAPagar: 0,\n                                            totalAReceber: 0\n                                        });\n                                        const branchData = branchMap.get(branch);\n                                        const valorNumerico = transaction.valorNumerico || 0;\n                                        const documentType = transaction.documentType === \"A_RECEBER\" ? \"A_RECEBER\" : \"A_PAGAR\";\n                                        const parsedDate = parsePtBrDate(transaction.vencimento);\n                                        if (isNaN(parsedDate.getTime())) {\n                                            console.warn(\"[EXPORT][CACHE] Ignorando transa\\xe7\\xe3o com data inv\\xe1lida:\", transaction.vencimento);\n                                            return;\n                                        }\n                                        if (typeof valorNumerico !== \"number\" || isNaN(Number(valorNumerico))) {\n                                            console.warn(\"[EXPORT][CACHE] Ignorando transa\\xe7\\xe3o com valor inv\\xe1lido:\", valorNumerico);\n                                            return;\n                                        }\n                                        if (documentType === \"A_PAGAR\") branchData.totalAPagar += Math.abs(valorNumerico);\n                                        else branchData.totalAReceber += Math.abs(valorNumerico);\n                                        allTransactions.push({\n                                            id: `real_${index}`,\n                                            branch: branch,\n                                            invoiceNumber: transaction.documento || `DOC-${index}`,\n                                            date: parsedDate,\n                                            value: transaction.valor || `R$ 0,00`,\n                                            supplier: transaction.transacionador || \"FORNECEDOR N\\xc3O IDENTIFICADO\",\n                                            documentType: documentType,\n                                            sourceFile: sourceFile,\n                                            valueNumeric: Math.abs(valorNumerico)\n                                        });\n                                    } catch (transactionErr) {\n                                        console.error(`[EXPORT][CACHE] Erro ao processar transação ${index}:`, transactionErr);\n                                    }\n                                });\n                            } catch (transactionsErr) {\n                                console.error(\"[EXPORT][CACHE] Erro ao processar transa\\xe7\\xf5es do cache:\", transactionsErr);\n                            }\n                            const branches = Array.from(branchMap.entries()).map(([name, totals])=>({\n                                    name,\n                                    totalAPagar: totals.totalAPagar,\n                                    totalAReceber: totals.totalAReceber,\n                                    total: totals.totalAPagar + totals.totalAReceber\n                                }));\n                            summaryData = {\n                                branches,\n                                dateSpecificTotals: [],\n                                grandTotal: branches.reduce((sum, b)=>sum + b.total, 0),\n                                grandTotalAPagar: branches.reduce((sum, b)=>sum + b.totalAPagar, 0),\n                                grandTotalAReceber: branches.reduce((sum, b)=>sum + b.totalAReceber, 0)\n                            };\n                            allInvoices = allTransactions;\n                            allBranchSummaries = branches.map((branch)=>({\n                                    branch: branch.name,\n                                    invoiceCount: allTransactions.filter((inv)=>inv.branch === branch.name).length,\n                                    totalValue: branch.total.toLocaleString(\"pt-BR\", {\n                                        style: \"currency\",\n                                        currency: \"BRL\"\n                                    })\n                                }));\n                        }\n                    }\n                } catch (cacheErr) {\n                    console.warn(\"Falha ao carregar cache de processedData:\", cacheErr);\n                }\n            }\n            if (body.allInvoices) {\n                allInvoices = body.allInvoices;\n            }\n            if (body.allBranchSummaries) {\n                allBranchSummaries = body.allBranchSummaries;\n            }\n        }\n        // Se não temos dados, usar dados hardcoded para demonstração\n        if (!summaryData || !summaryData.branches || summaryData.branches.length === 0) {\n            console.log(\"Usando dados hardcoded para demonstra\\xe7\\xe3o\");\n            summaryData = {\n                branches: [\n                    {\n                        name: \"GO SEEDS\",\n                        totalAPagar: 1912040.00,\n                        totalAReceber: 3175990.36,\n                        total: 5087030.36\n                    },\n                    {\n                        name: \"BEIJA FLOR\",\n                        totalAPagar: 129763.24,\n                        totalAReceber: 0.00,\n                        total: 129763.24\n                    },\n                    {\n                        name: \"SAGUIA\",\n                        totalAPagar: 138251.10,\n                        totalAReceber: 0.00,\n                        total: 138251.10\n                    },\n                    {\n                        name: \"ULTRA SEEDS\",\n                        totalAPagar: 80.96,\n                        totalAReceber: 0.00,\n                        total: 80.96\n                    }\n                ],\n                dateSpecificTotals: [\n                    {\n                        day: \"15/09/2024\",\n                        total: 500000.00\n                    },\n                    {\n                        day: \"16/09/2024\",\n                        total: 750000.00\n                    },\n                    {\n                        day: \"17/09/2024\",\n                        total: 950000.00\n                    }\n                ],\n                grandTotal: 5355135.66,\n                grandTotalAPagar: 2180135.30,\n                grandTotalAReceber: 3175000.36\n            };\n            // Gerar dados de invoices simulados baseados no summaryData\n            allInvoices = generateSimulatedInvoices(summaryData);\n            allBranchSummaries = summaryData.branches.map((branch)=>({\n                    branch: branch.name,\n                    invoiceCount: Math.floor(Math.random() * 10) + 5,\n                    totalValue: branch.total.toLocaleString(\"pt-BR\", {\n                        style: \"currency\",\n                        currency: \"BRL\"\n                    })\n                }));\n        }\n        // Calcular período real baseado nas datas dos documentos\n        let actualStartDate;\n        let actualEndDate;\n        if (allInvoices.length > 0) {\n            const invoiceDates = allInvoices.map((inv)=>new Date(inv.date)).sort((a, b)=>a.getTime() - b.getTime());\n            actualStartDate = invoiceDates[0];\n            actualEndDate = invoiceDates[invoiceDates.length - 1];\n        } else {\n            actualStartDate = new Date();\n            actualEndDate = new Date();\n        }\n        // Log estatístico para debug multi-file\n        const distinctFiles = Array.from(new Set(allInvoices.map((i)=>i.sourceFile)));\n        const distinctBranches = Array.from(new Set(allInvoices.map((i)=>i.branch)));\n        console.log(\"[EXPORT] Estat\\xedsticas:\", {\n            totalInvoices: allInvoices.length,\n            distinctFiles: distinctFiles.length,\n            files: distinctFiles,\n            distinctBranches: distinctBranches.length,\n            branches: distinctBranches\n        });\n        // Criar workbook\n        const workbook = new (exceljs__WEBPACK_IMPORTED_MODULE_0___default().Workbook)();\n        console.log(\"Criando aba de Resumo Geral...\");\n        await createAdvancedSummaryWorksheet(workbook, summaryData, allInvoices, reportName || \"Relat\\xf3rio de Notas Fiscais\", actualStartDate, actualEndDate);\n        console.log(\"Criando abas individuais por filial...\");\n        const existingWorksheetNames = new Set();\n        existingWorksheetNames.add(\"RESUMO GERAL\"); // Adicionar o nome da aba de resumo\n        for (const branch of summaryData.branches){\n            const branchInvoices = allInvoices.filter((inv)=>inv.branch === branch.name);\n            await createAdvancedBranchWorksheet(workbook, branch, branchInvoices, existingWorksheetNames);\n        }\n        // Configurar resposta HTTP\n        const fileName = `relatorio_detalhado_${new Date().toISOString().split(\"T\")[0]}.xlsx`;\n        res.setHeader(\"Content-Type\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\");\n        res.setHeader(\"Content-Disposition\", `attachment; filename=\"${fileName}\"`);\n        // Escrever workbook na resposta\n        await workbook.xlsx.write(res);\n        console.log(\"Excel gerado com sucesso!\");\n        res.end();\n    } catch (error) {\n        console.error(\"Erro na gera\\xe7\\xe3o do Excel:\", error);\n        console.error(\"Stack trace:\", error instanceof Error ? error.stack : \"N\\xe3o dispon\\xedvel\");\n        console.error(\"Tipo de erro:\", typeof error);\n        console.error(\"Estado do req.body:\", {\n            exists: !!req.body,\n            hasProcessedData: !!req.body?.processedData,\n            processedDataType: typeof req.body?.processedData\n        });\n        if (!res.headersSent) {\n            res.status(500).json({\n                success: false,\n                message: \"Erro interno do servidor: \" + (error instanceof Error ? error.message : \"Erro desconhecido\"),\n                errorDetails: error instanceof Error ? {\n                    name: error.name,\n                    message: error.message,\n                    stack: error.stack?.substring(0, 500) // Primeiros 500 chars do stack\n                } : \"Erro n\\xe3o identificado\"\n            });\n        }\n    }\n}\n// Função para gerar dados de invoices simulados\nfunction generateSimulatedInvoices(summaryData) {\n    const invoices = [];\n    let idCounter = 1;\n    summaryData.branches.forEach((branch)=>{\n        // Gerar algumas invoices A_PAGAR\n        if (branch.totalAPagar > 0) {\n            const numInvoicesAPagar = Math.floor(Math.random() * 5) + 2;\n            const averageValue = branch.totalAPagar / numInvoicesAPagar;\n            for(let i = 0; i < numInvoicesAPagar; i++){\n                const value = averageValue * (0.8 + Math.random() * 0.4); // Variação de ±20%\n                const date = new Date();\n                date.setDate(date.getDate() + Math.floor(Math.random() * 30)); // Próximos 30 dias\n                invoices.push({\n                    id: `inv_${idCounter++}`,\n                    branch: branch.name,\n                    invoiceNumber: `NF-${String(i + 1).padStart(3, \"0\")}`,\n                    date: date,\n                    value: value.toLocaleString(\"pt-BR\", {\n                        style: \"currency\",\n                        currency: \"BRL\"\n                    }),\n                    supplier: `FORNECEDOR ${String.fromCharCode(65 + i)}`,\n                    documentType: \"A_PAGAR\",\n                    sourceFile: `${branch.name}.csv`,\n                    valueNumeric: value\n                });\n            }\n        }\n        // Gerar algumas invoices A_RECEBER\n        if (branch.totalAReceber > 0) {\n            const numInvoicesAReceber = Math.floor(Math.random() * 3) + 1;\n            const averageValue = branch.totalAReceber / numInvoicesAReceber;\n            for(let i = 0; i < numInvoicesAReceber; i++){\n                const value = averageValue * (0.8 + Math.random() * 0.4);\n                const date = new Date();\n                date.setDate(date.getDate() + Math.floor(Math.random() * 30));\n                invoices.push({\n                    id: `inv_${idCounter++}`,\n                    branch: branch.name,\n                    invoiceNumber: `REC-${String(i + 1).padStart(3, \"0\")}`,\n                    date: date,\n                    value: value.toLocaleString(\"pt-BR\", {\n                        style: \"currency\",\n                        currency: \"BRL\"\n                    }),\n                    supplier: `CLIENTE ${String.fromCharCode(65 + i)}`,\n                    documentType: \"A_RECEBER\",\n                    sourceFile: `${branch.name}.csv`,\n                    valueNumeric: value\n                });\n            }\n        }\n    });\n    return invoices;\n}\n// Função para criar a aba de resumo geral avançada\nasync function createAdvancedSummaryWorksheet(workbook, summaryData, allInvoices, reportName, actualStartDate, actualEndDate) {\n    const summarySheet = workbook.addWorksheet(\"Resumo Geral\");\n    let summaryCurrentRow = 1;\n    // Header do relatório\n    summarySheet.addRow([\n        reportName\n    ]);\n    summarySheet.mergeCells(`A${summaryCurrentRow}:D${summaryCurrentRow}`);\n    summarySheet.getCell(`A${summaryCurrentRow}`).style = titleStyle;\n    summarySheet.getRow(summaryCurrentRow).height = 35;\n    summaryCurrentRow++;\n    // Período\n    const periodText = `PERÍODO: ${actualStartDate.toLocaleDateString(\"pt-BR\")} - ${actualEndDate.toLocaleDateString(\"pt-BR\")}`;\n    summarySheet.addRow([\n        periodText\n    ]);\n    summarySheet.mergeCells(`A${summaryCurrentRow}:D${summaryCurrentRow}`);\n    summarySheet.getCell(`A${summaryCurrentRow}`).style = {\n        font: {\n            bold: true,\n            size: 12\n        },\n        fill: {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"E7E6E6\"\n            }\n        },\n        alignment: {\n            horizontal: \"center\",\n            vertical: \"middle\"\n        }\n    };\n    summaryCurrentRow++;\n    // Linha vazia\n    summarySheet.addRow([]);\n    summaryCurrentRow++;\n    // Headers das colunas\n    summarySheet.addRow([\n        \"Vencimento\",\n        \"Transacionador\",\n        \"Documento\",\n        \"Valor\"\n    ]);\n    summarySheet.getRow(summaryCurrentRow).eachCell((cell)=>{\n        cell.style = headerStyle;\n    });\n    summaryCurrentRow++;\n    // Agrupar invoices por arquivo fonte e tipo de documento\n    const invoicesByFileAndType = new Map();\n    for (const invoice of allInvoices){\n        const sourceFile = invoice.sourceFile || \"Unknown\";\n        if (!invoicesByFileAndType.has(sourceFile)) {\n            invoicesByFileAndType.set(sourceFile, {\n                A_PAGAR: [],\n                A_RECEBER: []\n            });\n        }\n        const fileTypes = invoicesByFileAndType.get(sourceFile);\n        const docType = invoice.documentType || \"A_PAGAR\";\n        fileTypes[docType].push(invoice);\n    }\n    // Processar cada arquivo e tipo de documento\n    for (const [fileName, fileTypes] of Array.from(invoicesByFileAndType)){\n        for (const [docType, fileInvoices] of Object.entries(fileTypes)){\n            if (fileInvoices.length === 0) continue;\n            const typeLabel = docType === \"A_PAGAR\" ? \"CONTAS A PAGAR\" : \"CONTAS A RECEBER\";\n            const cleanFileName = fileName.replace(/\\.(csv|CSV)$/, \"\");\n            // Header da categoria\n            summarySheet.addRow([\n                `${typeLabel} - ${cleanFileName}`,\n                \"\",\n                \"\",\n                \"\"\n            ]);\n            summarySheet.mergeCells(`A${summaryCurrentRow}:D${summaryCurrentRow}`);\n            summarySheet.getCell(`A${summaryCurrentRow}`).style = subHeaderStyle;\n            summaryCurrentRow++;\n            // Ordenar por data\n            fileInvoices.sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n            // Adicionar transações com totais diários\n            let currentDate = \"\";\n            let dailyTotal = 0;\n            for (const invoice of fileInvoices){\n                const invoiceDate = new Date(invoice.date).toLocaleDateString(\"pt-BR\");\n                const invoiceValue = invoice.valueNumeric;\n                // Verificar mudança de data para total diário\n                if (currentDate && currentDate !== invoiceDate && dailyTotal > 0) {\n                    summarySheet.addRow([\n                        \"\",\n                        \"\",\n                        \"TOTAL\",\n                        dailyTotal\n                    ]);\n                    const totalRow = summarySheet.getRow(summaryCurrentRow);\n                    totalRow.eachCell((cell, colNumber)=>{\n                        cell.style = {\n                            font: {\n                                bold: true\n                            },\n                            fill: {\n                                type: \"pattern\",\n                                pattern: \"solid\",\n                                fgColor: {\n                                    argb: \"F2F2F2\"\n                                }\n                            },\n                            numFmt: colNumber === 4 ? \"R$ #,##0.00\" : undefined,\n                            border: cellStyle.border,\n                            alignment: colNumber === 3 ? {\n                                horizontal: \"center\"\n                            } : undefined\n                        };\n                    });\n                    summaryCurrentRow++;\n                    dailyTotal = 0;\n                }\n                // Adicionar linha da transação\n                summarySheet.addRow([\n                    invoiceDate,\n                    invoice.supplier || \"FORNECEDOR N\\xc3O IDENTIFICADO\",\n                    invoice.invoiceNumber,\n                    invoiceValue\n                ]);\n                const row = summarySheet.getRow(summaryCurrentRow);\n                row.eachCell((cell, colNumber)=>{\n                    cell.style = cellStyle;\n                    if (colNumber === 4) {\n                        cell.numFmt = \"R$ #,##0.00\";\n                    }\n                });\n                currentDate = invoiceDate;\n                dailyTotal += invoiceValue;\n                summaryCurrentRow++;\n            }\n            // Total final da categoria se houver dados pendentes\n            if (dailyTotal > 0) {\n                summarySheet.addRow([\n                    \"\",\n                    \"\",\n                    \"TOTAL\",\n                    dailyTotal\n                ]);\n                const totalRow = summarySheet.getRow(summaryCurrentRow);\n                totalRow.eachCell((cell, colNumber)=>{\n                    cell.style = {\n                        font: {\n                            bold: true\n                        },\n                        fill: {\n                            type: \"pattern\",\n                            pattern: \"solid\",\n                            fgColor: {\n                                argb: \"F2F2F2\"\n                            }\n                        },\n                        numFmt: colNumber === 4 ? \"R$ #,##0.00\" : undefined,\n                        border: cellStyle.border,\n                        alignment: colNumber === 3 ? {\n                            horizontal: \"center\"\n                        } : undefined\n                    };\n                });\n                summaryCurrentRow++;\n            }\n            // Total da categoria\n            const categoryTotal = fileInvoices.reduce((sum, inv)=>sum + inv.valueNumeric, 0);\n            summarySheet.addRow([\n                \"\",\n                \"\",\n                `TOTAL ${typeLabel}`,\n                categoryTotal\n            ]);\n            const categoryTotalRow = summarySheet.getRow(summaryCurrentRow);\n            categoryTotalRow.eachCell((cell, colNumber)=>{\n                cell.style = {\n                    ...totalRowStyle,\n                    numFmt: colNumber === 4 ? \"R$ #,##0.00\" : undefined,\n                    border: cellStyle.border\n                };\n            });\n            summaryCurrentRow++;\n            // Linha vazia para separação\n            summarySheet.addRow([]);\n            summaryCurrentRow++;\n        }\n    }\n    // Total geral final\n    summarySheet.addRow([\n        \"\",\n        \"\",\n        \"TOTAL GERAL\",\n        summaryData.grandTotal\n    ]);\n    const grandTotalRow = summarySheet.getRow(summaryCurrentRow);\n    grandTotalRow.eachCell((cell, colNumber)=>{\n        cell.style = {\n            ...totalRowStyle,\n            numFmt: colNumber === 4 ? \"R$ #,##0.00\" : undefined,\n            border: cellStyle.border,\n            font: {\n                bold: true,\n                size: 14,\n                color: {\n                    argb: \"FFFFFF\"\n                }\n            }\n        };\n    });\n    // Definir larguras das colunas\n    summarySheet.getColumn(1).width = 15; // Data\n    summarySheet.getColumn(2).width = 60; // Transacionador  \n    summarySheet.getColumn(3).width = 20; // Documento\n    summarySheet.getColumn(4).width = 18; // Valor\n}\n// Função para criar aba individual da filial avançada\n// Função para gerar nomes únicos de worksheet\nfunction generateUniqueWorksheetName(baseName, existingNames) {\n    // Limpar caracteres inválidos e limitar tamanho\n    let cleanName = baseName.replace(/[\\/\\\\\\?\\*\\[\\]]/g, \"_\").replace(/[^a-zA-Z0-9_\\-\\s]/g, \"\").substring(0, 25).trim();\n    // Se o nome estiver vazio após limpeza, usar um padrão\n    if (!cleanName) {\n        cleanName = \"PLANILHA\";\n    }\n    // Se o nome não existe, usar como está\n    if (!existingNames.has(cleanName)) {\n        existingNames.add(cleanName);\n        return cleanName;\n    }\n    // Se existe, adicionar número sequencial\n    let counter = 1;\n    let uniqueName = `${cleanName.substring(0, 22)}_${counter}`;\n    while(existingNames.has(uniqueName)){\n        counter++;\n        uniqueName = `${cleanName.substring(0, 22)}_${counter}`;\n    }\n    existingNames.add(uniqueName);\n    return uniqueName;\n}\nasync function createAdvancedBranchWorksheet(workbook, branch, branchInvoices, existingNames) {\n    const uniqueName = generateUniqueWorksheetName(branch.name, existingNames);\n    const worksheet = workbook.addWorksheet(uniqueName);\n    let currentRow = 1;\n    // Título da filial\n    const titleRow = worksheet.addRow([\n        `DETALHAMENTO - ${branch.name}`\n    ]);\n    worksheet.mergeCells(`A${currentRow}:D${currentRow}`);\n    titleRow.getCell(1).style = titleStyle;\n    titleRow.height = 30;\n    currentRow++;\n    // Período\n    if (branchInvoices.length > 0) {\n        const branchDates = branchInvoices.map((inv)=>new Date(inv.date)).sort((a, b)=>a.getTime() - b.getTime());\n        const startDate = branchDates[0];\n        const endDate = branchDates[branchDates.length - 1];\n        const periodText = `PERÍODO: ${startDate.toLocaleDateString(\"pt-BR\")} - ${endDate.toLocaleDateString(\"pt-BR\")}`;\n        worksheet.addRow([\n            periodText\n        ]);\n        worksheet.mergeCells(`A${currentRow}:D${currentRow}`);\n        worksheet.getCell(`A${currentRow}`).style = {\n            font: {\n                bold: true,\n                size: 12\n            },\n            fill: {\n                type: \"pattern\",\n                pattern: \"solid\",\n                fgColor: {\n                    argb: \"E7E6E6\"\n                }\n            },\n            alignment: {\n                horizontal: \"center\",\n                vertical: \"middle\"\n            }\n        };\n        currentRow++;\n    }\n    // Detalhamento de transações por tipo\n    if (branchInvoices.length > 0) {\n        // Separar por tipo de documento\n        const apagarInvoices = branchInvoices.filter((inv)=>inv.documentType === \"A_PAGAR\");\n        const areceberInvoices = branchInvoices.filter((inv)=>inv.documentType === \"A_RECEBER\");\n        // Processar A_PAGAR\n        if (apagarInvoices.length > 0) {\n            const aPagarHeaderRow = worksheet.addRow([\n                \"CONTAS A PAGAR\"\n            ]);\n            worksheet.mergeCells(`A${currentRow}:D${currentRow}`);\n            aPagarHeaderRow.getCell(1).style = subHeaderStyle;\n            currentRow++;\n            worksheet.addRow([]);\n            currentRow++;\n            // Cabeçalhos das transações A_PAGAR\n            const transHeaderRow = worksheet.addRow([\n                \"Vencimento\",\n                \"Transacionador\",\n                \"Documento\",\n                \"Valor\"\n            ]);\n            transHeaderRow.eachCell((cell)=>{\n                cell.style = headerStyle;\n            });\n            currentRow++;\n            // Ordenar por data e adicionar transações\n            apagarInvoices.sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n            let currentDate = \"\";\n            let dailyTotal = 0;\n            apagarInvoices.forEach((invoice)=>{\n                const invoiceDate = new Date(invoice.date).toLocaleDateString(\"pt-BR\");\n                // Verificar mudança de data para total diário\n                if (currentDate && currentDate !== invoiceDate && dailyTotal > 0) {\n                    worksheet.addRow([\n                        \"\",\n                        \"\",\n                        \"TOTAL\",\n                        dailyTotal\n                    ]);\n                    const totalRow = worksheet.getRow(currentRow);\n                    totalRow.eachCell((cell, colNumber)=>{\n                        cell.style = {\n                            font: {\n                                bold: true\n                            },\n                            fill: {\n                                type: \"pattern\",\n                                pattern: \"solid\",\n                                fgColor: {\n                                    argb: \"F2F2F2\"\n                                }\n                            },\n                            numFmt: colNumber === 4 ? \"R$ #,##0.00\" : undefined,\n                            border: cellStyle.border,\n                            alignment: colNumber === 3 ? {\n                                horizontal: \"center\"\n                            } : undefined\n                        };\n                    });\n                    currentRow++;\n                    dailyTotal = 0;\n                }\n                worksheet.addRow([\n                    invoiceDate,\n                    invoice.supplier,\n                    invoice.invoiceNumber,\n                    invoice.valueNumeric\n                ]);\n                const row = worksheet.getRow(currentRow);\n                row.eachCell((cell, colNumber)=>{\n                    cell.style = cellStyle;\n                    if (colNumber === 4) {\n                        cell.numFmt = \"R$ #,##0.00\";\n                    }\n                });\n                currentDate = invoiceDate;\n                dailyTotal += invoice.valueNumeric;\n                currentRow++;\n            });\n            // Total final A_PAGAR\n            if (dailyTotal > 0) {\n                worksheet.addRow([\n                    \"\",\n                    \"\",\n                    \"TOTAL\",\n                    dailyTotal\n                ]);\n                const totalRow = worksheet.getRow(currentRow);\n                totalRow.eachCell((cell, colNumber)=>{\n                    cell.style = {\n                        font: {\n                            bold: true\n                        },\n                        fill: {\n                            type: \"pattern\",\n                            pattern: \"solid\",\n                            fgColor: {\n                                argb: \"F2F2F2\"\n                            }\n                        },\n                        numFmt: colNumber === 4 ? \"R$ #,##0.00\" : undefined,\n                        border: cellStyle.border,\n                        alignment: colNumber === 3 ? {\n                            horizontal: \"center\"\n                        } : undefined\n                    };\n                });\n                currentRow++;\n            }\n            const totalAPagarRow = worksheet.addRow([\n                \"\",\n                \"\",\n                \"TOTAL A PAGAR\",\n                branch.totalAPagar\n            ]);\n            totalAPagarRow.eachCell((cell, colNumber)=>{\n                cell.style = {\n                    ...totalRowStyle,\n                    numFmt: colNumber === 4 ? \"R$ #,##0.00\" : undefined,\n                    border: cellStyle.border\n                };\n            });\n            currentRow++;\n            // Linha vazia\n            worksheet.addRow([]);\n            currentRow++;\n        }\n        // Processar A_RECEBER\n        if (areceberInvoices.length > 0) {\n            const aReceberHeaderRow = worksheet.addRow([\n                \"CONTAS A RECEBER\"\n            ]);\n            worksheet.mergeCells(`A${currentRow}:D${currentRow}`);\n            aReceberHeaderRow.getCell(1).style = subHeaderStyle;\n            currentRow++;\n            worksheet.addRow([]);\n            currentRow++;\n            // Cabeçalhos das transações A_RECEBER\n            const transHeaderRow = worksheet.addRow([\n                \"Vencimento\",\n                \"Cliente\",\n                \"Documento\",\n                \"Valor\"\n            ]);\n            transHeaderRow.eachCell((cell)=>{\n                cell.style = headerStyle;\n            });\n            currentRow++;\n            // Ordenar por data e adicionar transações\n            areceberInvoices.sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n            let currentDate = \"\";\n            let dailyTotal = 0;\n            areceberInvoices.forEach((invoice)=>{\n                const invoiceDate = new Date(invoice.date).toLocaleDateString(\"pt-BR\");\n                // Verificar mudança de data para total diário\n                if (currentDate && currentDate !== invoiceDate && dailyTotal > 0) {\n                    worksheet.addRow([\n                        \"\",\n                        \"\",\n                        \"TOTAL\",\n                        dailyTotal\n                    ]);\n                    const totalRow = worksheet.getRow(currentRow);\n                    totalRow.eachCell((cell, colNumber)=>{\n                        cell.style = {\n                            font: {\n                                bold: true\n                            },\n                            fill: {\n                                type: \"pattern\",\n                                pattern: \"solid\",\n                                fgColor: {\n                                    argb: \"F2F2F2\"\n                                }\n                            },\n                            numFmt: colNumber === 4 ? \"R$ #,##0.00\" : undefined,\n                            border: cellStyle.border,\n                            alignment: colNumber === 3 ? {\n                                horizontal: \"center\"\n                            } : undefined\n                        };\n                    });\n                    currentRow++;\n                    dailyTotal = 0;\n                }\n                worksheet.addRow([\n                    invoiceDate,\n                    invoice.supplier,\n                    invoice.invoiceNumber,\n                    invoice.valueNumeric\n                ]);\n                const row = worksheet.getRow(currentRow);\n                row.eachCell((cell, colNumber)=>{\n                    cell.style = cellStyle;\n                    if (colNumber === 4) {\n                        cell.numFmt = \"R$ #,##0.00\";\n                    }\n                });\n                currentDate = invoiceDate;\n                dailyTotal += invoice.valueNumeric;\n                currentRow++;\n            });\n            // Total final A_RECEBER\n            if (dailyTotal > 0) {\n                worksheet.addRow([\n                    \"\",\n                    \"\",\n                    \"TOTAL\",\n                    dailyTotal\n                ]);\n                const totalRow = worksheet.getRow(currentRow);\n                totalRow.eachCell((cell, colNumber)=>{\n                    cell.style = {\n                        font: {\n                            bold: true\n                        },\n                        fill: {\n                            type: \"pattern\",\n                            pattern: \"solid\",\n                            fgColor: {\n                                argb: \"F2F2F2\"\n                            }\n                        },\n                        numFmt: colNumber === 4 ? \"R$ #,##0.00\" : undefined,\n                        border: cellStyle.border,\n                        alignment: colNumber === 3 ? {\n                            horizontal: \"center\"\n                        } : undefined\n                    };\n                });\n                currentRow++;\n            }\n            const totalAReceberRow = worksheet.addRow([\n                \"\",\n                \"\",\n                \"TOTAL A RECEBER\",\n                branch.totalAReceber\n            ]);\n            totalAReceberRow.eachCell((cell, colNumber)=>{\n                cell.style = {\n                    ...totalRowStyle,\n                    numFmt: colNumber === 4 ? \"R$ #,##0.00\" : undefined,\n                    border: cellStyle.border\n                };\n            });\n            currentRow++;\n        }\n    } else {\n        // Mensagem quando não há transações detalhadas\n        const noDataRow = worksheet.addRow([\n            \"TRANSA\\xc7\\xd5ES DETALHADAS\"\n        ]);\n        worksheet.mergeCells(`A${currentRow}:D${currentRow}`);\n        noDataRow.getCell(1).style = subHeaderStyle;\n        currentRow++;\n        worksheet.addRow([]);\n        currentRow++;\n        worksheet.addRow([\n            \"Dados detalhados das transa\\xe7\\xf5es ser\\xe3o exibidos aqui quando dispon\\xedveis.\"\n        ]);\n        worksheet.addRow([\n            \"Para obter detalhes, fa\\xe7a upload dos arquivos CSV individuais.\"\n        ]);\n    }\n    // Ajustar largura das colunas\n    worksheet.columns = [\n        {\n            width: 15\n        },\n        {\n            width: 40\n        },\n        {\n            width: 20\n        },\n        {\n            width: 18\n        } // Valor\n    ];\n}\n// Função para criar a aba de resumo geral\nasync function createResumoGeralWorksheet(workbook, summaryData) {\n    const worksheet = workbook.addWorksheet(\"Resumo Geral\");\n    // Título principal\n    const titleRow = worksheet.addRow([\n        \"RESUMO GERAL - SALDO L\\xcdQUIDO POR FILIAL\"\n    ]);\n    worksheet.mergeCells(\"A1:D1\");\n    titleRow.getCell(1).fill = {\n        type: \"pattern\",\n        pattern: \"solid\",\n        fgColor: {\n            argb: \"FF4472C4\"\n        }\n    };\n    titleRow.getCell(1).font = {\n        bold: true,\n        color: {\n            argb: \"FFFFFFFF\"\n        },\n        size: 16\n    };\n    titleRow.getCell(1).alignment = {\n        horizontal: \"center\",\n        vertical: \"middle\"\n    };\n    titleRow.height = 30;\n    worksheet.addRow([]); // Linha vazia\n    // Cabeçalhos\n    const headerRow = worksheet.addRow([\n        \"FILIAL\",\n        \"TOTAL A PAGAR\",\n        \"TOTAL A RECEBER\",\n        \"SALDO L\\xcdQUIDO\"\n    ]);\n    headerRow.font = {\n        bold: true,\n        color: {\n            argb: \"FFFFFFFF\"\n        }\n    };\n    headerRow.fill = {\n        type: \"pattern\",\n        pattern: \"solid\",\n        fgColor: {\n            argb: \"FF4472C4\"\n        }\n    };\n    headerRow.alignment = {\n        horizontal: \"center\",\n        vertical: \"middle\"\n    };\n    // Dados das filiais\n    summaryData.branches.forEach((branch)=>{\n        const saldoLiquido = branch.totalAReceber - branch.totalAPagar;\n        const row = worksheet.addRow([\n            branch.name,\n            `R$ ${branch.totalAPagar.toLocaleString(\"pt-BR\", {\n                minimumFractionDigits: 2\n            })}`,\n            `R$ ${branch.totalAReceber.toLocaleString(\"pt-BR\", {\n                minimumFractionDigits: 2\n            })}`,\n            `R$ ${saldoLiquido.toLocaleString(\"pt-BR\", {\n                minimumFractionDigits: 2\n            })}`\n        ]);\n        // Colorir saldo líquido conforme valor\n        const saldoCell = row.getCell(4);\n        if (saldoLiquido > 0) {\n            saldoCell.font = {\n                color: {\n                    argb: \"FF008000\"\n                },\n                bold: true\n            }; // Verde\n        } else if (saldoLiquido < 0) {\n            saldoCell.font = {\n                color: {\n                    argb: \"FFFF0000\"\n                },\n                bold: true\n            }; // Vermelho\n        }\n    });\n    // Linha de total geral\n    worksheet.addRow([]); // Linha vazia\n    const totalRow = worksheet.addRow([\n        \"TOTAL GERAL\",\n        `R$ ${summaryData.grandTotalAPagar.toLocaleString(\"pt-BR\", {\n            minimumFractionDigits: 2\n        })}`,\n        `R$ ${summaryData.grandTotalAReceber.toLocaleString(\"pt-BR\", {\n            minimumFractionDigits: 2\n        })}`,\n        `R$ ${(summaryData.grandTotalAReceber - summaryData.grandTotalAPagar).toLocaleString(\"pt-BR\", {\n            minimumFractionDigits: 2\n        })}`\n    ]);\n    totalRow.font = {\n        bold: true,\n        size: 12\n    };\n    totalRow.fill = {\n        type: \"pattern\",\n        pattern: \"solid\",\n        fgColor: {\n            argb: \"FFE0E0E0\"\n        }\n    };\n    // Ajustar largura das colunas\n    worksheet.columns = [\n        {\n            width: 20\n        },\n        {\n            width: 18\n        },\n        {\n            width: 18\n        },\n        {\n            width: 18\n        } // Saldo Líquido\n    ];\n    // Adicionar bordas\n    const dataRange = worksheet.getRows(3, worksheet.rowCount - 2);\n    dataRange?.forEach((row)=>{\n        row.eachCell((cell)=>{\n            cell.border = {\n                top: {\n                    style: \"thin\"\n                },\n                left: {\n                    style: \"thin\"\n                },\n                bottom: {\n                    style: \"thin\"\n                },\n                right: {\n                    style: \"thin\"\n                }\n            };\n        });\n    });\n}\n// Função para criar aba individual da filial\nasync function createBranchWorksheet(workbook, branch, processedData) {\n    const worksheet = workbook.addWorksheet(branch.name);\n    // Título da filial\n    const titleRow = worksheet.addRow([\n        `DETALHAMENTO - ${branch.name}`\n    ]);\n    worksheet.mergeCells(\"A1:D1\");\n    titleRow.getCell(1).fill = {\n        type: \"pattern\",\n        pattern: \"solid\",\n        fgColor: {\n            argb: \"FF4472C4\"\n        }\n    };\n    titleRow.getCell(1).font = {\n        bold: true,\n        color: {\n            argb: \"FFFFFFFF\"\n        },\n        size: 14\n    };\n    titleRow.getCell(1).alignment = {\n        horizontal: \"center\",\n        vertical: \"middle\"\n    };\n    titleRow.height = 25;\n    worksheet.addRow([]); // Linha vazia\n    // Detalhamento de transações (se disponível)\n    if (processedData && processedData.transactions.length > 0) {\n        const transactionsHeaderRow = worksheet.addRow([\n            \"DETALHAMENTO DE TRANSA\\xc7\\xd5ES\"\n        ]);\n        worksheet.mergeCells(`A${worksheet.rowCount}:D${worksheet.rowCount}`);\n        transactionsHeaderRow.getCell(1).font = {\n            bold: true,\n            size: 12\n        };\n        transactionsHeaderRow.getCell(1).fill = {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"FFE0E0E0\"\n            }\n        };\n        transactionsHeaderRow.getCell(1).alignment = {\n            horizontal: \"center\"\n        };\n        worksheet.addRow([]); // Linha vazia\n        // Cabeçalhos das transações\n        const transHeaderRow = worksheet.addRow([\n            \"Vencimento\",\n            \"Transacionador\",\n            \"Documento\",\n            \"Valor\",\n            \"Tipo\"\n        ]);\n        transHeaderRow.font = {\n            bold: true,\n            color: {\n                argb: \"FFFFFFFF\"\n            }\n        };\n        transHeaderRow.fill = {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"FF4472C4\"\n            }\n        };\n        // Dados das transações\n        processedData.transactions.forEach((transaction)=>{\n            const tipo = transaction.valorNumerico > 0 ? \"A Pagar\" : \"A Receber\";\n            worksheet.addRow([\n                transaction.vencimento,\n                transaction.transacionador,\n                transaction.documento,\n                transaction.valor,\n                tipo\n            ]);\n        });\n    } else {\n        // Mensagem quando não há transações detalhadas\n        const noDataRow = worksheet.addRow([\n            \"TRANSA\\xc7\\xd5ES DETALHADAS\"\n        ]);\n        worksheet.mergeCells(`A${worksheet.rowCount}:D${worksheet.rowCount}`);\n        noDataRow.getCell(1).font = {\n            bold: true,\n            size: 12\n        };\n        noDataRow.getCell(1).fill = {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"FFE0E0E0\"\n            }\n        };\n        noDataRow.getCell(1).alignment = {\n            horizontal: \"center\"\n        };\n        worksheet.addRow([]); // Linha vazia\n        worksheet.addRow([\n            \"Dados detalhados das transa\\xe7\\xf5es ser\\xe3o exibidos aqui quando dispon\\xedveis.\"\n        ]);\n        worksheet.addRow([\n            \"Para obter detalhes, fa\\xe7a upload dos arquivos CSV individuais.\"\n        ]);\n    }\n    // Ajustar largura das colunas\n    worksheet.columns = [\n        {\n            width: 15\n        },\n        {\n            width: 25\n        },\n        {\n            width: 15\n        },\n        {\n            width: 18\n        },\n        {\n            width: 12\n        } // Tipo\n    ];\n    // Adicionar bordas nas células importantes\n    const allRows = worksheet.getRows(1, worksheet.rowCount);\n    allRows?.forEach((row)=>{\n        row.eachCell((cell)=>{\n            if (cell.value) {\n                cell.border = {\n                    top: {\n                        style: \"thin\"\n                    },\n                    left: {\n                        style: \"thin\"\n                    },\n                    bottom: {\n                        style: \"thin\"\n                    },\n                    right: {\n                        style: \"thin\"\n                    }\n                };\n            }\n        });\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFBQztTQUEwRTtRQUM1RnVDLFVBQVV2QyxNQUFNLENBQUM7WUFBQztTQUFpRTtJQUNyRjtJQUVBLDhCQUE4QjtJQUM5QnVDLFVBQVVZLE9BQU8sR0FBRztRQUNsQjtZQUFFbkIsT0FBTztRQUFHO1FBQ1o7WUFBRUEsT0FBTztRQUFHO1FBQ1o7WUFBRUEsT0FBTztRQUFHO1FBQ1o7WUFBRUEsT0FBTztRQUFHO1FBQ1o7WUFBRUEsT0FBTztRQUFHLEVBQUcsT0FBTztLQUN2QjtJQUVELDJDQUEyQztJQUMzQyxNQUFNOEIsVUFBVXZCLFVBQVVtQixPQUFPLENBQUMsR0FBR25CLFVBQVVvQixRQUFRO0lBQ3ZERyxTQUFTbkwsUUFBUWdKLENBQUFBO1FBQ2ZBLElBQUlwQixRQUFRLENBQUNDLENBQUFBO1lBQ1gsSUFBSUEsS0FBS2hHLEtBQUssRUFBRTtnQkFDZGdHLEtBQUtwSyxNQUFNLEdBQUc7b0JBQ1pDLEtBQUs7d0JBQUVDLE9BQU87b0JBQU87b0JBQ3JCQyxNQUFNO3dCQUFFRCxPQUFPO29CQUFPO29CQUN0QkUsUUFBUTt3QkFBRUYsT0FBTztvQkFBTztvQkFDeEJHLE9BQU87d0JBQUVILE9BQU87b0JBQU87Z0JBQ3pCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3RhZmxleC1uZXh0anMvLi9wYWdlcy9hcGkvZXhwb3J0LWV4Y2VsLnRzPzdkYTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCdcclxuaW1wb3J0IEV4Y2VsSlMgZnJvbSAnZXhjZWxqcydcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xyXG5cclxuLy8gSW50ZXJmYWNlIHBhcmEgZGFkb3MgZGUgaW52b2ljZSBpbmRpdmlkdWFsXHJcbmludGVyZmFjZSBJbnZvaWNlRGF0YSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBicmFuY2g6IHN0cmluZztcclxuICBpbnZvaWNlTnVtYmVyOiBzdHJpbmc7XHJcbiAgZGF0ZTogRGF0ZTtcclxuICB2YWx1ZTogc3RyaW5nO1xyXG4gIHN1cHBsaWVyOiBzdHJpbmc7XHJcbiAgZG9jdW1lbnRUeXBlOiAnQV9QQUdBUicgfCAnQV9SRUNFQkVSJztcclxuICBzb3VyY2VGaWxlOiBzdHJpbmc7XHJcbiAgdmFsdWVOdW1lcmljOiBudW1iZXI7XHJcbn1cclxuXHJcbi8vIEludGVyZmFjZSBwYXJhIGRhZG9zIGRlIHJlc3VtbyBwb3IgZmlsaWFsXHJcbmludGVyZmFjZSBCcmFuY2hEYXRhIHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgdG90YWxBUGFnYXI6IG51bWJlcjtcclxuICB0b3RhbEFSZWNlYmVyOiBudW1iZXI7XHJcbiAgdG90YWw6IG51bWJlcjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFN1bW1hcnlEYXRhIHtcclxuICBicmFuY2hlczogQnJhbmNoRGF0YVtdO1xyXG4gIGRhdGVTcGVjaWZpY1RvdGFsczogQXJyYXk8eyBkYXk6IHN0cmluZzsgdG90YWw6IG51bWJlciB9PjtcclxuICBncmFuZFRvdGFsOiBudW1iZXI7XHJcbiAgZ3JhbmRUb3RhbEFQYWdhcjogbnVtYmVyO1xyXG4gIGdyYW5kVG90YWxBUmVjZWJlcjogbnVtYmVyO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQnJhbmNoU3VtbWFyeSB7XHJcbiAgYnJhbmNoOiBzdHJpbmc7XHJcbiAgaW52b2ljZUNvdW50OiBudW1iZXI7XHJcbiAgdG90YWxWYWx1ZTogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25EYXRhIHtcclxuICB2ZW5jaW1lbnRvOiBzdHJpbmc7XHJcbiAgdHJhbnNhY2lvbmFkb3I6IHN0cmluZztcclxuICBkb2N1bWVudG86IHN0cmluZztcclxuICB2YWxvcjogc3RyaW5nO1xyXG4gIHZhbG9yTnVtZXJpY286IG51bWJlcjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFByb2Nlc3NlZERhdGEge1xyXG4gIGJyYW5jaDogc3RyaW5nO1xyXG4gIHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25EYXRhW107XHJcbiAgdG90YWxBUGFnYXI6IG51bWJlcjtcclxuICB0b3RhbEFSZWNlYmVyOiBudW1iZXI7XHJcbiAgc3VtbWFyeTogQnJhbmNoRGF0YTtcclxufVxyXG5cclxuLy8gVXRpbGl0w6FyaW8gc2VndXJvIHBhcmEgcGFyc2UgZGUgZGF0YXMgREQvTU0vQUFBQVxyXG5mdW5jdGlvbiBwYXJzZVB0QnJEYXRlKGRhdGVTdHI6IHN0cmluZyB8IERhdGUpOiBEYXRlIHtcclxuICBpZiAoZGF0ZVN0ciBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBkYXRlU3RyO1xyXG4gIGlmICh0eXBlb2YgZGF0ZVN0ciAhPT0gJ3N0cmluZycpIHJldHVybiBuZXcgRGF0ZSgpO1xyXG4gIGNvbnN0IHRyaW1tZWQgPSBkYXRlU3RyLnRyaW0oKTtcclxuICBjb25zdCBtID0gdHJpbW1lZC5tYXRjaCgvXihcXGR7MSwyfSlcXC8oXFxkezEsMn0pXFwvKFxcZHs0fSkkLyk7XHJcbiAgaWYgKG0pIHtcclxuICAgIGNvbnN0IGQgPSBwYXJzZUludChtWzFdLCAxMCk7XHJcbiAgICBjb25zdCBtbyA9IHBhcnNlSW50KG1bMl0sIDEwKSAtIDE7XHJcbiAgICBjb25zdCB5ID0gcGFyc2VJbnQobVszXSwgMTApO1xyXG4gICAgY29uc3QgZHQgPSBuZXcgRGF0ZSh5LCBtbywgZCk7XHJcbiAgICAvLyBWYWxpZGFyIChEYXRlIGF1dG8gY29ycmlnZSBvdmVyZmxvdzsgcHJlY2lzYW1vcyBnYXJhbnRpciBpbnRlZ3JpZGFkZSlcclxuICAgIGlmIChkdC5nZXRGdWxsWWVhcigpID09PSB5ICYmIGR0LmdldE1vbnRoKCkgPT09IG1vICYmIGR0LmdldERhdGUoKSA9PT0gZCkge1xyXG4gICAgICByZXR1cm4gZHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIFRlbnRhciBmYWxsYmFjayBJU09cclxuICBjb25zdCBpc28gPSBuZXcgRGF0ZSh0cmltbWVkKTtcclxuICBpZiAoIWlzTmFOKGlzby5nZXRUaW1lKCkpKSByZXR1cm4gaXNvO1xyXG4gIHJldHVybiBuZXcgRGF0ZSgpOyAvLyBmYWxsYmFjayBzZWd1cm9cclxufVxyXG5cclxuLy8gRXN0aWxvcyBFeGNlbCBvYnJpZ2F0w7NyaW9zXHJcbmNvbnN0IGhlYWRlclN0eWxlID0ge1xyXG4gIGZvbnQ6IHsgYm9sZDogdHJ1ZSwgY29sb3I6IHsgYXJnYjogJ0ZGRkZGRicgfSB9LFxyXG4gIGZpbGw6IHsgdHlwZTogJ3BhdHRlcm4nIGFzIGNvbnN0LCBwYXR0ZXJuOiAnc29saWQnIGFzIGNvbnN0LCBmZ0NvbG9yOiB7IGFyZ2I6ICcyRjU1OTcnIH0gfSxcclxuICBhbGlnbm1lbnQ6IHsgaG9yaXpvbnRhbDogJ2NlbnRlcicgYXMgY29uc3QsIHZlcnRpY2FsOiAnbWlkZGxlJyBhcyBjb25zdCB9LFxyXG4gIGJvcmRlcjoge1xyXG4gICAgdG9wOiB7IHN0eWxlOiAndGhpbicgYXMgY29uc3QgfSxcclxuICAgIGxlZnQ6IHsgc3R5bGU6ICd0aGluJyBhcyBjb25zdCB9LFxyXG4gICAgYm90dG9tOiB7IHN0eWxlOiAndGhpbicgYXMgY29uc3QgfSxcclxuICAgIHJpZ2h0OiB7IHN0eWxlOiAndGhpbicgYXMgY29uc3QgfVxyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNlbGxTdHlsZSA9IHtcclxuICBib3JkZXI6IHtcclxuICAgIHRvcDogeyBzdHlsZTogJ3RoaW4nIGFzIGNvbnN0IH0sXHJcbiAgICBsZWZ0OiB7IHN0eWxlOiAndGhpbicgYXMgY29uc3QgfSxcclxuICAgIGJvdHRvbTogeyBzdHlsZTogJ3RoaW4nIGFzIGNvbnN0IH0sXHJcbiAgICByaWdodDogeyBzdHlsZTogJ3RoaW4nIGFzIGNvbnN0IH1cclxuICB9XHJcbn07XHJcblxyXG5jb25zdCB0aXRsZVN0eWxlID0ge1xyXG4gIGZvbnQ6IHsgYm9sZDogdHJ1ZSwgc2l6ZTogMTYsIGNvbG9yOiB7IGFyZ2I6ICdGRkZGRkYnIH0gfSxcclxuICBhbGlnbm1lbnQ6IHsgaG9yaXpvbnRhbDogJ2NlbnRlcicgYXMgY29uc3QsIHZlcnRpY2FsOiAnbWlkZGxlJyBhcyBjb25zdCB9LFxyXG4gIGZpbGw6IHsgdHlwZTogJ3BhdHRlcm4nIGFzIGNvbnN0LCBwYXR0ZXJuOiAnc29saWQnIGFzIGNvbnN0LCBmZ0NvbG9yOiB7IGFyZ2I6ICcyRjU1OTcnIH0gfVxyXG59O1xyXG5cclxuY29uc3Qgc3ViSGVhZGVyU3R5bGUgPSB7XHJcbiAgZm9udDogeyBib2xkOiB0cnVlLCBzaXplOiAxNCwgY29sb3I6IHsgYXJnYjogJ0ZGRkZGRicgfSB9LFxyXG4gIGZpbGw6IHsgdHlwZTogJ3BhdHRlcm4nIGFzIGNvbnN0LCBwYXR0ZXJuOiAnc29saWQnIGFzIGNvbnN0LCBmZ0NvbG9yOiB7IGFyZ2I6ICcxRjRFNzknIH0gfSxcclxuICBhbGlnbm1lbnQ6IHsgaG9yaXpvbnRhbDogJ2NlbnRlcicgYXMgY29uc3QsIHZlcnRpY2FsOiAnbWlkZGxlJyBhcyBjb25zdCB9XHJcbn07XHJcblxyXG5jb25zdCB0b3RhbFJvd1N0eWxlID0ge1xyXG4gIGZvbnQ6IHsgYm9sZDogdHJ1ZSwgY29sb3I6IHsgYXJnYjogJ0ZGRkZGRicgfSB9LFxyXG4gIGZpbGw6IHsgdHlwZTogJ3BhdHRlcm4nIGFzIGNvbnN0LCBwYXR0ZXJuOiAnc29saWQnIGFzIGNvbnN0LCBmZ0NvbG9yOiB7IGFyZ2I6ICczNjYwOTInIH0gfSxcclxuICBhbGlnbm1lbnQ6IHsgaG9yaXpvbnRhbDogJ2NlbnRlcicgYXMgY29uc3QsIHZlcnRpY2FsOiAnbWlkZGxlJyBhcyBjb25zdCB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxyXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXHJcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2VcclxuKSB7XHJcbiAgY29uc29sZS5sb2coJz09PSBJTklDSUFORE8gRVhQT1JULUVYQ0VMID09PScpXHJcbiAgY29uc29sZS5sb2coJ01ldGhvZDonLCByZXEubWV0aG9kKVxyXG4gIGNvbnNvbGUubG9nKCdIZWFkZXJzOicsIHJlcS5oZWFkZXJzKVxyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICAvLyBFeHRyYWlyIGluZm9ybWHDp8O1ZXMgZG8gcmVsYXTDs3JpbyBjb20gcHJvdGXDp8OjbyBjYXNvIGJvZHkgc2VqYSB1bmRlZmluZWRcclxuICAgIGNvbnN0IGJvZHkgPSAocmVxIGFzIGFueSkuYm9keSB8fCB7fTtcclxuICAgIGNvbnNvbGUubG9nKCdCb2R5IGtleXM6JywgT2JqZWN0LmtleXMoYm9keSkpO1xyXG4gICAgY29uc29sZS5sb2coJ0JvZHkgdHlwZTonLCB0eXBlb2YgYm9keSk7XHJcbiAgICBjb25zdCB7IG5hbWU6IHJlcG9ydE5hbWUsIHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgY2F0ZWdvcmllcywgcHJvY2Vzc2VkRGF0YSB9ID0gYm9keTtcclxuICAgIFxyXG4gICAgbGV0IHN1bW1hcnlEYXRhOiBTdW1tYXJ5RGF0YSB8IG51bGwgPSBudWxsO1xyXG4gICAgbGV0IGFsbEludm9pY2VzOiBJbnZvaWNlRGF0YVtdID0gW107XHJcbiAgICBsZXQgYWxsQnJhbmNoU3VtbWFyaWVzOiBCcmFuY2hTdW1tYXJ5W10gPSBbXTtcclxuXHJcbiAgICAvLyBWZXJpZmljYXIgc2UgZXhpc3RlIGRhZG9zIHByb2Nlc3NhZG9zIHJlYWlzIGRvIHVwbG9hZC1jc3ZcclxuICAgIGlmIChyZXEubWV0aG9kID09PSAnUE9TVCcpIHtcclxuICAgICAgY29uc29sZS5sb2coJz09PSBEQURPUyBSRUNFQklET1MgTk8gRVhQT1JULUVYQ0VMID09PScpO1xyXG4gICAgICBjb25zb2xlLmxvZygnSGFzIHByb2Nlc3NlZERhdGE6JywgISFib2R5LnByb2Nlc3NlZERhdGEpO1xyXG4gICAgICBcclxuICAgICAgaWYgKGJvZHkucHJvY2Vzc2VkRGF0YSAmJiBBcnJheS5pc0FycmF5KGJvZHkucHJvY2Vzc2VkRGF0YS50cmFuc2FjdGlvbnMpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJz09PSBVU0FORE8gREFET1MgUkVBSVMgRE8gVVBMT0FEID09PScpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUb3RhbCB0cmFuc2FjdGlvbnM6JywgYm9keS5wcm9jZXNzZWREYXRhLnRyYW5zYWN0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdQcmltZWlyYXMgdHJhbnNhw6fDtWVzOicsIGJvZHkucHJvY2Vzc2VkRGF0YS50cmFuc2FjdGlvbnMuc2xpY2UoMCwgMykpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENvbnZlcnRlciBkYWRvcyByZWFpcyBwYXJhIGZvcm1hdG8gZXNwZXJhZG8gcGVsbyBFeGNlbFxyXG4gICAgICAgIGNvbnN0IHJlYWxEYXRhID0gYm9keS5wcm9jZXNzZWREYXRhO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFncnVwYXIgdHJhbnNhw6fDtWVzIHBvciBmaWxpYWwgcGFyYSBjcmlhciBzdW1tYXJ5RGF0YVxyXG4gICAgICAgIGNvbnN0IGJyYW5jaE1hcCA9IG5ldyBNYXA8c3RyaW5nLCB7dG90YWxBUGFnYXI6IG51bWJlciwgdG90YWxBUmVjZWJlcjogbnVtYmVyfT4oKTtcclxuICAgICAgICBjb25zdCBhbGxUcmFuc2FjdGlvbnM6IEludm9pY2VEYXRhW10gPSBbXTtcclxuICAgICAgICBcclxuICAgICAgICByZWFsRGF0YS50cmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb246IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0VYUE9SVF0gVHJhbnNhw6fDo28gbnVsYSBlbmNvbnRyYWRhIG5vIMOtbmRpY2U6JywgaW5kZXgpO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0VYUE9SVF0gUHJvY2Vzc2FuZG8gdHJhbnNhw6fDo28gJHtpbmRleH06YCwge1xyXG4gICAgICAgICAgICAgIHZlbmNpbWVudG86IHRyYW5zYWN0aW9uLnZlbmNpbWVudG8sXHJcbiAgICAgICAgICAgICAgdHJhbnNhY2lvbmFkb3I6IHRyYW5zYWN0aW9uLnRyYW5zYWNpb25hZG9yLFxyXG4gICAgICAgICAgICAgIHZhbG9yOiB0cmFuc2FjdGlvbi52YWxvck51bWVyaWNvLFxyXG4gICAgICAgICAgICAgIHRpcG86IHRyYW5zYWN0aW9uLmRvY3VtZW50VHlwZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGJyYW5jaCA9IHRyYW5zYWN0aW9uLmZpbGlhbCB8fCByZWFsRGF0YS5icmFuY2hUb3RhbHM/LlswXT8uYnJhbmNoIHx8ICdGSUxJQUwgUFJJTkNJUEFMJztcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlRmlsZSA9IHRyYW5zYWN0aW9uLnNvdXJjZUZpbGUgfHwgYCR7YnJhbmNofS5jc3ZgO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFicmFuY2hNYXAuaGFzKGJyYW5jaCkpIHtcclxuICAgICAgICAgICAgICBicmFuY2hNYXAuc2V0KGJyYW5jaCwge3RvdGFsQVBhZ2FyOiAwLCB0b3RhbEFSZWNlYmVyOiAwfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGJyYW5jaERhdGEgPSBicmFuY2hNYXAuZ2V0KGJyYW5jaCkhO1xyXG4gICAgICAgICAgICBjb25zdCB2YWxvck51bWVyaWNvID0gdHJhbnNhY3Rpb24udmFsb3JOdW1lcmljbyB8fCAwO1xyXG4gICAgICAgICAgICAvLyBVc2FyIHRpcG8gdmluZG8gZG8gcHJvY2Vzc2FtZW50byAodmFsb3IgZGVmYXVsdCBBX1BBR0FSIGNhc28gYXVzZW50ZSlcclxuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRUeXBlOiAnQV9QQUdBUicgfCAnQV9SRUNFQkVSJyA9IHRyYW5zYWN0aW9uLmRvY3VtZW50VHlwZSA9PT0gJ0FfUkVDRUJFUicgPyAnQV9SRUNFQkVSJyA6ICdBX1BBR0FSJztcclxuXHJcbiAgICAgICAgICAgIC8vIFBhcnNlIGRhdGEgcm9idXN0b1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRlID0gcGFyc2VQdEJyRGF0ZSh0cmFuc2FjdGlvbi52ZW5jaW1lbnRvKTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlZERhdGUuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0VYUE9SVF0gSWdub3JhbmRvIHRyYW5zYcOnw6NvIGNvbSBkYXRhIGludsOhbGlkYTonLCB0cmFuc2FjdGlvbi52ZW5jaW1lbnRvLCB0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsb3JOdW1lcmljbyAhPT0gJ251bWJlcicgfHwgaXNOYU4oTnVtYmVyKHZhbG9yTnVtZXJpY28pKSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0VYUE9SVF0gSWdub3JhbmRvIHRyYW5zYcOnw6NvIGNvbSB2YWxvciBpbnbDoWxpZG86JywgdmFsb3JOdW1lcmljbywgdHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoZG9jdW1lbnRUeXBlID09PSAnQV9QQUdBUicpIHtcclxuICAgICAgICAgICAgYnJhbmNoRGF0YS50b3RhbEFQYWdhciArPSBNYXRoLmFicyh2YWxvck51bWVyaWNvKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJyYW5jaERhdGEudG90YWxBUmVjZWJlciArPSBNYXRoLmFicyh2YWxvck51bWVyaWNvKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ29udmVydGVyIHBhcmEgZm9ybWF0byBJbnZvaWNlRGF0YVxyXG4gICAgICAgICAgYWxsVHJhbnNhY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICBpZDogYHJlYWxfJHtpbmRleH1gLFxyXG4gICAgICAgICAgICBicmFuY2g6IGJyYW5jaCxcclxuICAgICAgICAgICAgaW52b2ljZU51bWJlcjogdHJhbnNhY3Rpb24uZG9jdW1lbnRvIHx8IGBET0MtJHtpbmRleH1gLFxyXG4gICAgICAgICAgICBkYXRlOiBwYXJzZWREYXRlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdHJhbnNhY3Rpb24udmFsb3IgfHwgYFIkIDAsMDBgLFxyXG4gICAgICAgICAgICBzdXBwbGllcjogdHJhbnNhY3Rpb24udHJhbnNhY2lvbmFkb3IgfHwgJ0ZPUk5FQ0VET1IgTsODTyBJREVOVElGSUNBRE8nLFxyXG4gICAgICAgICAgICBkb2N1bWVudFR5cGU6IGRvY3VtZW50VHlwZSxcclxuICAgICAgICAgICAgc291cmNlRmlsZTogc291cmNlRmlsZSxcclxuICAgICAgICAgICAgdmFsdWVOdW1lcmljOiBNYXRoLmFicyh2YWxvck51bWVyaWNvKVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGNhdGNoICh0cmFuc2FjdGlvbkVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbRVhQT1JUXSBFcnJvIGFvIHByb2Nlc3NhciB0cmFuc2HDp8OjbzonLCBpbmRleCwgdHJhbnNhY3Rpb25FcnIsIHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDcmlhciBzdW1tYXJ5RGF0YSBhIHBhcnRpciBkb3MgZGFkb3MgcmVhaXNcclxuICAgICAgICBjb25zdCBicmFuY2hlcyA9IEFycmF5LmZyb20oYnJhbmNoTWFwLmVudHJpZXMoKSkubWFwKChbbmFtZSwgdG90YWxzXSkgPT4gKHtcclxuICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICB0b3RhbEFQYWdhcjogdG90YWxzLnRvdGFsQVBhZ2FyLFxyXG4gICAgICAgICAgdG90YWxBUmVjZWJlcjogdG90YWxzLnRvdGFsQVJlY2ViZXIsXHJcbiAgICAgICAgICB0b3RhbDogdG90YWxzLnRvdGFsQVBhZ2FyICsgdG90YWxzLnRvdGFsQVJlY2ViZXJcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3VtbWFyeURhdGEgPSB7XHJcbiAgICAgICAgICBicmFuY2hlcyxcclxuICAgICAgICAgIGRhdGVTcGVjaWZpY1RvdGFsczogW10sXHJcbiAgICAgICAgICBncmFuZFRvdGFsOiBicmFuY2hlcy5yZWR1Y2UoKHN1bSwgYikgPT4gc3VtICsgYi50b3RhbCwgMCksXHJcbiAgICAgICAgICBncmFuZFRvdGFsQVBhZ2FyOiBicmFuY2hlcy5yZWR1Y2UoKHN1bSwgYikgPT4gc3VtICsgYi50b3RhbEFQYWdhciwgMCksXHJcbiAgICAgICAgICBncmFuZFRvdGFsQVJlY2ViZXI6IGJyYW5jaGVzLnJlZHVjZSgoc3VtLCBiKSA9PiBzdW0gKyBiLnRvdGFsQVJlY2ViZXIsIDApXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBhbGxJbnZvaWNlcyA9IGFsbFRyYW5zYWN0aW9ucztcclxuICAgICAgICBhbGxCcmFuY2hTdW1tYXJpZXMgPSBicmFuY2hlcy5tYXAoYnJhbmNoID0+ICh7XHJcbiAgICAgICAgICBicmFuY2g6IGJyYW5jaC5uYW1lLFxyXG4gICAgICAgICAgaW52b2ljZUNvdW50OiBhbGxUcmFuc2FjdGlvbnMuZmlsdGVyKGludiA9PiBpbnYuYnJhbmNoID09PSBicmFuY2gubmFtZSkubGVuZ3RoLFxyXG4gICAgICAgICAgdG90YWxWYWx1ZTogYnJhbmNoLnRvdGFsLnRvTG9jYWxlU3RyaW5nKCdwdC1CUicsIHsgc3R5bGU6ICdjdXJyZW5jeScsIGN1cnJlbmN5OiAnQlJMJyB9KVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZygnPT09IERBRE9TIENPTlZFUlRJRE9TID09PScpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdCcmFuY2hlcyBjcmlhZGFzOicsIGJyYW5jaGVzLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1RvdGFsIGludm9pY2VzOicsIGFsbEludm9pY2VzLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1N1bW1hcnkgZ3JhbmRUb3RhbDonLCBzdW1tYXJ5RGF0YS5ncmFuZFRvdGFsKTtcclxuICAgICAgfSBlbHNlIGlmIChib2R5LnN1bW1hcnlEYXRhKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJz09PSBVU0FORE8gREFET1MgRk9STkVDSURPUyBOTyBCT0RZID09PScpO1xyXG4gICAgICAgIHN1bW1hcnlEYXRhID0gYm9keS5zdW1tYXJ5RGF0YTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBUZW50YXRpdmEgZGUgZmFsbGJhY2s6IGNhcnJlZ2FyIGNhY2hlIGRlIHVwbG9hZC1jc3ZcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgY2FjaGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICd0ZW1wJywgJ2xhc3RfcHJvY2Vzc2VkLmpzb24nKTtcclxuICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGNhY2hlUGF0aCkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NhcnJlZ2FuZG8gcHJvY2Vzc2VkRGF0YSBkbyBjYWNoZSBsb2NhbCAobGFzdF9wcm9jZXNzZWQuanNvbiknKTtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoY2FjaGVQYXRoLCAndXRmOCcpKTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQudHJhbnNhY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgYm9keS5wcm9jZXNzZWREYXRhID0gY2FjaGVkOyAvLyByZXRlciBlbSBtZW3Ds3JpYSBsb2NhbFxyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWludm9jYW5kbyBwcm9jZXNzYW1lbnRvIGNvbSBjYWNoZScpO1xyXG4gICAgICAgICAgICAgIC8vIEZvcsOnYXIgcGVxdWVuYSByZWN1cnPDo28gbMOzZ2ljYSBtYW51YWw6IGR1cGxpY2FyIGJsb2NvIHNlbSByZWN1cnPDo28gSFRUUFxyXG4gICAgICAgICAgICAgIGNvbnN0IHJlYWxEYXRhID0gY2FjaGVkO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGJyYW5jaE1hcCA9IG5ldyBNYXA8c3RyaW5nLCB7dG90YWxBUGFnYXI6IG51bWJlciwgdG90YWxBUmVjZWJlcjogbnVtYmVyfT4oKTtcclxuICAgICAgICAgICAgICBjb25zdCBhbGxUcmFuc2FjdGlvbnM6IEludm9pY2VEYXRhW10gPSBbXTtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVhbERhdGEudHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0VYUE9SVF1bQ0FDSEVdIFByb2Nlc3NhbmRvIHRyYW5zYcOnw6NvICR7aW5kZXh9OmAsIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZlbmNpbWVudG86IHRyYW5zYWN0aW9uLnZlbmNpbWVudG8sXHJcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjaW9uYWRvcjogdHJhbnNhY3Rpb24udHJhbnNhY2lvbmFkb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWxvck51bWVyaWNvOiB0cmFuc2FjdGlvbi52YWxvck51bWVyaWNvXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbikgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJyYW5jaCA9IHRyYW5zYWN0aW9uLmZpbGlhbCB8fCByZWFsRGF0YS5icmFuY2hUb3RhbHM/LlswXT8uYnJhbmNoIHx8ICdGSUxJQUwgUFJJTkNJUEFMJztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VGaWxlID0gdHJhbnNhY3Rpb24uc291cmNlRmlsZSB8fCBgJHticmFuY2h9LmNzdmA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFicmFuY2hNYXAuaGFzKGJyYW5jaCkpIGJyYW5jaE1hcC5zZXQoYnJhbmNoLCB7dG90YWxBUGFnYXI6IDAsIHRvdGFsQVJlY2ViZXI6IDB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBicmFuY2hEYXRhID0gYnJhbmNoTWFwLmdldChicmFuY2gpITtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxvck51bWVyaWNvID0gdHJhbnNhY3Rpb24udmFsb3JOdW1lcmljbyB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50VHlwZTogJ0FfUEFHQVInIHwgJ0FfUkVDRUJFUicgPSB0cmFuc2FjdGlvbi5kb2N1bWVudFR5cGUgPT09ICdBX1JFQ0VCRVInID8gJ0FfUkVDRUJFUicgOiAnQV9QQUdBUic7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IHBhcnNlUHRCckRhdGUodHJhbnNhY3Rpb24udmVuY2ltZW50byk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlZERhdGUuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbRVhQT1JUXVtDQUNIRV0gSWdub3JhbmRvIHRyYW5zYcOnw6NvIGNvbSBkYXRhIGludsOhbGlkYTonLCB0cmFuc2FjdGlvbi52ZW5jaW1lbnRvKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWxvck51bWVyaWNvICE9PSAnbnVtYmVyJyB8fCBpc05hTihOdW1iZXIodmFsb3JOdW1lcmljbykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tFWFBPUlRdW0NBQ0hFXSBJZ25vcmFuZG8gdHJhbnNhw6fDo28gY29tIHZhbG9yIGludsOhbGlkbzonLCB2YWxvck51bWVyaWNvKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50VHlwZSA9PT0gJ0FfUEFHQVInKSBicmFuY2hEYXRhLnRvdGFsQVBhZ2FyICs9IE1hdGguYWJzKHZhbG9yTnVtZXJpY28pOyBlbHNlIGJyYW5jaERhdGEudG90YWxBUmVjZWJlciArPSBNYXRoLmFicyh2YWxvck51bWVyaWNvKTtcclxuICAgICAgICAgICAgICAgICAgICBhbGxUcmFuc2FjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZDogYHJlYWxfJHtpbmRleH1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgYnJhbmNoOiBicmFuY2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICBpbnZvaWNlTnVtYmVyOiB0cmFuc2FjdGlvbi5kb2N1bWVudG8gfHwgYERPQy0ke2luZGV4fWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBwYXJzZWREYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRyYW5zYWN0aW9uLnZhbG9yIHx8IGBSJCAwLDAwYCxcclxuICAgICAgICAgICAgICAgICAgICAgIHN1cHBsaWVyOiB0cmFuc2FjdGlvbi50cmFuc2FjaW9uYWRvciB8fCAnRk9STkVDRURPUiBOw4NPIElERU5USUZJQ0FETycsXHJcbiAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFR5cGU6IGRvY3VtZW50VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpbGU6IHNvdXJjZUZpbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZU51bWVyaWM6IE1hdGguYWJzKHZhbG9yTnVtZXJpY28pXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHRyYW5zYWN0aW9uRXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW0VYUE9SVF1bQ0FDSEVdIEVycm8gYW8gcHJvY2Vzc2FyIHRyYW5zYcOnw6NvICR7aW5kZXh9OmAsIHRyYW5zYWN0aW9uRXJyKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAodHJhbnNhY3Rpb25zRXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbRVhQT1JUXVtDQUNIRV0gRXJybyBhbyBwcm9jZXNzYXIgdHJhbnNhw6fDtWVzIGRvIGNhY2hlOicsIHRyYW5zYWN0aW9uc0Vycik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNvbnN0IGJyYW5jaGVzID0gQXJyYXkuZnJvbShicmFuY2hNYXAuZW50cmllcygpKS5tYXAoKFtuYW1lLCB0b3RhbHNdKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgIHRvdGFsQVBhZ2FyOiB0b3RhbHMudG90YWxBUGFnYXIsXHJcbiAgICAgICAgICAgICAgICB0b3RhbEFSZWNlYmVyOiB0b3RhbHMudG90YWxBUmVjZWJlcixcclxuICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbHMudG90YWxBUGFnYXIgKyB0b3RhbHMudG90YWxBUmVjZWJlclxyXG4gICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICBzdW1tYXJ5RGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGJyYW5jaGVzLFxyXG4gICAgICAgICAgICAgICAgZGF0ZVNwZWNpZmljVG90YWxzOiBbXSxcclxuICAgICAgICAgICAgICAgIGdyYW5kVG90YWw6IGJyYW5jaGVzLnJlZHVjZSgoc3VtLCBiKSA9PiBzdW0gKyBiLnRvdGFsLCAwKSxcclxuICAgICAgICAgICAgICAgIGdyYW5kVG90YWxBUGFnYXI6IGJyYW5jaGVzLnJlZHVjZSgoc3VtLCBiKSA9PiBzdW0gKyBiLnRvdGFsQVBhZ2FyLCAwKSxcclxuICAgICAgICAgICAgICAgIGdyYW5kVG90YWxBUmVjZWJlcjogYnJhbmNoZXMucmVkdWNlKChzdW0sIGIpID0+IHN1bSArIGIudG90YWxBUmVjZWJlciwgMClcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIGFsbEludm9pY2VzID0gYWxsVHJhbnNhY3Rpb25zO1xyXG4gICAgICAgICAgICAgIGFsbEJyYW5jaFN1bW1hcmllcyA9IGJyYW5jaGVzLm1hcChicmFuY2ggPT4gKHtcclxuICAgICAgICAgICAgICAgIGJyYW5jaDogYnJhbmNoLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBpbnZvaWNlQ291bnQ6IGFsbFRyYW5zYWN0aW9ucy5maWx0ZXIoaW52ID0+IGludi5icmFuY2ggPT09IGJyYW5jaC5uYW1lKS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB0b3RhbFZhbHVlOiBicmFuY2gudG90YWwudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywgeyBzdHlsZTogJ2N1cnJlbmN5JywgY3VycmVuY3k6ICdCUkwnIH0pXHJcbiAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoY2FjaGVFcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignRmFsaGEgYW8gY2FycmVnYXIgY2FjaGUgZGUgcHJvY2Vzc2VkRGF0YTonLCBjYWNoZUVycik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoYm9keS5hbGxJbnZvaWNlcykge1xyXG4gICAgICAgIGFsbEludm9pY2VzID0gYm9keS5hbGxJbnZvaWNlcztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKGJvZHkuYWxsQnJhbmNoU3VtbWFyaWVzKSB7XHJcbiAgICAgICAgYWxsQnJhbmNoU3VtbWFyaWVzID0gYm9keS5hbGxCcmFuY2hTdW1tYXJpZXM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZSBuw6NvIHRlbW9zIGRhZG9zLCB1c2FyIGRhZG9zIGhhcmRjb2RlZCBwYXJhIGRlbW9uc3RyYcOnw6NvXHJcbiAgICBpZiAoIXN1bW1hcnlEYXRhIHx8ICFzdW1tYXJ5RGF0YS5icmFuY2hlcyB8fCBzdW1tYXJ5RGF0YS5icmFuY2hlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coJ1VzYW5kbyBkYWRvcyBoYXJkY29kZWQgcGFyYSBkZW1vbnN0cmHDp8OjbycpO1xyXG4gICAgICBzdW1tYXJ5RGF0YSA9IHtcclxuICAgICAgICBicmFuY2hlczogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnR08gU0VFRFMnLFxyXG4gICAgICAgICAgICB0b3RhbEFQYWdhcjogMTkxMjA0MC4wMCxcclxuICAgICAgICAgICAgdG90YWxBUmVjZWJlcjogMzE3NTk5MC4zNixcclxuICAgICAgICAgICAgdG90YWw6IDUwODcwMzAuMzZcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdCRUlKQSBGTE9SJyxcclxuICAgICAgICAgICAgdG90YWxBUGFnYXI6IDEyOTc2My4yNCxcclxuICAgICAgICAgICAgdG90YWxBUmVjZWJlcjogMC4wMCxcclxuICAgICAgICAgICAgdG90YWw6IDEyOTc2My4yNFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NBR1VJQScsXHJcbiAgICAgICAgICAgIHRvdGFsQVBhZ2FyOiAxMzgyNTEuMTAsXHJcbiAgICAgICAgICAgIHRvdGFsQVJlY2ViZXI6IDAuMDAsXHJcbiAgICAgICAgICAgIHRvdGFsOiAxMzgyNTEuMTBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdVTFRSQSBTRUVEUycsXHJcbiAgICAgICAgICAgIHRvdGFsQVBhZ2FyOiA4MC45NixcclxuICAgICAgICAgICAgdG90YWxBUmVjZWJlcjogMC4wMCxcclxuICAgICAgICAgICAgdG90YWw6IDgwLjk2XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkYXRlU3BlY2lmaWNUb3RhbHM6IFtcclxuICAgICAgICAgIHsgZGF5OiAnMTUvMDkvMjAyNCcsIHRvdGFsOiA1MDAwMDAuMDAgfSxcclxuICAgICAgICAgIHsgZGF5OiAnMTYvMDkvMjAyNCcsIHRvdGFsOiA3NTAwMDAuMDAgfSxcclxuICAgICAgICAgIHsgZGF5OiAnMTcvMDkvMjAyNCcsIHRvdGFsOiA5NTAwMDAuMDAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZ3JhbmRUb3RhbDogNTM1NTEzNS42NixcclxuICAgICAgICBncmFuZFRvdGFsQVBhZ2FyOiAyMTgwMTM1LjMwLFxyXG4gICAgICAgIGdyYW5kVG90YWxBUmVjZWJlcjogMzE3NTAwMC4zNlxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gR2VyYXIgZGFkb3MgZGUgaW52b2ljZXMgc2ltdWxhZG9zIGJhc2VhZG9zIG5vIHN1bW1hcnlEYXRhXHJcbiAgICAgIGFsbEludm9pY2VzID0gZ2VuZXJhdGVTaW11bGF0ZWRJbnZvaWNlcyhzdW1tYXJ5RGF0YSk7XHJcbiAgICAgIGFsbEJyYW5jaFN1bW1hcmllcyA9IHN1bW1hcnlEYXRhLmJyYW5jaGVzLm1hcChicmFuY2ggPT4gKHtcclxuICAgICAgICBicmFuY2g6IGJyYW5jaC5uYW1lLFxyXG4gICAgICAgIGludm9pY2VDb3VudDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApICsgNSxcclxuICAgICAgICB0b3RhbFZhbHVlOiBicmFuY2gudG90YWwudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywgeyBzdHlsZTogJ2N1cnJlbmN5JywgY3VycmVuY3k6ICdCUkwnIH0pXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhciBwZXLDrW9kbyByZWFsIGJhc2VhZG8gbmFzIGRhdGFzIGRvcyBkb2N1bWVudG9zXHJcbiAgICBsZXQgYWN0dWFsU3RhcnREYXRlOiBEYXRlO1xyXG4gICAgbGV0IGFjdHVhbEVuZERhdGU6IERhdGU7XHJcbiAgICBcclxuICAgIGlmIChhbGxJbnZvaWNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGludm9pY2VEYXRlcyA9IGFsbEludm9pY2VzXHJcbiAgICAgICAgLm1hcChpbnYgPT4gbmV3IERhdGUoaW52LmRhdGUpKVxyXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmdldFRpbWUoKSAtIGIuZ2V0VGltZSgpKTtcclxuICAgICAgYWN0dWFsU3RhcnREYXRlID0gaW52b2ljZURhdGVzWzBdO1xyXG4gICAgICBhY3R1YWxFbmREYXRlID0gaW52b2ljZURhdGVzW2ludm9pY2VEYXRlcy5sZW5ndGggLSAxXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFjdHVhbFN0YXJ0RGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIGFjdHVhbEVuZERhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExvZyBlc3RhdMOtc3RpY28gcGFyYSBkZWJ1ZyBtdWx0aS1maWxlXHJcbiAgICBjb25zdCBkaXN0aW5jdEZpbGVzID0gQXJyYXkuZnJvbShuZXcgU2V0KGFsbEludm9pY2VzLm1hcChpID0+IGkuc291cmNlRmlsZSkpKTtcclxuICAgIGNvbnN0IGRpc3RpbmN0QnJhbmNoZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoYWxsSW52b2ljZXMubWFwKGkgPT4gaS5icmFuY2gpKSk7XHJcbiAgICBjb25zb2xlLmxvZygnW0VYUE9SVF0gRXN0YXTDrXN0aWNhczonLCB7XHJcbiAgICAgIHRvdGFsSW52b2ljZXM6IGFsbEludm9pY2VzLmxlbmd0aCxcclxuICAgICAgZGlzdGluY3RGaWxlczogZGlzdGluY3RGaWxlcy5sZW5ndGgsXHJcbiAgICAgIGZpbGVzOiBkaXN0aW5jdEZpbGVzLFxyXG4gICAgICBkaXN0aW5jdEJyYW5jaGVzOiBkaXN0aW5jdEJyYW5jaGVzLmxlbmd0aCxcclxuICAgICAgYnJhbmNoZXM6IGRpc3RpbmN0QnJhbmNoZXNcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENyaWFyIHdvcmtib29rXHJcbiAgICBjb25zdCB3b3JrYm9vayA9IG5ldyBFeGNlbEpTLldvcmtib29rKCk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdDcmlhbmRvIGFiYSBkZSBSZXN1bW8gR2VyYWwuLi4nKTtcclxuICAgIGF3YWl0IGNyZWF0ZUFkdmFuY2VkU3VtbWFyeVdvcmtzaGVldChcclxuICAgICAgd29ya2Jvb2ssIFxyXG4gICAgICBzdW1tYXJ5RGF0YSwgXHJcbiAgICAgIGFsbEludm9pY2VzLCBcclxuICAgICAgcmVwb3J0TmFtZSB8fCAnUmVsYXTDs3JpbyBkZSBOb3RhcyBGaXNjYWlzJyxcclxuICAgICAgYWN0dWFsU3RhcnREYXRlLFxyXG4gICAgICBhY3R1YWxFbmREYXRlXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQ3JpYW5kbyBhYmFzIGluZGl2aWR1YWlzIHBvciBmaWxpYWwuLi4nKTtcclxuICAgIGNvbnN0IGV4aXN0aW5nV29ya3NoZWV0TmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgIGV4aXN0aW5nV29ya3NoZWV0TmFtZXMuYWRkKCdSRVNVTU8gR0VSQUwnKTsgLy8gQWRpY2lvbmFyIG8gbm9tZSBkYSBhYmEgZGUgcmVzdW1vXHJcbiAgICBcclxuICAgIGZvciAoY29uc3QgYnJhbmNoIG9mIHN1bW1hcnlEYXRhLmJyYW5jaGVzKSB7XHJcbiAgICAgIGNvbnN0IGJyYW5jaEludm9pY2VzID0gYWxsSW52b2ljZXMuZmlsdGVyKGludiA9PiBpbnYuYnJhbmNoID09PSBicmFuY2gubmFtZSk7XHJcbiAgICAgIGF3YWl0IGNyZWF0ZUFkdmFuY2VkQnJhbmNoV29ya3NoZWV0KHdvcmtib29rLCBicmFuY2gsIGJyYW5jaEludm9pY2VzLCBleGlzdGluZ1dvcmtzaGVldE5hbWVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb25maWd1cmFyIHJlc3Bvc3RhIEhUVFBcclxuICAgIGNvbnN0IGZpbGVOYW1lID0gYHJlbGF0b3Jpb19kZXRhbGhhZG9fJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXX0ueGxzeGA7XHJcbiAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQnKTtcclxuICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtRGlzcG9zaXRpb24nLCBgYXR0YWNobWVudDsgZmlsZW5hbWU9XCIke2ZpbGVOYW1lfVwiYCk7XHJcbiAgICBcclxuICAgIC8vIEVzY3JldmVyIHdvcmtib29rIG5hIHJlc3Bvc3RhXHJcbiAgICBhd2FpdCB3b3JrYm9vay54bHN4LndyaXRlKHJlcyk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdFeGNlbCBnZXJhZG8gY29tIHN1Y2Vzc28hJyk7XHJcbiAgICByZXMuZW5kKCk7XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvIG5hIGdlcmHDp8OjbyBkbyBFeGNlbDonLCBlcnJvcik7XHJcbiAgICBjb25zb2xlLmVycm9yKCdTdGFjayB0cmFjZTonLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiAnTsOjbyBkaXNwb27DrXZlbCcpO1xyXG4gICAgY29uc29sZS5lcnJvcignVGlwbyBkZSBlcnJvOicsIHR5cGVvZiBlcnJvcik7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFc3RhZG8gZG8gcmVxLmJvZHk6Jywge1xyXG4gICAgICBleGlzdHM6ICEhKHJlcSBhcyBhbnkpLmJvZHksXHJcbiAgICAgIGhhc1Byb2Nlc3NlZERhdGE6ICEhKChyZXEgYXMgYW55KS5ib2R5Py5wcm9jZXNzZWREYXRhKSxcclxuICAgICAgcHJvY2Vzc2VkRGF0YVR5cGU6IHR5cGVvZiAocmVxIGFzIGFueSkuYm9keT8ucHJvY2Vzc2VkRGF0YVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlmICghcmVzLmhlYWRlcnNTZW50KSB7XHJcbiAgICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgXHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsIFxyXG4gICAgICAgIG1lc3NhZ2U6ICdFcnJvIGludGVybm8gZG8gc2Vydmlkb3I6ICcgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRXJybyBkZXNjb25oZWNpZG8nKSxcclxuICAgICAgICBlcnJvckRldGFpbHM6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyB7XHJcbiAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lLFxyXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjaz8uc3Vic3RyaW5nKDAsIDUwMCkgLy8gUHJpbWVpcm9zIDUwMCBjaGFycyBkbyBzdGFja1xyXG4gICAgICAgIH0gOiAnRXJybyBuw6NvIGlkZW50aWZpY2FkbydcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBGdW7Dp8OjbyBwYXJhIGdlcmFyIGRhZG9zIGRlIGludm9pY2VzIHNpbXVsYWRvc1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVNpbXVsYXRlZEludm9pY2VzKHN1bW1hcnlEYXRhOiBTdW1tYXJ5RGF0YSk6IEludm9pY2VEYXRhW10ge1xyXG4gIGNvbnN0IGludm9pY2VzOiBJbnZvaWNlRGF0YVtdID0gW107XHJcbiAgbGV0IGlkQ291bnRlciA9IDE7XHJcbiAgXHJcbiAgc3VtbWFyeURhdGEuYnJhbmNoZXMuZm9yRWFjaChicmFuY2ggPT4ge1xyXG4gICAgLy8gR2VyYXIgYWxndW1hcyBpbnZvaWNlcyBBX1BBR0FSXHJcbiAgICBpZiAoYnJhbmNoLnRvdGFsQVBhZ2FyID4gMCkge1xyXG4gICAgICBjb25zdCBudW1JbnZvaWNlc0FQYWdhciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUpICsgMjtcclxuICAgICAgY29uc3QgYXZlcmFnZVZhbHVlID0gYnJhbmNoLnRvdGFsQVBhZ2FyIC8gbnVtSW52b2ljZXNBUGFnYXI7XHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUludm9pY2VzQVBhZ2FyOyBpKyspIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGF2ZXJhZ2VWYWx1ZSAqICgwLjggKyBNYXRoLnJhbmRvbSgpICogMC40KTsgLy8gVmFyaWHDp8OjbyBkZSDCsTIwJVxyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMwKSk7IC8vIFByw7N4aW1vcyAzMCBkaWFzXHJcbiAgICAgICAgXHJcbiAgICAgICAgaW52b2ljZXMucHVzaCh7XHJcbiAgICAgICAgICBpZDogYGludl8ke2lkQ291bnRlcisrfWAsXHJcbiAgICAgICAgICBicmFuY2g6IGJyYW5jaC5uYW1lLFxyXG4gICAgICAgICAgaW52b2ljZU51bWJlcjogYE5GLSR7U3RyaW5nKGkgKyAxKS5wYWRTdGFydCgzLCAnMCcpfWAsXHJcbiAgICAgICAgICBkYXRlOiBkYXRlLFxyXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLnRvTG9jYWxlU3RyaW5nKCdwdC1CUicsIHsgc3R5bGU6ICdjdXJyZW5jeScsIGN1cnJlbmN5OiAnQlJMJyB9KSxcclxuICAgICAgICAgIHN1cHBsaWVyOiBgRk9STkVDRURPUiAke1N0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBpKX1gLFxyXG4gICAgICAgICAgZG9jdW1lbnRUeXBlOiAnQV9QQUdBUicsXHJcbiAgICAgICAgICBzb3VyY2VGaWxlOiBgJHticmFuY2gubmFtZX0uY3N2YCxcclxuICAgICAgICAgIHZhbHVlTnVtZXJpYzogdmFsdWVcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBHZXJhciBhbGd1bWFzIGludm9pY2VzIEFfUkVDRUJFUlxyXG4gICAgaWYgKGJyYW5jaC50b3RhbEFSZWNlYmVyID4gMCkge1xyXG4gICAgICBjb25zdCBudW1JbnZvaWNlc0FSZWNlYmVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMykgKyAxO1xyXG4gICAgICBjb25zdCBhdmVyYWdlVmFsdWUgPSBicmFuY2gudG90YWxBUmVjZWJlciAvIG51bUludm9pY2VzQVJlY2ViZXI7XHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUludm9pY2VzQVJlY2ViZXI7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXZlcmFnZVZhbHVlICogKDAuOCArIE1hdGgucmFuZG9tKCkgKiAwLjQpO1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMwKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaW52b2ljZXMucHVzaCh7XHJcbiAgICAgICAgICBpZDogYGludl8ke2lkQ291bnRlcisrfWAsXHJcbiAgICAgICAgICBicmFuY2g6IGJyYW5jaC5uYW1lLFxyXG4gICAgICAgICAgaW52b2ljZU51bWJlcjogYFJFQy0ke1N0cmluZyhpICsgMSkucGFkU3RhcnQoMywgJzAnKX1gLFxyXG4gICAgICAgICAgZGF0ZTogZGF0ZSxcclxuICAgICAgICAgIHZhbHVlOiB2YWx1ZS50b0xvY2FsZVN0cmluZygncHQtQlInLCB7IHN0eWxlOiAnY3VycmVuY3knLCBjdXJyZW5jeTogJ0JSTCcgfSksXHJcbiAgICAgICAgICBzdXBwbGllcjogYENMSUVOVEUgJHtTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgaSl9YCxcclxuICAgICAgICAgIGRvY3VtZW50VHlwZTogJ0FfUkVDRUJFUicsXHJcbiAgICAgICAgICBzb3VyY2VGaWxlOiBgJHticmFuY2gubmFtZX0uY3N2YCxcclxuICAgICAgICAgIHZhbHVlTnVtZXJpYzogdmFsdWVcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIHJldHVybiBpbnZvaWNlcztcclxufVxyXG5cclxuLy8gRnVuw6fDo28gcGFyYSBjcmlhciBhIGFiYSBkZSByZXN1bW8gZ2VyYWwgYXZhbsOnYWRhXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFkdmFuY2VkU3VtbWFyeVdvcmtzaGVldChcclxuICB3b3JrYm9vazogRXhjZWxKUy5Xb3JrYm9vaywgXHJcbiAgc3VtbWFyeURhdGE6IFN1bW1hcnlEYXRhLCBcclxuICBhbGxJbnZvaWNlczogSW52b2ljZURhdGFbXSxcclxuICByZXBvcnROYW1lOiBzdHJpbmcsXHJcbiAgYWN0dWFsU3RhcnREYXRlOiBEYXRlLFxyXG4gIGFjdHVhbEVuZERhdGU6IERhdGVcclxuKSB7XHJcbiAgY29uc3Qgc3VtbWFyeVNoZWV0ID0gd29ya2Jvb2suYWRkV29ya3NoZWV0KCdSZXN1bW8gR2VyYWwnKTtcclxuICBsZXQgc3VtbWFyeUN1cnJlbnRSb3cgPSAxO1xyXG5cclxuICAvLyBIZWFkZXIgZG8gcmVsYXTDs3Jpb1xyXG4gIHN1bW1hcnlTaGVldC5hZGRSb3coW3JlcG9ydE5hbWVdKTtcclxuICBzdW1tYXJ5U2hlZXQubWVyZ2VDZWxscyhgQSR7c3VtbWFyeUN1cnJlbnRSb3d9OkQke3N1bW1hcnlDdXJyZW50Um93fWApO1xyXG4gIHN1bW1hcnlTaGVldC5nZXRDZWxsKGBBJHtzdW1tYXJ5Q3VycmVudFJvd31gKS5zdHlsZSA9IHRpdGxlU3R5bGU7XHJcbiAgc3VtbWFyeVNoZWV0LmdldFJvdyhzdW1tYXJ5Q3VycmVudFJvdykuaGVpZ2h0ID0gMzU7XHJcbiAgc3VtbWFyeUN1cnJlbnRSb3crKztcclxuXHJcbiAgLy8gUGVyw61vZG9cclxuICBjb25zdCBwZXJpb2RUZXh0ID0gYFBFUsONT0RPOiAke2FjdHVhbFN0YXJ0RGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ3B0LUJSJyl9IC0gJHthY3R1YWxFbmREYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygncHQtQlInKX1gO1xyXG4gIHN1bW1hcnlTaGVldC5hZGRSb3coW3BlcmlvZFRleHRdKTtcclxuICBzdW1tYXJ5U2hlZXQubWVyZ2VDZWxscyhgQSR7c3VtbWFyeUN1cnJlbnRSb3d9OkQke3N1bW1hcnlDdXJyZW50Um93fWApO1xyXG4gIHN1bW1hcnlTaGVldC5nZXRDZWxsKGBBJHtzdW1tYXJ5Q3VycmVudFJvd31gKS5zdHlsZSA9IHtcclxuICAgIGZvbnQ6IHsgYm9sZDogdHJ1ZSwgc2l6ZTogMTIgfSxcclxuICAgIGZpbGw6IHsgdHlwZTogJ3BhdHRlcm4nIGFzIGNvbnN0LCBwYXR0ZXJuOiAnc29saWQnIGFzIGNvbnN0LCBmZ0NvbG9yOiB7IGFyZ2I6ICdFN0U2RTYnIH0gfSxcclxuICAgIGFsaWdubWVudDogeyBob3Jpem9udGFsOiAnY2VudGVyJyBhcyBjb25zdCwgdmVydGljYWw6ICdtaWRkbGUnIGFzIGNvbnN0IH1cclxuICB9O1xyXG4gIHN1bW1hcnlDdXJyZW50Um93Kys7XHJcblxyXG4gIC8vIExpbmhhIHZhemlhXHJcbiAgc3VtbWFyeVNoZWV0LmFkZFJvdyhbXSk7XHJcbiAgc3VtbWFyeUN1cnJlbnRSb3crKztcclxuXHJcbiAgLy8gSGVhZGVycyBkYXMgY29sdW5hc1xyXG4gIHN1bW1hcnlTaGVldC5hZGRSb3coWydWZW5jaW1lbnRvJywgJ1RyYW5zYWNpb25hZG9yJywgJ0RvY3VtZW50bycsICdWYWxvciddKTtcclxuICBzdW1tYXJ5U2hlZXQuZ2V0Um93KHN1bW1hcnlDdXJyZW50Um93KS5lYWNoQ2VsbCgoY2VsbCkgPT4ge1xyXG4gICAgY2VsbC5zdHlsZSA9IGhlYWRlclN0eWxlO1xyXG4gIH0pO1xyXG4gIHN1bW1hcnlDdXJyZW50Um93Kys7XHJcblxyXG4gIC8vIEFncnVwYXIgaW52b2ljZXMgcG9yIGFycXVpdm8gZm9udGUgZSB0aXBvIGRlIGRvY3VtZW50b1xyXG4gIGNvbnN0IGludm9pY2VzQnlGaWxlQW5kVHlwZSA9IG5ldyBNYXA8c3RyaW5nLCB7IEFfUEFHQVI6IEludm9pY2VEYXRhW10sIEFfUkVDRUJFUjogSW52b2ljZURhdGFbXSB9PigpO1xyXG4gIFxyXG4gIGZvciAoY29uc3QgaW52b2ljZSBvZiBhbGxJbnZvaWNlcykge1xyXG4gICAgY29uc3Qgc291cmNlRmlsZSA9IGludm9pY2Uuc291cmNlRmlsZSB8fCAnVW5rbm93bic7XHJcbiAgICBcclxuICAgIGlmICghaW52b2ljZXNCeUZpbGVBbmRUeXBlLmhhcyhzb3VyY2VGaWxlKSkge1xyXG4gICAgICBpbnZvaWNlc0J5RmlsZUFuZFR5cGUuc2V0KHNvdXJjZUZpbGUsIHsgQV9QQUdBUjogW10sIEFfUkVDRUJFUjogW10gfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGZpbGVUeXBlcyA9IGludm9pY2VzQnlGaWxlQW5kVHlwZS5nZXQoc291cmNlRmlsZSkhO1xyXG4gICAgY29uc3QgZG9jVHlwZSA9IGludm9pY2UuZG9jdW1lbnRUeXBlIHx8ICdBX1BBR0FSJztcclxuICAgIGZpbGVUeXBlc1tkb2NUeXBlXS5wdXNoKGludm9pY2UpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHJvY2Vzc2FyIGNhZGEgYXJxdWl2byBlIHRpcG8gZGUgZG9jdW1lbnRvXHJcbiAgZm9yIChjb25zdCBbZmlsZU5hbWUsIGZpbGVUeXBlc10gb2YgQXJyYXkuZnJvbShpbnZvaWNlc0J5RmlsZUFuZFR5cGUpKSB7XHJcbiAgICBmb3IgKGNvbnN0IFtkb2NUeXBlLCBmaWxlSW52b2ljZXNdIG9mIE9iamVjdC5lbnRyaWVzKGZpbGVUeXBlcykpIHtcclxuICAgICAgaWYgKGZpbGVJbnZvaWNlcy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdHlwZUxhYmVsID0gZG9jVHlwZSA9PT0gJ0FfUEFHQVInID8gJ0NPTlRBUyBBIFBBR0FSJyA6ICdDT05UQVMgQSBSRUNFQkVSJztcclxuICAgICAgY29uc3QgY2xlYW5GaWxlTmFtZSA9IGZpbGVOYW1lLnJlcGxhY2UoL1xcLihjc3Z8Q1NWKSQvLCAnJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBIZWFkZXIgZGEgY2F0ZWdvcmlhXHJcbiAgICAgIHN1bW1hcnlTaGVldC5hZGRSb3coW2Ake3R5cGVMYWJlbH0gLSAke2NsZWFuRmlsZU5hbWV9YCwgJycsICcnLCAnJ10pO1xyXG4gICAgICBzdW1tYXJ5U2hlZXQubWVyZ2VDZWxscyhgQSR7c3VtbWFyeUN1cnJlbnRSb3d9OkQke3N1bW1hcnlDdXJyZW50Um93fWApO1xyXG4gICAgICBzdW1tYXJ5U2hlZXQuZ2V0Q2VsbChgQSR7c3VtbWFyeUN1cnJlbnRSb3d9YCkuc3R5bGUgPSBzdWJIZWFkZXJTdHlsZTtcclxuICAgICAgc3VtbWFyeUN1cnJlbnRSb3crKztcclxuICAgICAgXHJcbiAgICAgIC8vIE9yZGVuYXIgcG9yIGRhdGFcclxuICAgICAgZmlsZUludm9pY2VzLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGEuZGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5kYXRlKS5nZXRUaW1lKCkpO1xyXG4gICAgICBcclxuICAgICAgLy8gQWRpY2lvbmFyIHRyYW5zYcOnw7VlcyBjb20gdG90YWlzIGRpw6FyaW9zXHJcbiAgICAgIGxldCBjdXJyZW50RGF0ZSA9ICcnO1xyXG4gICAgICBsZXQgZGFpbHlUb3RhbCA9IDA7XHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGNvbnN0IGludm9pY2Ugb2YgZmlsZUludm9pY2VzKSB7XHJcbiAgICAgICAgY29uc3QgaW52b2ljZURhdGUgPSBuZXcgRGF0ZShpbnZvaWNlLmRhdGUpLnRvTG9jYWxlRGF0ZVN0cmluZygncHQtQlInKTtcclxuICAgICAgICBjb25zdCBpbnZvaWNlVmFsdWUgPSBpbnZvaWNlLnZhbHVlTnVtZXJpYztcclxuICAgICAgICBcclxuICAgICAgICAvLyBWZXJpZmljYXIgbXVkYW7Dp2EgZGUgZGF0YSBwYXJhIHRvdGFsIGRpw6FyaW9cclxuICAgICAgICBpZiAoY3VycmVudERhdGUgJiYgY3VycmVudERhdGUgIT09IGludm9pY2VEYXRlICYmIGRhaWx5VG90YWwgPiAwKSB7XHJcbiAgICAgICAgICBzdW1tYXJ5U2hlZXQuYWRkUm93KFsnJywgJycsICdUT1RBTCcsIGRhaWx5VG90YWxdKTtcclxuICAgICAgICAgIGNvbnN0IHRvdGFsUm93ID0gc3VtbWFyeVNoZWV0LmdldFJvdyhzdW1tYXJ5Q3VycmVudFJvdyk7XHJcbiAgICAgICAgICB0b3RhbFJvdy5lYWNoQ2VsbCgoY2VsbCwgY29sTnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGNlbGwuc3R5bGUgPSB7XHJcbiAgICAgICAgICAgICAgZm9udDogeyBib2xkOiB0cnVlIH0sXHJcbiAgICAgICAgICAgICAgZmlsbDogeyB0eXBlOiAncGF0dGVybicgYXMgY29uc3QsIHBhdHRlcm46ICdzb2xpZCcgYXMgY29uc3QsIGZnQ29sb3I6IHsgYXJnYjogJ0YyRjJGMicgfSB9LFxyXG4gICAgICAgICAgICAgIG51bUZtdDogY29sTnVtYmVyID09PSA0ID8gJ1IkICMsIyMwLjAwJyA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICBib3JkZXI6IGNlbGxTdHlsZS5ib3JkZXIsXHJcbiAgICAgICAgICAgICAgYWxpZ25tZW50OiBjb2xOdW1iZXIgPT09IDMgPyB7IGhvcml6b250YWw6ICdjZW50ZXInIGFzIGNvbnN0IH0gOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgc3VtbWFyeUN1cnJlbnRSb3crKztcclxuICAgICAgICAgIGRhaWx5VG90YWwgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBBZGljaW9uYXIgbGluaGEgZGEgdHJhbnNhw6fDo29cclxuICAgICAgICBzdW1tYXJ5U2hlZXQuYWRkUm93KFtcclxuICAgICAgICAgIGludm9pY2VEYXRlLFxyXG4gICAgICAgICAgaW52b2ljZS5zdXBwbGllciB8fCAnRk9STkVDRURPUiBOw4NPIElERU5USUZJQ0FETycsXHJcbiAgICAgICAgICBpbnZvaWNlLmludm9pY2VOdW1iZXIsXHJcbiAgICAgICAgICBpbnZvaWNlVmFsdWVcclxuICAgICAgICBdKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCByb3cgPSBzdW1tYXJ5U2hlZXQuZ2V0Um93KHN1bW1hcnlDdXJyZW50Um93KTtcclxuICAgICAgICByb3cuZWFjaENlbGwoKGNlbGwsIGNvbE51bWJlcikgPT4ge1xyXG4gICAgICAgICAgY2VsbC5zdHlsZSA9IGNlbGxTdHlsZTtcclxuICAgICAgICAgIGlmIChjb2xOdW1iZXIgPT09IDQpIHtcclxuICAgICAgICAgICAgY2VsbC5udW1GbXQgPSAnUiQgIywjIzAuMDAnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGN1cnJlbnREYXRlID0gaW52b2ljZURhdGU7XHJcbiAgICAgICAgZGFpbHlUb3RhbCArPSBpbnZvaWNlVmFsdWU7XHJcbiAgICAgICAgc3VtbWFyeUN1cnJlbnRSb3crKztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gVG90YWwgZmluYWwgZGEgY2F0ZWdvcmlhIHNlIGhvdXZlciBkYWRvcyBwZW5kZW50ZXNcclxuICAgICAgaWYgKGRhaWx5VG90YWwgPiAwKSB7XHJcbiAgICAgICAgc3VtbWFyeVNoZWV0LmFkZFJvdyhbJycsICcnLCAnVE9UQUwnLCBkYWlseVRvdGFsXSk7XHJcbiAgICAgICAgY29uc3QgdG90YWxSb3cgPSBzdW1tYXJ5U2hlZXQuZ2V0Um93KHN1bW1hcnlDdXJyZW50Um93KTtcclxuICAgICAgICB0b3RhbFJvdy5lYWNoQ2VsbCgoY2VsbCwgY29sTnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICBjZWxsLnN0eWxlID0ge1xyXG4gICAgICAgICAgICBmb250OiB7IGJvbGQ6IHRydWUgfSxcclxuICAgICAgICAgICAgZmlsbDogeyB0eXBlOiAncGF0dGVybicgYXMgY29uc3QsIHBhdHRlcm46ICdzb2xpZCcgYXMgY29uc3QsIGZnQ29sb3I6IHsgYXJnYjogJ0YyRjJGMicgfSB9LFxyXG4gICAgICAgICAgICBudW1GbXQ6IGNvbE51bWJlciA9PT0gNCA/ICdSJCAjLCMjMC4wMCcgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGJvcmRlcjogY2VsbFN0eWxlLmJvcmRlcixcclxuICAgICAgICAgICAgYWxpZ25tZW50OiBjb2xOdW1iZXIgPT09IDMgPyB7IGhvcml6b250YWw6ICdjZW50ZXInIGFzIGNvbnN0IH0gOiB1bmRlZmluZWRcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VtbWFyeUN1cnJlbnRSb3crKztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gVG90YWwgZGEgY2F0ZWdvcmlhXHJcbiAgICAgIGNvbnN0IGNhdGVnb3J5VG90YWwgPSBmaWxlSW52b2ljZXMucmVkdWNlKChzdW0sIGludikgPT4gc3VtICsgaW52LnZhbHVlTnVtZXJpYywgMCk7XHJcbiAgICAgIHN1bW1hcnlTaGVldC5hZGRSb3coWycnLCAnJywgYFRPVEFMICR7dHlwZUxhYmVsfWAsIGNhdGVnb3J5VG90YWxdKTtcclxuICAgICAgY29uc3QgY2F0ZWdvcnlUb3RhbFJvdyA9IHN1bW1hcnlTaGVldC5nZXRSb3coc3VtbWFyeUN1cnJlbnRSb3cpO1xyXG4gICAgICBjYXRlZ29yeVRvdGFsUm93LmVhY2hDZWxsKChjZWxsLCBjb2xOdW1iZXIpID0+IHtcclxuICAgICAgICBjZWxsLnN0eWxlID0ge1xyXG4gICAgICAgICAgLi4udG90YWxSb3dTdHlsZSxcclxuICAgICAgICAgIG51bUZtdDogY29sTnVtYmVyID09PSA0ID8gJ1IkICMsIyMwLjAwJyA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgIGJvcmRlcjogY2VsbFN0eWxlLmJvcmRlclxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgICBzdW1tYXJ5Q3VycmVudFJvdysrO1xyXG4gICAgICBcclxuICAgICAgLy8gTGluaGEgdmF6aWEgcGFyYSBzZXBhcmHDp8Ojb1xyXG4gICAgICBzdW1tYXJ5U2hlZXQuYWRkUm93KFtdKTtcclxuICAgICAgc3VtbWFyeUN1cnJlbnRSb3crKztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFRvdGFsIGdlcmFsIGZpbmFsXHJcbiAgc3VtbWFyeVNoZWV0LmFkZFJvdyhbJycsICcnLCAnVE9UQUwgR0VSQUwnLCBzdW1tYXJ5RGF0YS5ncmFuZFRvdGFsXSk7XHJcbiAgY29uc3QgZ3JhbmRUb3RhbFJvdyA9IHN1bW1hcnlTaGVldC5nZXRSb3coc3VtbWFyeUN1cnJlbnRSb3cpO1xyXG4gIGdyYW5kVG90YWxSb3cuZWFjaENlbGwoKGNlbGwsIGNvbE51bWJlcikgPT4ge1xyXG4gICAgY2VsbC5zdHlsZSA9IHtcclxuICAgICAgLi4udG90YWxSb3dTdHlsZSxcclxuICAgICAgbnVtRm10OiBjb2xOdW1iZXIgPT09IDQgPyAnUiQgIywjIzAuMDAnIDogdW5kZWZpbmVkLFxyXG4gICAgICBib3JkZXI6IGNlbGxTdHlsZS5ib3JkZXIsXHJcbiAgICAgIGZvbnQ6IHsgYm9sZDogdHJ1ZSwgc2l6ZTogMTQsIGNvbG9yOiB7IGFyZ2I6ICdGRkZGRkYnIH0gfVxyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gRGVmaW5pciBsYXJndXJhcyBkYXMgY29sdW5hc1xyXG4gIHN1bW1hcnlTaGVldC5nZXRDb2x1bW4oMSkud2lkdGggPSAxNTsgLy8gRGF0YVxyXG4gIHN1bW1hcnlTaGVldC5nZXRDb2x1bW4oMikud2lkdGggPSA2MDsgLy8gVHJhbnNhY2lvbmFkb3IgIFxyXG4gIHN1bW1hcnlTaGVldC5nZXRDb2x1bW4oMykud2lkdGggPSAyMDsgLy8gRG9jdW1lbnRvXHJcbiAgc3VtbWFyeVNoZWV0LmdldENvbHVtbig0KS53aWR0aCA9IDE4OyAvLyBWYWxvclxyXG59XHJcblxyXG4vLyBGdW7Dp8OjbyBwYXJhIGNyaWFyIGFiYSBpbmRpdmlkdWFsIGRhIGZpbGlhbCBhdmFuw6dhZGFcclxuLy8gRnVuw6fDo28gcGFyYSBnZXJhciBub21lcyDDum5pY29zIGRlIHdvcmtzaGVldFxyXG5mdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZVdvcmtzaGVldE5hbWUoYmFzZU5hbWU6IHN0cmluZywgZXhpc3RpbmdOYW1lczogU2V0PHN0cmluZz4pOiBzdHJpbmcge1xyXG4gIC8vIExpbXBhciBjYXJhY3RlcmVzIGludsOhbGlkb3MgZSBsaW1pdGFyIHRhbWFuaG9cclxuICBsZXQgY2xlYW5OYW1lID0gYmFzZU5hbWVcclxuICAgIC5yZXBsYWNlKC9bXFwvXFxcXFxcP1xcKlxcW1xcXV0vZywgJ18nKVxyXG4gICAgLnJlcGxhY2UoL1teYS16QS1aMC05X1xcLVxcc10vZywgJycpXHJcbiAgICAuc3Vic3RyaW5nKDAsIDI1KVxyXG4gICAgLnRyaW0oKTtcclxuICBcclxuICAvLyBTZSBvIG5vbWUgZXN0aXZlciB2YXppbyBhcMOzcyBsaW1wZXphLCB1c2FyIHVtIHBhZHLDo29cclxuICBpZiAoIWNsZWFuTmFtZSkge1xyXG4gICAgY2xlYW5OYW1lID0gJ1BMQU5JTEhBJztcclxuICB9XHJcbiAgXHJcbiAgLy8gU2UgbyBub21lIG7Do28gZXhpc3RlLCB1c2FyIGNvbW8gZXN0w6FcclxuICBpZiAoIWV4aXN0aW5nTmFtZXMuaGFzKGNsZWFuTmFtZSkpIHtcclxuICAgIGV4aXN0aW5nTmFtZXMuYWRkKGNsZWFuTmFtZSk7XHJcbiAgICByZXR1cm4gY2xlYW5OYW1lO1xyXG4gIH1cclxuICBcclxuICAvLyBTZSBleGlzdGUsIGFkaWNpb25hciBuw7ptZXJvIHNlcXVlbmNpYWxcclxuICBsZXQgY291bnRlciA9IDE7XHJcbiAgbGV0IHVuaXF1ZU5hbWUgPSBgJHtjbGVhbk5hbWUuc3Vic3RyaW5nKDAsIDIyKX1fJHtjb3VudGVyfWA7XHJcbiAgXHJcbiAgd2hpbGUgKGV4aXN0aW5nTmFtZXMuaGFzKHVuaXF1ZU5hbWUpKSB7XHJcbiAgICBjb3VudGVyKys7XHJcbiAgICB1bmlxdWVOYW1lID0gYCR7Y2xlYW5OYW1lLnN1YnN0cmluZygwLCAyMil9XyR7Y291bnRlcn1gO1xyXG4gIH1cclxuICBcclxuICBleGlzdGluZ05hbWVzLmFkZCh1bmlxdWVOYW1lKTtcclxuICByZXR1cm4gdW5pcXVlTmFtZTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQWR2YW5jZWRCcmFuY2hXb3Jrc2hlZXQoXHJcbiAgd29ya2Jvb2s6IEV4Y2VsSlMuV29ya2Jvb2ssIFxyXG4gIGJyYW5jaDogQnJhbmNoRGF0YSwgXHJcbiAgYnJhbmNoSW52b2ljZXM6IEludm9pY2VEYXRhW10sXHJcbiAgZXhpc3RpbmdOYW1lczogU2V0PHN0cmluZz5cclxuKSB7XHJcbiAgY29uc3QgdW5pcXVlTmFtZSA9IGdlbmVyYXRlVW5pcXVlV29ya3NoZWV0TmFtZShicmFuY2gubmFtZSwgZXhpc3RpbmdOYW1lcyk7XHJcbiAgY29uc3Qgd29ya3NoZWV0ID0gd29ya2Jvb2suYWRkV29ya3NoZWV0KHVuaXF1ZU5hbWUpO1xyXG4gIGxldCBjdXJyZW50Um93ID0gMTtcclxuXHJcbiAgLy8gVMOtdHVsbyBkYSBmaWxpYWxcclxuICBjb25zdCB0aXRsZVJvdyA9IHdvcmtzaGVldC5hZGRSb3coW2BERVRBTEhBTUVOVE8gLSAke2JyYW5jaC5uYW1lfWBdKTtcclxuICB3b3Jrc2hlZXQubWVyZ2VDZWxscyhgQSR7Y3VycmVudFJvd306RCR7Y3VycmVudFJvd31gKTtcclxuICB0aXRsZVJvdy5nZXRDZWxsKDEpLnN0eWxlID0gdGl0bGVTdHlsZTtcclxuICB0aXRsZVJvdy5oZWlnaHQgPSAzMDtcclxuICBjdXJyZW50Um93Kys7XHJcblxyXG4gIC8vIFBlcsOtb2RvXHJcbiAgaWYgKGJyYW5jaEludm9pY2VzLmxlbmd0aCA+IDApIHtcclxuICAgIGNvbnN0IGJyYW5jaERhdGVzID0gYnJhbmNoSW52b2ljZXMubWFwKGludiA9PiBuZXcgRGF0ZShpbnYuZGF0ZSkpLnNvcnQoKGEsIGIpID0+IGEuZ2V0VGltZSgpIC0gYi5nZXRUaW1lKCkpO1xyXG4gICAgY29uc3Qgc3RhcnREYXRlID0gYnJhbmNoRGF0ZXNbMF07XHJcbiAgICBjb25zdCBlbmREYXRlID0gYnJhbmNoRGF0ZXNbYnJhbmNoRGF0ZXMubGVuZ3RoIC0gMV07XHJcbiAgICBjb25zdCBwZXJpb2RUZXh0ID0gYFBFUsONT0RPOiAke3N0YXJ0RGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ3B0LUJSJyl9IC0gJHtlbmREYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygncHQtQlInKX1gO1xyXG4gICAgXHJcbiAgICB3b3Jrc2hlZXQuYWRkUm93KFtwZXJpb2RUZXh0XSk7XHJcbiAgICB3b3Jrc2hlZXQubWVyZ2VDZWxscyhgQSR7Y3VycmVudFJvd306RCR7Y3VycmVudFJvd31gKTtcclxuICAgIHdvcmtzaGVldC5nZXRDZWxsKGBBJHtjdXJyZW50Um93fWApLnN0eWxlID0ge1xyXG4gICAgICBmb250OiB7IGJvbGQ6IHRydWUsIHNpemU6IDEyIH0sXHJcbiAgICAgIGZpbGw6IHsgdHlwZTogJ3BhdHRlcm4nIGFzIGNvbnN0LCBwYXR0ZXJuOiAnc29saWQnIGFzIGNvbnN0LCBmZ0NvbG9yOiB7IGFyZ2I6ICdFN0U2RTYnIH0gfSxcclxuICAgICAgYWxpZ25tZW50OiB7IGhvcml6b250YWw6ICdjZW50ZXInIGFzIGNvbnN0LCB2ZXJ0aWNhbDogJ21pZGRsZScgYXMgY29uc3QgfVxyXG4gICAgfTtcclxuICAgIGN1cnJlbnRSb3crKztcclxuICB9XHJcblxyXG4gIC8vIERldGFsaGFtZW50byBkZSB0cmFuc2HDp8O1ZXMgcG9yIHRpcG9cclxuICBpZiAoYnJhbmNoSW52b2ljZXMubGVuZ3RoID4gMCkge1xyXG4gICAgLy8gU2VwYXJhciBwb3IgdGlwbyBkZSBkb2N1bWVudG9cclxuICAgIGNvbnN0IGFwYWdhckludm9pY2VzID0gYnJhbmNoSW52b2ljZXMuZmlsdGVyKGludiA9PiBpbnYuZG9jdW1lbnRUeXBlID09PSAnQV9QQUdBUicpO1xyXG4gICAgY29uc3QgYXJlY2ViZXJJbnZvaWNlcyA9IGJyYW5jaEludm9pY2VzLmZpbHRlcihpbnYgPT4gaW52LmRvY3VtZW50VHlwZSA9PT0gJ0FfUkVDRUJFUicpO1xyXG5cclxuICAgIC8vIFByb2Nlc3NhciBBX1BBR0FSXHJcbiAgICBpZiAoYXBhZ2FySW52b2ljZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBhUGFnYXJIZWFkZXJSb3cgPSB3b3Jrc2hlZXQuYWRkUm93KFsnQ09OVEFTIEEgUEFHQVInXSk7XHJcbiAgICAgIHdvcmtzaGVldC5tZXJnZUNlbGxzKGBBJHtjdXJyZW50Um93fTpEJHtjdXJyZW50Um93fWApO1xyXG4gICAgICBhUGFnYXJIZWFkZXJSb3cuZ2V0Q2VsbCgxKS5zdHlsZSA9IHN1YkhlYWRlclN0eWxlO1xyXG4gICAgICBjdXJyZW50Um93Kys7XHJcblxyXG4gICAgICB3b3Jrc2hlZXQuYWRkUm93KFtdKTtcclxuICAgICAgY3VycmVudFJvdysrO1xyXG5cclxuICAgICAgLy8gQ2FiZcOnYWxob3MgZGFzIHRyYW5zYcOnw7VlcyBBX1BBR0FSXHJcbiAgICAgIGNvbnN0IHRyYW5zSGVhZGVyUm93ID0gd29ya3NoZWV0LmFkZFJvdyhbJ1ZlbmNpbWVudG8nLCAnVHJhbnNhY2lvbmFkb3InLCAnRG9jdW1lbnRvJywgJ1ZhbG9yJ10pO1xyXG4gICAgICB0cmFuc0hlYWRlclJvdy5lYWNoQ2VsbCgoY2VsbCkgPT4ge1xyXG4gICAgICAgIGNlbGwuc3R5bGUgPSBoZWFkZXJTdHlsZTtcclxuICAgICAgfSk7XHJcbiAgICAgIGN1cnJlbnRSb3crKztcclxuXHJcbiAgICAgIC8vIE9yZGVuYXIgcG9yIGRhdGEgZSBhZGljaW9uYXIgdHJhbnNhw6fDtWVzXHJcbiAgICAgIGFwYWdhckludm9pY2VzLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGEuZGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5kYXRlKS5nZXRUaW1lKCkpO1xyXG4gICAgICBcclxuICAgICAgbGV0IGN1cnJlbnREYXRlID0gJyc7XHJcbiAgICAgIGxldCBkYWlseVRvdGFsID0gMDtcclxuXHJcbiAgICAgIGFwYWdhckludm9pY2VzLmZvckVhY2goaW52b2ljZSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW52b2ljZURhdGUgPSBuZXcgRGF0ZShpbnZvaWNlLmRhdGUpLnRvTG9jYWxlRGF0ZVN0cmluZygncHQtQlInKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBWZXJpZmljYXIgbXVkYW7Dp2EgZGUgZGF0YSBwYXJhIHRvdGFsIGRpw6FyaW9cclxuICAgICAgICBpZiAoY3VycmVudERhdGUgJiYgY3VycmVudERhdGUgIT09IGludm9pY2VEYXRlICYmIGRhaWx5VG90YWwgPiAwKSB7XHJcbiAgICAgICAgICB3b3Jrc2hlZXQuYWRkUm93KFsnJywgJycsICdUT1RBTCcsIGRhaWx5VG90YWxdKTtcclxuICAgICAgICAgIGNvbnN0IHRvdGFsUm93ID0gd29ya3NoZWV0LmdldFJvdyhjdXJyZW50Um93KTtcclxuICAgICAgICAgIHRvdGFsUm93LmVhY2hDZWxsKChjZWxsLCBjb2xOdW1iZXIpID0+IHtcclxuICAgICAgICAgICAgY2VsbC5zdHlsZSA9IHtcclxuICAgICAgICAgICAgICBmb250OiB7IGJvbGQ6IHRydWUgfSxcclxuICAgICAgICAgICAgICBmaWxsOiB7IHR5cGU6ICdwYXR0ZXJuJyBhcyBjb25zdCwgcGF0dGVybjogJ3NvbGlkJyBhcyBjb25zdCwgZmdDb2xvcjogeyBhcmdiOiAnRjJGMkYyJyB9IH0sXHJcbiAgICAgICAgICAgICAgbnVtRm10OiBjb2xOdW1iZXIgPT09IDQgPyAnUiQgIywjIzAuMDAnIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIGJvcmRlcjogY2VsbFN0eWxlLmJvcmRlcixcclxuICAgICAgICAgICAgICBhbGlnbm1lbnQ6IGNvbE51bWJlciA9PT0gMyA/IHsgaG9yaXpvbnRhbDogJ2NlbnRlcicgYXMgY29uc3QgfSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBjdXJyZW50Um93Kys7XHJcbiAgICAgICAgICBkYWlseVRvdGFsID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdvcmtzaGVldC5hZGRSb3coW1xyXG4gICAgICAgICAgaW52b2ljZURhdGUsXHJcbiAgICAgICAgICBpbnZvaWNlLnN1cHBsaWVyLFxyXG4gICAgICAgICAgaW52b2ljZS5pbnZvaWNlTnVtYmVyLFxyXG4gICAgICAgICAgaW52b2ljZS52YWx1ZU51bWVyaWNcclxuICAgICAgICBdKTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm93ID0gd29ya3NoZWV0LmdldFJvdyhjdXJyZW50Um93KTtcclxuICAgICAgICByb3cuZWFjaENlbGwoKGNlbGwsIGNvbE51bWJlcikgPT4ge1xyXG4gICAgICAgICAgY2VsbC5zdHlsZSA9IGNlbGxTdHlsZTtcclxuICAgICAgICAgIGlmIChjb2xOdW1iZXIgPT09IDQpIHtcclxuICAgICAgICAgICAgY2VsbC5udW1GbXQgPSAnUiQgIywjIzAuMDAnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjdXJyZW50RGF0ZSA9IGludm9pY2VEYXRlO1xyXG4gICAgICAgIGRhaWx5VG90YWwgKz0gaW52b2ljZS52YWx1ZU51bWVyaWM7XHJcbiAgICAgICAgY3VycmVudFJvdysrO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFRvdGFsIGZpbmFsIEFfUEFHQVJcclxuICAgICAgaWYgKGRhaWx5VG90YWwgPiAwKSB7XHJcbiAgICAgICAgd29ya3NoZWV0LmFkZFJvdyhbJycsICcnLCAnVE9UQUwnLCBkYWlseVRvdGFsXSk7XHJcbiAgICAgICAgY29uc3QgdG90YWxSb3cgPSB3b3Jrc2hlZXQuZ2V0Um93KGN1cnJlbnRSb3cpO1xyXG4gICAgICAgIHRvdGFsUm93LmVhY2hDZWxsKChjZWxsLCBjb2xOdW1iZXIpID0+IHtcclxuICAgICAgICAgIGNlbGwuc3R5bGUgPSB7XHJcbiAgICAgICAgICAgIGZvbnQ6IHsgYm9sZDogdHJ1ZSB9LFxyXG4gICAgICAgICAgICBmaWxsOiB7IHR5cGU6ICdwYXR0ZXJuJyBhcyBjb25zdCwgcGF0dGVybjogJ3NvbGlkJyBhcyBjb25zdCwgZmdDb2xvcjogeyBhcmdiOiAnRjJGMkYyJyB9IH0sXHJcbiAgICAgICAgICAgIG51bUZtdDogY29sTnVtYmVyID09PSA0ID8gJ1IkICMsIyMwLjAwJyA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYm9yZGVyOiBjZWxsU3R5bGUuYm9yZGVyLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnQ6IGNvbE51bWJlciA9PT0gMyA/IHsgaG9yaXpvbnRhbDogJ2NlbnRlcicgYXMgY29uc3QgfSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjdXJyZW50Um93Kys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHRvdGFsQVBhZ2FyUm93ID0gd29ya3NoZWV0LmFkZFJvdyhbJycsICcnLCAnVE9UQUwgQSBQQUdBUicsIGJyYW5jaC50b3RhbEFQYWdhcl0pO1xyXG4gICAgICB0b3RhbEFQYWdhclJvdy5lYWNoQ2VsbCgoY2VsbCwgY29sTnVtYmVyKSA9PiB7XHJcbiAgICAgICAgY2VsbC5zdHlsZSA9IHtcclxuICAgICAgICAgIC4uLnRvdGFsUm93U3R5bGUsXHJcbiAgICAgICAgICBudW1GbXQ6IGNvbE51bWJlciA9PT0gNCA/ICdSJCAjLCMjMC4wMCcgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICBib3JkZXI6IGNlbGxTdHlsZS5ib3JkZXJcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgICAgY3VycmVudFJvdysrO1xyXG5cclxuICAgICAgLy8gTGluaGEgdmF6aWFcclxuICAgICAgd29ya3NoZWV0LmFkZFJvdyhbXSk7XHJcbiAgICAgIGN1cnJlbnRSb3crKztcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm9jZXNzYXIgQV9SRUNFQkVSXHJcbiAgICBpZiAoYXJlY2ViZXJJbnZvaWNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGFSZWNlYmVySGVhZGVyUm93ID0gd29ya3NoZWV0LmFkZFJvdyhbJ0NPTlRBUyBBIFJFQ0VCRVInXSk7XHJcbiAgICAgIHdvcmtzaGVldC5tZXJnZUNlbGxzKGBBJHtjdXJyZW50Um93fTpEJHtjdXJyZW50Um93fWApO1xyXG4gICAgICBhUmVjZWJlckhlYWRlclJvdy5nZXRDZWxsKDEpLnN0eWxlID0gc3ViSGVhZGVyU3R5bGU7XHJcbiAgICAgIGN1cnJlbnRSb3crKztcclxuXHJcbiAgICAgIHdvcmtzaGVldC5hZGRSb3coW10pO1xyXG4gICAgICBjdXJyZW50Um93Kys7XHJcblxyXG4gICAgICAvLyBDYWJlw6dhbGhvcyBkYXMgdHJhbnNhw6fDtWVzIEFfUkVDRUJFUlxyXG4gICAgICBjb25zdCB0cmFuc0hlYWRlclJvdyA9IHdvcmtzaGVldC5hZGRSb3coWydWZW5jaW1lbnRvJywgJ0NsaWVudGUnLCAnRG9jdW1lbnRvJywgJ1ZhbG9yJ10pO1xyXG4gICAgICB0cmFuc0hlYWRlclJvdy5lYWNoQ2VsbCgoY2VsbCkgPT4ge1xyXG4gICAgICAgIGNlbGwuc3R5bGUgPSBoZWFkZXJTdHlsZTtcclxuICAgICAgfSk7XHJcbiAgICAgIGN1cnJlbnRSb3crKztcclxuXHJcbiAgICAgIC8vIE9yZGVuYXIgcG9yIGRhdGEgZSBhZGljaW9uYXIgdHJhbnNhw6fDtWVzXHJcbiAgICAgIGFyZWNlYmVySW52b2ljZXMuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYS5kYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLmRhdGUpLmdldFRpbWUoKSk7XHJcbiAgICAgIFxyXG4gICAgICBsZXQgY3VycmVudERhdGUgPSAnJztcclxuICAgICAgbGV0IGRhaWx5VG90YWwgPSAwO1xyXG5cclxuICAgICAgYXJlY2ViZXJJbnZvaWNlcy5mb3JFYWNoKGludm9pY2UgPT4ge1xyXG4gICAgICAgIGNvbnN0IGludm9pY2VEYXRlID0gbmV3IERhdGUoaW52b2ljZS5kYXRlKS50b0xvY2FsZURhdGVTdHJpbmcoJ3B0LUJSJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVmVyaWZpY2FyIG11ZGFuw6dhIGRlIGRhdGEgcGFyYSB0b3RhbCBkacOhcmlvXHJcbiAgICAgICAgaWYgKGN1cnJlbnREYXRlICYmIGN1cnJlbnREYXRlICE9PSBpbnZvaWNlRGF0ZSAmJiBkYWlseVRvdGFsID4gMCkge1xyXG4gICAgICAgICAgd29ya3NoZWV0LmFkZFJvdyhbJycsICcnLCAnVE9UQUwnLCBkYWlseVRvdGFsXSk7XHJcbiAgICAgICAgICBjb25zdCB0b3RhbFJvdyA9IHdvcmtzaGVldC5nZXRSb3coY3VycmVudFJvdyk7XHJcbiAgICAgICAgICB0b3RhbFJvdy5lYWNoQ2VsbCgoY2VsbCwgY29sTnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGNlbGwuc3R5bGUgPSB7XHJcbiAgICAgICAgICAgICAgZm9udDogeyBib2xkOiB0cnVlIH0sXHJcbiAgICAgICAgICAgICAgZmlsbDogeyB0eXBlOiAncGF0dGVybicgYXMgY29uc3QsIHBhdHRlcm46ICdzb2xpZCcgYXMgY29uc3QsIGZnQ29sb3I6IHsgYXJnYjogJ0YyRjJGMicgfSB9LFxyXG4gICAgICAgICAgICAgIG51bUZtdDogY29sTnVtYmVyID09PSA0ID8gJ1IkICMsIyMwLjAwJyA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICBib3JkZXI6IGNlbGxTdHlsZS5ib3JkZXIsXHJcbiAgICAgICAgICAgICAgYWxpZ25tZW50OiBjb2xOdW1iZXIgPT09IDMgPyB7IGhvcml6b250YWw6ICdjZW50ZXInIGFzIGNvbnN0IH0gOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY3VycmVudFJvdysrO1xyXG4gICAgICAgICAgZGFpbHlUb3RhbCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3b3Jrc2hlZXQuYWRkUm93KFtcclxuICAgICAgICAgIGludm9pY2VEYXRlLFxyXG4gICAgICAgICAgaW52b2ljZS5zdXBwbGllcixcclxuICAgICAgICAgIGludm9pY2UuaW52b2ljZU51bWJlcixcclxuICAgICAgICAgIGludm9pY2UudmFsdWVOdW1lcmljXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvdyA9IHdvcmtzaGVldC5nZXRSb3coY3VycmVudFJvdyk7XHJcbiAgICAgICAgcm93LmVhY2hDZWxsKChjZWxsLCBjb2xOdW1iZXIpID0+IHtcclxuICAgICAgICAgIGNlbGwuc3R5bGUgPSBjZWxsU3R5bGU7XHJcbiAgICAgICAgICBpZiAoY29sTnVtYmVyID09PSA0KSB7XHJcbiAgICAgICAgICAgIGNlbGwubnVtRm10ID0gJ1IkICMsIyMwLjAwJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY3VycmVudERhdGUgPSBpbnZvaWNlRGF0ZTtcclxuICAgICAgICBkYWlseVRvdGFsICs9IGludm9pY2UudmFsdWVOdW1lcmljO1xyXG4gICAgICAgIGN1cnJlbnRSb3crKztcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBUb3RhbCBmaW5hbCBBX1JFQ0VCRVJcclxuICAgICAgaWYgKGRhaWx5VG90YWwgPiAwKSB7XHJcbiAgICAgICAgd29ya3NoZWV0LmFkZFJvdyhbJycsICcnLCAnVE9UQUwnLCBkYWlseVRvdGFsXSk7XHJcbiAgICAgICAgY29uc3QgdG90YWxSb3cgPSB3b3Jrc2hlZXQuZ2V0Um93KGN1cnJlbnRSb3cpO1xyXG4gICAgICAgIHRvdGFsUm93LmVhY2hDZWxsKChjZWxsLCBjb2xOdW1iZXIpID0+IHtcclxuICAgICAgICAgIGNlbGwuc3R5bGUgPSB7XHJcbiAgICAgICAgICAgIGZvbnQ6IHsgYm9sZDogdHJ1ZSB9LFxyXG4gICAgICAgICAgICBmaWxsOiB7IHR5cGU6ICdwYXR0ZXJuJyBhcyBjb25zdCwgcGF0dGVybjogJ3NvbGlkJyBhcyBjb25zdCwgZmdDb2xvcjogeyBhcmdiOiAnRjJGMkYyJyB9IH0sXHJcbiAgICAgICAgICAgIG51bUZtdDogY29sTnVtYmVyID09PSA0ID8gJ1IkICMsIyMwLjAwJyA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYm9yZGVyOiBjZWxsU3R5bGUuYm9yZGVyLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnQ6IGNvbE51bWJlciA9PT0gMyA/IHsgaG9yaXpvbnRhbDogJ2NlbnRlcicgYXMgY29uc3QgfSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjdXJyZW50Um93Kys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHRvdGFsQVJlY2ViZXJSb3cgPSB3b3Jrc2hlZXQuYWRkUm93KFsnJywgJycsICdUT1RBTCBBIFJFQ0VCRVInLCBicmFuY2gudG90YWxBUmVjZWJlcl0pO1xyXG4gICAgICB0b3RhbEFSZWNlYmVyUm93LmVhY2hDZWxsKChjZWxsLCBjb2xOdW1iZXIpID0+IHtcclxuICAgICAgICBjZWxsLnN0eWxlID0ge1xyXG4gICAgICAgICAgLi4udG90YWxSb3dTdHlsZSxcclxuICAgICAgICAgIG51bUZtdDogY29sTnVtYmVyID09PSA0ID8gJ1IkICMsIyMwLjAwJyA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgIGJvcmRlcjogY2VsbFN0eWxlLmJvcmRlclxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgICBjdXJyZW50Um93Kys7XHJcbiAgICB9XHJcblxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBNZW5zYWdlbSBxdWFuZG8gbsOjbyBow6EgdHJhbnNhw6fDtWVzIGRldGFsaGFkYXNcclxuICAgIGNvbnN0IG5vRGF0YVJvdyA9IHdvcmtzaGVldC5hZGRSb3coWydUUkFOU0HDh8OVRVMgREVUQUxIQURBUyddKTtcclxuICAgIHdvcmtzaGVldC5tZXJnZUNlbGxzKGBBJHtjdXJyZW50Um93fTpEJHtjdXJyZW50Um93fWApO1xyXG4gICAgbm9EYXRhUm93LmdldENlbGwoMSkuc3R5bGUgPSBzdWJIZWFkZXJTdHlsZTtcclxuICAgIGN1cnJlbnRSb3crKztcclxuXHJcbiAgICB3b3Jrc2hlZXQuYWRkUm93KFtdKTtcclxuICAgIGN1cnJlbnRSb3crKztcclxuICAgIHdvcmtzaGVldC5hZGRSb3coWydEYWRvcyBkZXRhbGhhZG9zIGRhcyB0cmFuc2HDp8O1ZXMgc2Vyw6NvIGV4aWJpZG9zIGFxdWkgcXVhbmRvIGRpc3BvbsOtdmVpcy4nXSk7XHJcbiAgICB3b3Jrc2hlZXQuYWRkUm93KFsnUGFyYSBvYnRlciBkZXRhbGhlcywgZmHDp2EgdXBsb2FkIGRvcyBhcnF1aXZvcyBDU1YgaW5kaXZpZHVhaXMuJ10pO1xyXG4gIH1cclxuXHJcbiAgLy8gQWp1c3RhciBsYXJndXJhIGRhcyBjb2x1bmFzXHJcbiAgd29ya3NoZWV0LmNvbHVtbnMgPSBbXHJcbiAgICB7IHdpZHRoOiAxNSB9LCAvLyBWZW5jaW1lbnRvXHJcbiAgICB7IHdpZHRoOiA0MCB9LCAvLyBUcmFuc2FjaW9uYWRvci9DbGllbnRlXHJcbiAgICB7IHdpZHRoOiAyMCB9LCAvLyBEb2N1bWVudG9cclxuICAgIHsgd2lkdGg6IDE4IH0gIC8vIFZhbG9yXHJcbiAgXTtcclxufVxyXG5cclxuLy8gRnVuw6fDo28gcGFyYSBjcmlhciBhIGFiYSBkZSByZXN1bW8gZ2VyYWxcclxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlUmVzdW1vR2VyYWxXb3Jrc2hlZXQod29ya2Jvb2s6IEV4Y2VsSlMuV29ya2Jvb2ssIHN1bW1hcnlEYXRhOiBTdW1tYXJ5RGF0YSkge1xyXG4gIGNvbnN0IHdvcmtzaGVldCA9IHdvcmtib29rLmFkZFdvcmtzaGVldCgnUmVzdW1vIEdlcmFsJyk7XHJcbiAgXHJcbiAgLy8gVMOtdHVsbyBwcmluY2lwYWxcclxuICBjb25zdCB0aXRsZVJvdyA9IHdvcmtzaGVldC5hZGRSb3coWydSRVNVTU8gR0VSQUwgLSBTQUxETyBMw41RVUlETyBQT1IgRklMSUFMJ10pO1xyXG4gIHdvcmtzaGVldC5tZXJnZUNlbGxzKCdBMTpEMScpO1xyXG4gIHRpdGxlUm93LmdldENlbGwoMSkuZmlsbCA9IHsgdHlwZTogJ3BhdHRlcm4nLCBwYXR0ZXJuOiAnc29saWQnLCBmZ0NvbG9yOiB7IGFyZ2I6ICdGRjQ0NzJDNCcgfSB9O1xyXG4gIHRpdGxlUm93LmdldENlbGwoMSkuZm9udCA9IHsgYm9sZDogdHJ1ZSwgY29sb3I6IHsgYXJnYjogJ0ZGRkZGRkZGJyB9LCBzaXplOiAxNiB9O1xyXG4gIHRpdGxlUm93LmdldENlbGwoMSkuYWxpZ25tZW50ID0geyBob3Jpem9udGFsOiAnY2VudGVyJywgdmVydGljYWw6ICdtaWRkbGUnIH07XHJcbiAgdGl0bGVSb3cuaGVpZ2h0ID0gMzA7XHJcbiAgXHJcbiAgd29ya3NoZWV0LmFkZFJvdyhbXSk7IC8vIExpbmhhIHZhemlhXHJcbiAgXHJcbiAgLy8gQ2FiZcOnYWxob3NcclxuICBjb25zdCBoZWFkZXJSb3cgPSB3b3Jrc2hlZXQuYWRkUm93KFsnRklMSUFMJywgJ1RPVEFMIEEgUEFHQVInLCAnVE9UQUwgQSBSRUNFQkVSJywgJ1NBTERPIEzDjVFVSURPJ10pO1xyXG4gIGhlYWRlclJvdy5mb250ID0geyBib2xkOiB0cnVlLCBjb2xvcjogeyBhcmdiOiAnRkZGRkZGRkYnIH0gfTtcclxuICBoZWFkZXJSb3cuZmlsbCA9IHsgdHlwZTogJ3BhdHRlcm4nLCBwYXR0ZXJuOiAnc29saWQnLCBmZ0NvbG9yOiB7IGFyZ2I6ICdGRjQ0NzJDNCcgfSB9O1xyXG4gIGhlYWRlclJvdy5hbGlnbm1lbnQgPSB7IGhvcml6b250YWw6ICdjZW50ZXInLCB2ZXJ0aWNhbDogJ21pZGRsZScgfTtcclxuICBcclxuICAvLyBEYWRvcyBkYXMgZmlsaWFpc1xyXG4gIHN1bW1hcnlEYXRhLmJyYW5jaGVzLmZvckVhY2goYnJhbmNoID0+IHtcclxuICAgIGNvbnN0IHNhbGRvTGlxdWlkbyA9IGJyYW5jaC50b3RhbEFSZWNlYmVyIC0gYnJhbmNoLnRvdGFsQVBhZ2FyO1xyXG4gICAgY29uc3Qgcm93ID0gd29ya3NoZWV0LmFkZFJvdyhbXHJcbiAgICAgIGJyYW5jaC5uYW1lLFxyXG4gICAgICBgUiQgJHticmFuY2gudG90YWxBUGFnYXIudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSl9YCxcclxuICAgICAgYFIkICR7YnJhbmNoLnRvdGFsQVJlY2ViZXIudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSl9YCxcclxuICAgICAgYFIkICR7c2FsZG9MaXF1aWRvLnRvTG9jYWxlU3RyaW5nKCdwdC1CUicsIHsgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyIH0pfWBcclxuICAgIF0pO1xyXG4gICAgXHJcbiAgICAvLyBDb2xvcmlyIHNhbGRvIGzDrXF1aWRvIGNvbmZvcm1lIHZhbG9yXHJcbiAgICBjb25zdCBzYWxkb0NlbGwgPSByb3cuZ2V0Q2VsbCg0KTtcclxuICAgIGlmIChzYWxkb0xpcXVpZG8gPiAwKSB7XHJcbiAgICAgIHNhbGRvQ2VsbC5mb250ID0geyBjb2xvcjogeyBhcmdiOiAnRkYwMDgwMDAnIH0sIGJvbGQ6IHRydWUgfTsgLy8gVmVyZGVcclxuICAgIH0gZWxzZSBpZiAoc2FsZG9MaXF1aWRvIDwgMCkge1xyXG4gICAgICBzYWxkb0NlbGwuZm9udCA9IHsgY29sb3I6IHsgYXJnYjogJ0ZGRkYwMDAwJyB9LCBib2xkOiB0cnVlIH07IC8vIFZlcm1lbGhvXHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gTGluaGEgZGUgdG90YWwgZ2VyYWxcclxuICB3b3Jrc2hlZXQuYWRkUm93KFtdKTsgLy8gTGluaGEgdmF6aWFcclxuICBjb25zdCB0b3RhbFJvdyA9IHdvcmtzaGVldC5hZGRSb3coW1xyXG4gICAgJ1RPVEFMIEdFUkFMJyxcclxuICAgIGBSJCAke3N1bW1hcnlEYXRhLmdyYW5kVG90YWxBUGFnYXIudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSl9YCxcclxuICAgIGBSJCAke3N1bW1hcnlEYXRhLmdyYW5kVG90YWxBUmVjZWJlci50b0xvY2FsZVN0cmluZygncHQtQlInLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gLFxyXG4gICAgYFIkICR7KHN1bW1hcnlEYXRhLmdyYW5kVG90YWxBUmVjZWJlciAtIHN1bW1hcnlEYXRhLmdyYW5kVG90YWxBUGFnYXIpLnRvTG9jYWxlU3RyaW5nKCdwdC1CUicsIHsgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyIH0pfWBcclxuICBdKTtcclxuICBcclxuICB0b3RhbFJvdy5mb250ID0geyBib2xkOiB0cnVlLCBzaXplOiAxMiB9O1xyXG4gIHRvdGFsUm93LmZpbGwgPSB7IHR5cGU6ICdwYXR0ZXJuJywgcGF0dGVybjogJ3NvbGlkJywgZmdDb2xvcjogeyBhcmdiOiAnRkZFMEUwRTAnIH0gfTtcclxuICBcclxuICAvLyBBanVzdGFyIGxhcmd1cmEgZGFzIGNvbHVuYXNcclxuICB3b3Jrc2hlZXQuY29sdW1ucyA9IFtcclxuICAgIHsgd2lkdGg6IDIwIH0sIC8vIEZpbGlhbFxyXG4gICAgeyB3aWR0aDogMTggfSwgLy8gVG90YWwgQSBQYWdhclxyXG4gICAgeyB3aWR0aDogMTggfSwgLy8gVG90YWwgQSBSZWNlYmVyXHJcbiAgICB7IHdpZHRoOiAxOCB9ICAvLyBTYWxkbyBMw61xdWlkb1xyXG4gIF07XHJcbiAgXHJcbiAgLy8gQWRpY2lvbmFyIGJvcmRhc1xyXG4gIGNvbnN0IGRhdGFSYW5nZSA9IHdvcmtzaGVldC5nZXRSb3dzKDMsIHdvcmtzaGVldC5yb3dDb3VudCAtIDIpO1xyXG4gIGRhdGFSYW5nZT8uZm9yRWFjaChyb3cgPT4ge1xyXG4gICAgcm93LmVhY2hDZWxsKGNlbGwgPT4ge1xyXG4gICAgICBjZWxsLmJvcmRlciA9IHtcclxuICAgICAgICB0b3A6IHsgc3R5bGU6ICd0aGluJyB9LFxyXG4gICAgICAgIGxlZnQ6IHsgc3R5bGU6ICd0aGluJyB9LFxyXG4gICAgICAgIGJvdHRvbTogeyBzdHlsZTogJ3RoaW4nIH0sXHJcbiAgICAgICAgcmlnaHQ6IHsgc3R5bGU6ICd0aGluJyB9XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuLy8gRnVuw6fDo28gcGFyYSBjcmlhciBhYmEgaW5kaXZpZHVhbCBkYSBmaWxpYWxcclxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQnJhbmNoV29ya3NoZWV0KHdvcmtib29rOiBFeGNlbEpTLldvcmtib29rLCBicmFuY2g6IEJyYW5jaERhdGEsIHByb2Nlc3NlZERhdGE/OiBQcm9jZXNzZWREYXRhKSB7XHJcbiAgY29uc3Qgd29ya3NoZWV0ID0gd29ya2Jvb2suYWRkV29ya3NoZWV0KGJyYW5jaC5uYW1lKTtcclxuICBcclxuICAvLyBUw610dWxvIGRhIGZpbGlhbFxyXG4gIGNvbnN0IHRpdGxlUm93ID0gd29ya3NoZWV0LmFkZFJvdyhbYERFVEFMSEFNRU5UTyAtICR7YnJhbmNoLm5hbWV9YF0pO1xyXG4gIHdvcmtzaGVldC5tZXJnZUNlbGxzKCdBMTpEMScpO1xyXG4gIHRpdGxlUm93LmdldENlbGwoMSkuZmlsbCA9IHsgdHlwZTogJ3BhdHRlcm4nLCBwYXR0ZXJuOiAnc29saWQnLCBmZ0NvbG9yOiB7IGFyZ2I6ICdGRjQ0NzJDNCcgfSB9O1xyXG4gIHRpdGxlUm93LmdldENlbGwoMSkuZm9udCA9IHsgYm9sZDogdHJ1ZSwgY29sb3I6IHsgYXJnYjogJ0ZGRkZGRkZGJyB9LCBzaXplOiAxNCB9O1xyXG4gIHRpdGxlUm93LmdldENlbGwoMSkuYWxpZ25tZW50ID0geyBob3Jpem9udGFsOiAnY2VudGVyJywgdmVydGljYWw6ICdtaWRkbGUnIH07XHJcbiAgdGl0bGVSb3cuaGVpZ2h0ID0gMjU7XHJcbiAgXHJcbiAgd29ya3NoZWV0LmFkZFJvdyhbXSk7IC8vIExpbmhhIHZhemlhXHJcbiAgXHJcbiAgLy8gRGV0YWxoYW1lbnRvIGRlIHRyYW5zYcOnw7VlcyAoc2UgZGlzcG9uw612ZWwpXHJcbiAgaWYgKHByb2Nlc3NlZERhdGEgJiYgcHJvY2Vzc2VkRGF0YS50cmFuc2FjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25zSGVhZGVyUm93ID0gd29ya3NoZWV0LmFkZFJvdyhbJ0RFVEFMSEFNRU5UTyBERSBUUkFOU0HDh8OVRVMnXSk7XHJcbiAgICB3b3Jrc2hlZXQubWVyZ2VDZWxscyhgQSR7d29ya3NoZWV0LnJvd0NvdW50fTpEJHt3b3Jrc2hlZXQucm93Q291bnR9YCk7XHJcbiAgICB0cmFuc2FjdGlvbnNIZWFkZXJSb3cuZ2V0Q2VsbCgxKS5mb250ID0geyBib2xkOiB0cnVlLCBzaXplOiAxMiB9O1xyXG4gICAgdHJhbnNhY3Rpb25zSGVhZGVyUm93LmdldENlbGwoMSkuZmlsbCA9IHsgdHlwZTogJ3BhdHRlcm4nLCBwYXR0ZXJuOiAnc29saWQnLCBmZ0NvbG9yOiB7IGFyZ2I6ICdGRkUwRTBFMCcgfSB9O1xyXG4gICAgdHJhbnNhY3Rpb25zSGVhZGVyUm93LmdldENlbGwoMSkuYWxpZ25tZW50ID0geyBob3Jpem9udGFsOiAnY2VudGVyJyB9O1xyXG4gICAgXHJcbiAgICB3b3Jrc2hlZXQuYWRkUm93KFtdKTsgLy8gTGluaGEgdmF6aWFcclxuICAgIFxyXG4gICAgLy8gQ2FiZcOnYWxob3MgZGFzIHRyYW5zYcOnw7Vlc1xyXG4gICAgY29uc3QgdHJhbnNIZWFkZXJSb3cgPSB3b3Jrc2hlZXQuYWRkUm93KFsnVmVuY2ltZW50bycsICdUcmFuc2FjaW9uYWRvcicsICdEb2N1bWVudG8nLCAnVmFsb3InLCAnVGlwbyddKTtcclxuICAgIHRyYW5zSGVhZGVyUm93LmZvbnQgPSB7IGJvbGQ6IHRydWUsIGNvbG9yOiB7IGFyZ2I6ICdGRkZGRkZGRicgfSB9O1xyXG4gICAgdHJhbnNIZWFkZXJSb3cuZmlsbCA9IHsgdHlwZTogJ3BhdHRlcm4nLCBwYXR0ZXJuOiAnc29saWQnLCBmZ0NvbG9yOiB7IGFyZ2I6ICdGRjQ0NzJDNCcgfSB9O1xyXG4gICAgXHJcbiAgICAvLyBEYWRvcyBkYXMgdHJhbnNhw6fDtWVzXHJcbiAgICBwcm9jZXNzZWREYXRhLnRyYW5zYWN0aW9ucy5mb3JFYWNoKHRyYW5zYWN0aW9uID0+IHtcclxuICAgICAgY29uc3QgdGlwbyA9IHRyYW5zYWN0aW9uLnZhbG9yTnVtZXJpY28gPiAwID8gJ0EgUGFnYXInIDogJ0EgUmVjZWJlcic7XHJcbiAgICAgIHdvcmtzaGVldC5hZGRSb3coW1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLnZlbmNpbWVudG8sXHJcbiAgICAgICAgdHJhbnNhY3Rpb24udHJhbnNhY2lvbmFkb3IsXHJcbiAgICAgICAgdHJhbnNhY3Rpb24uZG9jdW1lbnRvLFxyXG4gICAgICAgIHRyYW5zYWN0aW9uLnZhbG9yLFxyXG4gICAgICAgIHRpcG9cclxuICAgICAgXSk7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gTWVuc2FnZW0gcXVhbmRvIG7Do28gaMOhIHRyYW5zYcOnw7VlcyBkZXRhbGhhZGFzXHJcbiAgICBjb25zdCBub0RhdGFSb3cgPSB3b3Jrc2hlZXQuYWRkUm93KFsnVFJBTlNBw4fDlUVTIERFVEFMSEFEQVMnXSk7XHJcbiAgICB3b3Jrc2hlZXQubWVyZ2VDZWxscyhgQSR7d29ya3NoZWV0LnJvd0NvdW50fTpEJHt3b3Jrc2hlZXQucm93Q291bnR9YCk7XHJcbiAgICBub0RhdGFSb3cuZ2V0Q2VsbCgxKS5mb250ID0geyBib2xkOiB0cnVlLCBzaXplOiAxMiB9O1xyXG4gICAgbm9EYXRhUm93LmdldENlbGwoMSkuZmlsbCA9IHsgdHlwZTogJ3BhdHRlcm4nLCBwYXR0ZXJuOiAnc29saWQnLCBmZ0NvbG9yOiB7IGFyZ2I6ICdGRkUwRTBFMCcgfSB9O1xyXG4gICAgbm9EYXRhUm93LmdldENlbGwoMSkuYWxpZ25tZW50ID0geyBob3Jpem9udGFsOiAnY2VudGVyJyB9O1xyXG4gICAgXHJcbiAgICB3b3Jrc2hlZXQuYWRkUm93KFtdKTsgLy8gTGluaGEgdmF6aWFcclxuICAgIHdvcmtzaGVldC5hZGRSb3coWydEYWRvcyBkZXRhbGhhZG9zIGRhcyB0cmFuc2HDp8O1ZXMgc2Vyw6NvIGV4aWJpZG9zIGFxdWkgcXVhbmRvIGRpc3BvbsOtdmVpcy4nXSk7XHJcbiAgICB3b3Jrc2hlZXQuYWRkUm93KFsnUGFyYSBvYnRlciBkZXRhbGhlcywgZmHDp2EgdXBsb2FkIGRvcyBhcnF1aXZvcyBDU1YgaW5kaXZpZHVhaXMuJ10pO1xyXG4gIH1cclxuICBcclxuICAvLyBBanVzdGFyIGxhcmd1cmEgZGFzIGNvbHVuYXNcclxuICB3b3Jrc2hlZXQuY29sdW1ucyA9IFtcclxuICAgIHsgd2lkdGg6IDE1IH0sIC8vIFZlbmNpbWVudG9cclxuICAgIHsgd2lkdGg6IDI1IH0sIC8vIFRyYW5zYWNpb25hZG9yXHJcbiAgICB7IHdpZHRoOiAxNSB9LCAvLyBEb2N1bWVudG9cclxuICAgIHsgd2lkdGg6IDE4IH0sIC8vIFZhbG9yXHJcbiAgICB7IHdpZHRoOiAxMiB9ICAvLyBUaXBvXHJcbiAgXTtcclxuICBcclxuICAvLyBBZGljaW9uYXIgYm9yZGFzIG5hcyBjw6lsdWxhcyBpbXBvcnRhbnRlc1xyXG4gIGNvbnN0IGFsbFJvd3MgPSB3b3Jrc2hlZXQuZ2V0Um93cygxLCB3b3Jrc2hlZXQucm93Q291bnQpO1xyXG4gIGFsbFJvd3M/LmZvckVhY2gocm93ID0+IHtcclxuICAgIHJvdy5lYWNoQ2VsbChjZWxsID0+IHtcclxuICAgICAgaWYgKGNlbGwudmFsdWUpIHtcclxuICAgICAgICBjZWxsLmJvcmRlciA9IHtcclxuICAgICAgICAgIHRvcDogeyBzdHlsZTogJ3RoaW4nIH0sXHJcbiAgICAgICAgICBsZWZ0OiB7IHN0eWxlOiAndGhpbicgfSxcclxuICAgICAgICAgIGJvdHRvbTogeyBzdHlsZTogJ3RoaW4nIH0sXHJcbiAgICAgICAgICByaWdodDogeyBzdHlsZTogJ3RoaW4nIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxufSJdLCJuYW1lcyI6WyJFeGNlbEpTIiwiZnMiLCJwYXRoIiwicGFyc2VQdEJyRGF0ZSIsImRhdGVTdHIiLCJEYXRlIiwidHJpbW1lZCIsInRyaW0iLCJtIiwibWF0Y2giLCJkIiwicGFyc2VJbnQiLCJtbyIsInkiLCJkdCIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiaXNvIiwiaXNOYU4iLCJnZXRUaW1lIiwiaGVhZGVyU3R5bGUiLCJmb250IiwiYm9sZCIsImNvbG9yIiwiYXJnYiIsImZpbGwiLCJ0eXBlIiwicGF0dGVybiIsImZnQ29sb3IiLCJhbGlnbm1lbnQiLCJob3Jpem9udGFsIiwidmVydGljYWwiLCJib3JkZXIiLCJ0b3AiLCJzdHlsZSIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsImNlbGxTdHlsZSIsInRpdGxlU3R5bGUiLCJzaXplIiwic3ViSGVhZGVyU3R5bGUiLCJ0b3RhbFJvd1N0eWxlIiwiaGFuZGxlciIsInJlcSIsInJlcyIsImNvbnNvbGUiLCJsb2ciLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIk9iamVjdCIsImtleXMiLCJuYW1lIiwicmVwb3J0TmFtZSIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJjYXRlZ29yaWVzIiwicHJvY2Vzc2VkRGF0YSIsInN1bW1hcnlEYXRhIiwiYWxsSW52b2ljZXMiLCJhbGxCcmFuY2hTdW1tYXJpZXMiLCJBcnJheSIsImlzQXJyYXkiLCJ0cmFuc2FjdGlvbnMiLCJsZW5ndGgiLCJzbGljZSIsInJlYWxEYXRhIiwiYnJhbmNoTWFwIiwiTWFwIiwiYWxsVHJhbnNhY3Rpb25zIiwiZm9yRWFjaCIsInRyYW5zYWN0aW9uIiwiaW5kZXgiLCJ3YXJuIiwidmVuY2ltZW50byIsInRyYW5zYWNpb25hZG9yIiwidmFsb3IiLCJ2YWxvck51bWVyaWNvIiwidGlwbyIsImRvY3VtZW50VHlwZSIsImJyYW5jaCIsImZpbGlhbCIsImJyYW5jaFRvdGFscyIsInNvdXJjZUZpbGUiLCJoYXMiLCJzZXQiLCJ0b3RhbEFQYWdhciIsInRvdGFsQVJlY2ViZXIiLCJicmFuY2hEYXRhIiwiZ2V0IiwicGFyc2VkRGF0ZSIsIk51bWJlciIsIk1hdGgiLCJhYnMiLCJwdXNoIiwiaWQiLCJpbnZvaWNlTnVtYmVyIiwiZG9jdW1lbnRvIiwiZGF0ZSIsInZhbHVlIiwic3VwcGxpZXIiLCJ2YWx1ZU51bWVyaWMiLCJ0cmFuc2FjdGlvbkVyciIsImVycm9yIiwiYnJhbmNoZXMiLCJmcm9tIiwiZW50cmllcyIsIm1hcCIsInRvdGFscyIsInRvdGFsIiwiZGF0ZVNwZWNpZmljVG90YWxzIiwiZ3JhbmRUb3RhbCIsInJlZHVjZSIsInN1bSIsImIiLCJncmFuZFRvdGFsQVBhZ2FyIiwiZ3JhbmRUb3RhbEFSZWNlYmVyIiwiaW52b2ljZUNvdW50IiwiZmlsdGVyIiwiaW52IiwidG90YWxWYWx1ZSIsInRvTG9jYWxlU3RyaW5nIiwiY3VycmVuY3kiLCJjYWNoZVBhdGgiLCJqb2luIiwicHJvY2VzcyIsImN3ZCIsImV4aXN0c1N5bmMiLCJjYWNoZWQiLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZVN5bmMiLCJ0cmFuc2FjdGlvbnNFcnIiLCJjYWNoZUVyciIsImRheSIsImdlbmVyYXRlU2ltdWxhdGVkSW52b2ljZXMiLCJmbG9vciIsInJhbmRvbSIsImFjdHVhbFN0YXJ0RGF0ZSIsImFjdHVhbEVuZERhdGUiLCJpbnZvaWNlRGF0ZXMiLCJzb3J0IiwiYSIsImRpc3RpbmN0RmlsZXMiLCJTZXQiLCJpIiwiZGlzdGluY3RCcmFuY2hlcyIsInRvdGFsSW52b2ljZXMiLCJmaWxlcyIsIndvcmtib29rIiwiV29ya2Jvb2siLCJjcmVhdGVBZHZhbmNlZFN1bW1hcnlXb3Jrc2hlZXQiLCJleGlzdGluZ1dvcmtzaGVldE5hbWVzIiwiYWRkIiwiYnJhbmNoSW52b2ljZXMiLCJjcmVhdGVBZHZhbmNlZEJyYW5jaFdvcmtzaGVldCIsImZpbGVOYW1lIiwidG9JU09TdHJpbmciLCJzcGxpdCIsInNldEhlYWRlciIsInhsc3giLCJ3cml0ZSIsImVuZCIsIkVycm9yIiwic3RhY2siLCJleGlzdHMiLCJoYXNQcm9jZXNzZWREYXRhIiwicHJvY2Vzc2VkRGF0YVR5cGUiLCJoZWFkZXJzU2VudCIsInN0YXR1cyIsImpzb24iLCJzdWNjZXNzIiwibWVzc2FnZSIsImVycm9yRGV0YWlscyIsInN1YnN0cmluZyIsImludm9pY2VzIiwiaWRDb3VudGVyIiwibnVtSW52b2ljZXNBUGFnYXIiLCJhdmVyYWdlVmFsdWUiLCJzZXREYXRlIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJmcm9tQ2hhckNvZGUiLCJudW1JbnZvaWNlc0FSZWNlYmVyIiwic3VtbWFyeVNoZWV0IiwiYWRkV29ya3NoZWV0Iiwic3VtbWFyeUN1cnJlbnRSb3ciLCJhZGRSb3ciLCJtZXJnZUNlbGxzIiwiZ2V0Q2VsbCIsImdldFJvdyIsImhlaWdodCIsInBlcmlvZFRleHQiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJlYWNoQ2VsbCIsImNlbGwiLCJpbnZvaWNlc0J5RmlsZUFuZFR5cGUiLCJpbnZvaWNlIiwiQV9QQUdBUiIsIkFfUkVDRUJFUiIsImZpbGVUeXBlcyIsImRvY1R5cGUiLCJmaWxlSW52b2ljZXMiLCJ0eXBlTGFiZWwiLCJjbGVhbkZpbGVOYW1lIiwicmVwbGFjZSIsImN1cnJlbnREYXRlIiwiZGFpbHlUb3RhbCIsImludm9pY2VEYXRlIiwiaW52b2ljZVZhbHVlIiwidG90YWxSb3ciLCJjb2xOdW1iZXIiLCJudW1GbXQiLCJ1bmRlZmluZWQiLCJyb3ciLCJjYXRlZ29yeVRvdGFsIiwiY2F0ZWdvcnlUb3RhbFJvdyIsImdyYW5kVG90YWxSb3ciLCJnZXRDb2x1bW4iLCJ3aWR0aCIsImdlbmVyYXRlVW5pcXVlV29ya3NoZWV0TmFtZSIsImJhc2VOYW1lIiwiZXhpc3RpbmdOYW1lcyIsImNsZWFuTmFtZSIsImNvdW50ZXIiLCJ1bmlxdWVOYW1lIiwid29ya3NoZWV0IiwiY3VycmVudFJvdyIsInRpdGxlUm93IiwiYnJhbmNoRGF0ZXMiLCJhcGFnYXJJbnZvaWNlcyIsImFyZWNlYmVySW52b2ljZXMiLCJhUGFnYXJIZWFkZXJSb3ciLCJ0cmFuc0hlYWRlclJvdyIsInRvdGFsQVBhZ2FyUm93IiwiYVJlY2ViZXJIZWFkZXJSb3ciLCJ0b3RhbEFSZWNlYmVyUm93Iiwibm9EYXRhUm93IiwiY29sdW1ucyIsImNyZWF0ZVJlc3Vtb0dlcmFsV29ya3NoZWV0IiwiaGVhZGVyUm93Iiwic2FsZG9MaXF1aWRvIiwibWluaW11bUZyYWN0aW9uRGlnaXRzIiwic2FsZG9DZWxsIiwiZGF0YVJhbmdlIiwiZ2V0Um93cyIsInJvd0NvdW50IiwiY3JlYXRlQnJhbmNoV29ya3NoZWV0IiwidHJhbnNhY3Rpb25zSGVhZGVyUm93IiwiYWxsUm93cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/export-excel.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexport-excel&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexport-excel.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();